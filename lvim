diff --git a/scripts/ldm_rpa.jl b/scripts/ldm_rpa.jl
deleted file mode 100644
index aa21271..0000000
--- a/scripts/ldm_rpa.jl
+++ /dev/null
@@ -1,158 +0,0 @@
-using Pkg
-using TimerOutputs
-using DataFrames
-using CSV
-path = "/afs/physnet.uni-hamburg.de/users/th1_ro/fweissle/Masterarbeit/LadderDGA.jl"
-println("activating: ", path)
-Pkg.activate(path)
-# Pkg.instantiate()
-using LadderDGA
-
-cfg = ARGS[1]
-output_file = splitext(cfg)[1] * ".csv"
-
-"""
-    max_index(kG::KGrid)
-
-Max integer position along a dimension
-"""
-function max_index(kG::LadderDGA.KGrid)
-    return Int(kG.Ns/2)
-end
-
-"""
-    to_1d_index(n₁::Int, n₂::Int, n₃::Int, kG::KGrid)
-
-Maps integer position to 1d index in reduced grid array
-"""
-function to_1d_index(n₁::Int, n₂::Int, n₃::Int, kG::LadderDGA.KGrid)
-    if (max_index(kG) ≥ n₁) && (n₁ ≥ n₂) && (n₂ ≥ n₃) && (n₃ ≥ 0)
-        return Int(n₁*(n₁ + 1)*(n₁ + 2) / 6 + n₂*(n₂ + 1) / 2 + n₃ + 1)
-    else
-        error("require n₁ ≥ n₂ ≥ n₃")
-    end
-end
-
-function R_index(kG)
-    return to_1d_index(max_index(kG), max_index(kG), max_index(kG), kG)
-end
-
-χ₀, wP, mP, sP, env, kGridStr = readConfig_RPA(cfg);
-
-println("u=$(mP.U)\nμ=$(mP.μ)")
-
-# --------- pull into setup_RPA --------- 
-kG = gen_kGrid(kGridStr, χ₀.Nq)
-
-if length(LadderDGA.gridPoints(kG)) ≠ size(χ₀.data)[χ₀.axis_types[:q]]
-    error("Number of q points in kGrid does not match number of q-points in χ₀!")
-end
-# ---------------------------------------
-
-χm, γm = calc_χγ(:m, χ₀, mP, sP);
-χd, γd = calc_χγ(:d, χ₀, mP, sP);
-helper = setup_RPA(kG, mP, sP, χ₀)
-
-if count(χd[begin, :] ≠ 0) ≠ 1 || count(χm[begin, :] ≠ 0) ≠ 1 || χm[begin, LadderDGA.ω0_index(sP)] ≈ 0 || χd[begin, LadderDGA.ω0_index(sP)] ≈ 0
-   error("Wrong input data. Stop!")
-end
-
-if isfile(output_file)
-    println("Output file exists, aborting.")
-    exit(1)
-end
-println("output file location: ", output_file)
-flush(stdout)
-
-λ₀ = calc_λ0(χ₀, helper)
-
-λm_result  = LadderDGA.λ_correction(:m, χm, γm, χd, γd, λ₀, helper)
-λdm_result = λdm_correction(χm, γm, χd, γd, helper.Σ_loc, helper.gLoc_rfft, helper.χloc_m_sum, λ₀, kG, mP, sP; fit_μ=true , tc=true , verbose=true, rpa=true)
-
-# helper
-r_point = R_index(kG)
-ω_0     = LadderDGA.ω0_index(sP)
-
-# technical stuff
-ngl = χ₀.Ngl
-Nq = kG.Ns
-
-# thermodynamics
-β = mP.β
-T = 1.0/β
-μ = λdm_result.μ
-n = λdm_result.n
-
-# rpa result
-chi0 = χ₀[r_point, ω_0]
-chim = χm[r_point, ω_0]
-chid = χd[r_point, ω_0]
-
-# lambda m correction results
-λm_converged = λm_result.converged
-
-λm_m = λm_result.λm
-
-χm_λm = χ_λ(χm, λm_m)[r_point, ω_0]
-χd_λm = χd[r_point, ω_0]
-
-# lambda dm correction results
-λdm_converged = λdm_result.converged
-
-λm_dm = λdm_result.λm
-λd_dm = λdm_result.λd
-
-if isfinite(λdm_result.λm) && isfinite(λdm_result.λd)
-    χm_dm = χ_λ(χm, λm_dm)[r_point, ω_0]
-    χd_dm = χ_λ(χd, λd_dm)[r_point, ω_0]
-
-    EKin_dm    = λdm_result.EKin
-    EPot_p1_dm = λdm_result.EPot_p1
-    EPot_p2_dm = λdm_result.EPot_p2
-    PP_p1_dm   = λdm_result.PP_p1
-    PP_p2_dm   = λdm_result.PP_p2
-else
-    χm_dm = NaN
-    χd_dm = NaN
-
-    EKin_dm    = NaN
-    EPot_p1_dm = NaN
-    EPot_p2_dm = NaN
-    PP_p1_dm   = NaN
-    PP_p2_dm   = NaN
-end
-
-df = DataFrame(
-    # macro state
-    "T" => T,
-    "μ" => μ,
-    "n" => n,
-    # rpa
-    "u"    => mP.U,
-    "chi0" => chi0,
-    "chim" => chim,
-    "chid" => chid,
-    # λm-correction
-    "m_converged"    => λm_converged,
-    "lambda_m_m"     => λm_m,
-    "chi_m_lambda_m" => χm_λm,
-    "chi_d_lambda_m" => χd_λm,
-    # λdm-correction
-    "dm_converged" => λdm_converged,
-    "lambda_m_dm"  => λm_dm,
-    "lambda_d_dm"  => λd_dm,
-    "chi_m_dm"     => χm_dm,
-    "chi_d_dm"     => χd_dm,
-    # additional info about λdm-correction
-    "EKin_dm"    => EKin_dm,
-    "EPot_p1_dm" => EPot_p1_dm,
-    "EPot_p2_dm" => EPot_p2_dm,
-    "PP_p1_dm"   => PP_p1_dm,
-    "PP_p2_dm"   => PP_p2_dm,
-    # simulation parameters
-    "Ngl"           => ngl,
-    "Nq"            => Nq,
-    "max_omega_int" => sP.n_iω
-)
-
-CSV.write(output_file, df)
\ No newline at end of file
diff --git a/src/DataTypes.jl b/src/DataTypes.jl
index 33b3f70..2eb3bf0 100644
--- a/src/DataTypes.jl
+++ b/src/DataTypes.jl
@@ -157,7 +157,6 @@ Fields
 - **`β`**            : `Float64`, inverse temperature.
 - **`e_kin`**        : `Float64`, kinetic energy.
 - **`Nq`**           : `Int`, Number of points per dimension that are used to sample the reciprocal space
-- **`Ngl`**           : `Int`, Number of gauß-legendre sample points per dimension that where used to calculate each element
 """
 struct χ₀RPA_T <: MatsubaraFunction{_eltype_RPA,2}
     data::Array{_eltype_RPA,2}
@@ -165,11 +164,10 @@ struct χ₀RPA_T <: MatsubaraFunction{_eltype_RPA,2}
     indices_ω::Vector{Int}
     β::Float64
     e_kin::Float64
-    Nq::Int64
-    Ngl::Int64
-    function χ₀RPA_T(data::Array{_eltype_RPA,2}, ωnGrid::UnitRange{Int}, β::Float64, e_kin::Float64, Nq::Int64, Ngl::Int64)
+    Nq::Int
+    function χ₀RPA_T(data::Array{_eltype_RPA,2}, ωnGrid::UnitRange{Int}, β::Float64, e_kin::Float64, Nq::Int)
         indices_ω = [i for i in ωnGrid];
-        new(data, Dict(:q => 1, :ω => 2), indices_ω, β, e_kin, Nq, Ngl)
+        new(data, Dict(:q => 1, :ω => 2), indices_ω, β, e_kin, Nq)
     end
 end
 # ------------------------------------------------- χ ------------------------------------------------
diff --git a/src/IO_RPA.jl b/src/IO_RPA.jl
index 6dbb78a..e2f4e56 100644
--- a/src/IO_RPA.jl
+++ b/src/IO_RPA.jl
@@ -24,9 +24,9 @@ end
 """
     read_χ₀_RPA(file::String)
 
-    Nω :: Int, Number of positive bosonic frequencies to be used. Make sure that the given χ₀-file has at least this many bosonic frequencies!  
+TBW
 """
-function read_χ₀_RPA(file::String, Nω::Int)
+function read_χ₀_RPA(file::String)
     if !HDF5.ishdf5(file)
         throw(ArgumentError("The given file is not a valid hdf5 file!\ngiven path is: '$(file)'"))
     end
@@ -37,23 +37,17 @@ function read_χ₀_RPA(file::String, Nω::Int)
 
     # attributes
     attr_dict = attrs(chi0_group)
-    β      :: Float64 = attr_dict["beta"]           # inverse temperature
-    n_bz_k :: Int64   = attr_dict["n_k"]            # number of gauß-legendre sample points that were used to calculate χ₀
-    n_bz_q :: Int64   = 2 * (attr_dict["n_q"] - 1)  # number of sample points per dimension to sample the first brillouin zone
-    e_kin  :: Float64 = attr_dict["e_kin"]
+    β = attr_dict["beta"]               # inverse temperature
+    n_bz_k = attr_dict["n_k"]            # number of sample points per dimension to sample the first brillouin zone
+    n_bz_q = 2 * (attr_dict["n_q"] - 1)     # number of sample points per dimension to sample the first brillouin zone
+    e_kin = attr_dict["e_kin"]
 
     # datasets
     ω_integers = read(chi0_group["omega_integers"])
-    max_ω_index = indexin(Nω, ω_integers)[1]
-    if size(ω_integers,1) > Nω
-        ω_integers = ω_integers[begin:max_ω_index]
-    elseif size(ω_integers,1) < Nω
-        error("Number of bosonic frequencies in the χ₀ file is smaller than n_pos_bose_freqs from the configuration file!") 
+    if ω_integers ≠ collect(0:maximum(ω_integers))
+        throw(ArgumentError("ω-integers are distict from (0:$(maximum(ω_integers)))!"))
     end
-    if ω_integers ≠ collect(0:Nω)
-        throw(ArgumentError("ω-integers are distict from (0:$(Nω))!"))
-    end
-    χ₀qω = read(chi0_group["values"])[:,begin:max_ω_index]
+    χ₀qω = read(chi0_group["values"])
 
     # consistency checks
     if β ≤ 0.0
@@ -79,7 +73,7 @@ function read_χ₀_RPA(file::String, Nω::Int)
 
     data = expand_ω(χ₀qω)
     ωnGrid = (convert(Int64, -maximum(ω_integers)):convert(Int64, maximum(ω_integers)))
-    return χ₀RPA_T(data, ωnGrid, β, e_kin, n_bz_q, n_bz_k)
+    return χ₀RPA_T(data, ωnGrid, β, e_kin, n_bz_q)
 end
 
 """
@@ -126,31 +120,28 @@ function readConfig_RPA(cfg_in::String)
     tml_debug      = tml["Debug"]
 
     # read section Model
-    U        = tml_model["U"]
+    U = tml_model["U"]
+    @warn "The parameter μ should be read from the χ₀-file and not passed via the configuration file!"
+    μ = tml_model["mu"]
+    @warn "The parameter n should be read from the χ₀-file and not passed via the configuration file!"
+    n_density = tml_model["n_density"]
+    @warn "The parameter EPot_DMFT should be read from the χ₀-file and not passed via the configuration file!"
+    EPot_DMFT = tml_model["EPot_DMFT"] # after inspecting the code: EPot_DMFT is actually never used during the standard-λdm-calculation... 
     kGridStr = tml_model["kGrid"]
-    
-    @warn "The filling is set to ome!"
-    n_density = 1.0 # tml_model["n_density"]
-    @warn "The parameter μ is set to Un/2!"
-    μ = U * n_density / 2
-    @warn "The parameter EPot_DMFT is set to zero!"
-    EPot_DMFT = 0.0 # tml_model["EPot_DMFT"] # after inspecting the code: EPot_DMFT is actually never used during the standard-λdm-calculation... 
+
+    if μ ≠ U * n_density / 2
+        error("So far only half filling is implemented! Please choose μ=U*n/2.")
+    end
 
     # read section Debug
     full_EoM_omega = tml_debug["full_EoM_omega"]
 
     # read section Simulation
-    Nν = tml_simulation["n_pos_fermi_freqs"]       # Number of positive fermionic matsubara frequencies. The matsubara frequency will be sampled symmetrically around zero. So the space of fermionic matsubara frequencies will be sampled by 2Nν elements in total. Will be used for the triangular vertex as well as the self energy
-    Nω = tml_simulation["n_pos_bose_freqs"]        # Number of positive bosonic matsubara frequencies. The matsubara frequency will be sampled symmetrically around zero. So the space of fermionic matsubara frequencies will be sampled by 2Nν elements in total. Will be used for the triangular vertex as well as the self energy
-
-    if Nν ≠ Nω
-        # Julian: strange things might happen if Nν ≠ Nω... So:
-        error("Please use same number of bosonic and fermionic frequencies!")
-    end
-    # chi_asympt_method     = tml_simulation["chi_asympt_method"]     # what is this used for? First guess ν-Asymptotics...
-    # chi_asympt_shell      = tml_simulation["chi_asympt_shell"]      # what is this used for? First guess ν-Asymptotics...
-    # usable_prct_reduction = tml_simulation["usable_prct_reduction"] # what is this used for? First guess ν-Asymptotics...
-    # omega_smoothing       = tml_simulation["omega_smoothing"]       # what is this used for?
+    Nν                    = tml_simulation["n_pos_fermi_freqs"]     # Number of positive fermionic matsubara frequencies. The matsubara frequency will be sampled symmetrically around zero. So the space of fermionic matsubara frequencies will be sampled by 2Nν elements in total. Will be used for the triangular vertex as well as the self energy
+    chi_asympt_method     = tml_simulation["chi_asympt_method"]     # what is this used for? First guess ν-Asymptotics...
+    chi_asympt_shell      = tml_simulation["chi_asympt_shell"]      # what is this used for? First guess ν-Asymptotics...
+    usable_prct_reduction = tml_simulation["usable_prct_reduction"] # what is this used for? First guess ν-Asymptotics...
+    omega_smoothing       = tml_simulation["omega_smoothing"]       # what is this used for?
 
     # read section Environment
     inputDir  = tml_enviroment["inputDir"]
@@ -167,13 +158,13 @@ function readConfig_RPA(cfg_in::String)
         lowercase(logfile))
 
     # read RPA χ₀ from hdf5 file
-    χ₀::χ₀RPA_T = read_χ₀_RPA(env.inputVars, Nω)
+    χ₀::χ₀RPA_T = read_χ₀_RPA(env.inputVars)
 
     # collect ModelParameters
     mP = ModelParameters(U, μ, χ₀.β, n_density, EPot_DMFT, χ₀.e_kin)
 
     # collect SimulationParameters
-    # Nω = trunc(Int, (length(χ₀.indices_ω) - 1) / 2) # number of positive bosonic matsubara frequencies. Is there a particular reason for this choice ?
+    Nω = trunc(Int, (length(χ₀.indices_ω) - 1) / 2) # number of positive bosonic matsubara frequencies. Is there a particular reason for this choice ?
     freq_r = 2 * (Nν + Nω)
     freq_r = -freq_r:freq_r
     sP = SimulationParameters(
diff --git a/src/LambdaCorrection/LambdaCorrection.jl b/src/LambdaCorrection/LambdaCorrection.jl
index 3776cca..c093403 100644
--- a/src/LambdaCorrection/LambdaCorrection.jl
+++ b/src/LambdaCorrection/LambdaCorrection.jl
@@ -11,7 +11,7 @@ using FiniteDifferences
 
 import ..χT, ..γT, ..GνqT, ..KGrid, ..ModelParameters, ..SimulationParameters, ..lDΓAHelper, ..RunHelper
 import ..sum_ω, ..sum_ω!, ..sum_kω, ..sum_ωk, ..subtract_tail, ..update_tail!, ..ω0_index, ..usable_ωindices, ..iν_array
-import ..G_from_Σ, ..G_fft, ..G_rfft!, ..G_from_Σladder!, ..G_from_Σladder, ..calc_E, ..EPot1, ..calc_Σ, ..calc_Σ_ω!, ..calc_Σ!, ..calc_Σ_rpa!, ..eom, ..eom_rpa
+import ..G_from_Σ, ..G_fft, ..G_rfft!, ..G_from_Σladder!, ..G_from_Σladder, ..calc_E, ..EPot1, ..calc_Σ, ..calc_Σ_ω!, ..calc_Σ!, ..eom
 import ..initialize_EoM, ..calc_Σ_par, ..calc_Σ_par!
 import ..filling, ..filling_pos
 import ..update_wcaches_G_rfft!
diff --git a/src/LambdaCorrection/conditions_new.jl b/src/LambdaCorrection/conditions_new.jl
index 1d3ca7c..aae2c76 100644
--- a/src/LambdaCorrection/conditions_new.jl
+++ b/src/LambdaCorrection/conditions_new.jl
@@ -145,14 +145,7 @@ function λm_correction_full(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::Arra
     fit_μ::Bool=true, validate_threshold::Float64=1e-8)
 
     νmax = νmax < 0 ? floor(Int, size(γm, γm.axis_types[:ν]) / 2) : νmax
-    if typeof(h) === RPAHelper
-        λ_rhs =:fixed
-    elseif typeof(h) === lDΓAHelper
-        λ_rhs =:native
-    else
-        error("RunHelper type not implemented!")
-    end
-    rhs = λm_rhs(χm, χd, h; λ_rhs=λ_rhs)
+    rhs = λm_rhs(χm, χd, h; λ_rhs=:native)
     λm, validation = λm_correction(χm, rhs, h, verbose=verbose, validate_threshold=validate_threshold)
     Σ_ladder = calc_Σ(χm, γm, χd, γd, λ₀, h, νmax=νmax, λm=λm)
     μnew, G_ladder = G_from_Σladder(Σ_ladder, h.Σ_loc, h.kG, h.mP, h.sP; fix_n=fit_μ)
@@ -216,6 +209,7 @@ function λdm_correction(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::Array{Co
                    update_χ_tail=update_χ_tail, fit_μ=fit_μ, μ=μ,
                    validate_threshold=validate_threshold, par=par, verbose=verbose, tc=tc)
 end
+
 function λdm_correction(χm::χT, γm::γT, χd::χT, γd::γT, Σ_loc::OffsetVector{ComplexF64},
                         gLoc_rfft::GνqT, χloc_m_sum::Union{Float64,ComplexF64}, λ₀::Array{ComplexF64,3},
                         kG::KGrid, mP::ModelParameters, sP::SimulationParameters; 
@@ -223,7 +217,7 @@ function λdm_correction(χm::χT, γm::γT, χd::χT, γd::γT, Σ_loc::OffsetV
                         sc_max_it::Int = 0, sc_mixing::Float64=0.2, sc_conv::Float64=1e-8,
                         update_χ_tail::Bool=false, fit_μ::Bool=true, μ::Float64=mP.μ, 
                         λinit::Vector{Float64}=[0.0,0.0],
-                        validate_threshold::Float64=1e-8, par::Bool=false, verbose::Bool=false, tc::Bool=true, rpa=false)
+                        validate_threshold::Float64=1e-8, par::Bool=false, verbose::Bool=false, tc::Bool=true)
 
     (χm.λ != 0 || χd.λ != 0) && error("λ parameter already set. Aborting λdm calculation")    
     ωindices, νGrid, iωn_f = gen_νω_indices(χm, χd, mP, sP)
@@ -234,9 +228,6 @@ function λdm_correction(χm::χT, γm::γT, χd::χT, γd::γT, Σ_loc::OffsetV
     end
 
     # --- Preallocations ---
-    if rpa
-        work_kG_exp = similar(kG.cache1)
-    end
     par && initialize_EoM(gLoc_rfft, χloc_m_sum, λ₀, νGrid, kG, mP, sP, χ_m = χm, γ_m = γm, χ_d = χd, γ_d = γd)
     fft_νGrid = sP.fft_range
     Nq::Int   = length(kG.kMult)
@@ -257,11 +248,7 @@ function λdm_correction(χm::χT, γm::γT, χd::χT, γd::γT, Σ_loc::OffsetV
         if par
             calc_Σ_par!(Σ_ladder, λm=λ[1], λd=λ[2], tc=tc)
         else
-            if rpa
-                calc_Σ_rpa!(Σ_ladder, Kνωq_pre, work_kG_exp, χm, χd, χloc_m_sum, λ₀, gLoc_rfft, kG, mP, sP; tc=tc)
-            else
-                calc_Σ!(Σ_ladder, Kνωq_pre, χm, γm, χd, γd, χloc_m_sum, λ₀, gLoc_rfft, kG, mP, sP; tc=tc)
-            end
+            calc_Σ!(Σ_ladder, Kνωq_pre, χm, γm, χd, γd, χloc_m_sum, λ₀, gLoc_rfft, kG, mP, sP; tc=tc)
         end
         #!!!!!!! auf korrektheit pruefen
         μ = G_from_Σladder!(G_ladder, Σ_ladder, Σ_loc, kG, mP; fix_n=fit_μ, μ=μ)
diff --git a/src/LambdaCorrection/helpers.jl b/src/LambdaCorrection/helpers.jl
index 019104f..a105bee 100644
--- a/src/LambdaCorrection/helpers.jl
+++ b/src/LambdaCorrection/helpers.jl
@@ -220,23 +220,15 @@ function get_λ_min(χr::AbstractArray{Float64,2})::Float64
 end
 
 """
-    λm_rhs(χ_m::χT, χ_d::χT, h::RunHelper; λd::Float64=NaN, λ_rhs = :native, verbose=false)
+    λm_rhs(χ_m::χT, χ_d::χT, λd::Float64, h::lDΓAHelper; λ_rhs = :native, verbose=false)
     λm_rhs(imp_density::Float64, χ_m::χT, χ_d::χT, λd::Float64, kG::KGrid, mP::ModelParameters, sP::SimulationParameters, λ_rhs = :native)
 
 Helper function for the right hand side of the Pauli principle conditions (λm correction).
 `imp_density` can be set to `NaN`, if the rhs (``\\frac{n}{2}(1-\\frac{n}{2})``) should not be error-corrected (not ncessary or usefull when asymptotic improvement are active).
 TODO: write down formula, explain imp_density as compensation to DMFT.
 """
-function λm_rhs(χ_m::χT, χ_d::χT, h::RunHelper; λd::Float64=NaN, λ_rhs = :native, verbose=false)
-    imp_density::Float64 = 0.0
-    if typeof(h) === RPAHelper
-        imp_density = NaN64
-    elseif typeof(h) === lDΓAHelper
-        imp_density = h.imp_density
-    else
-        error("RunHelper type not implemented!")
-    end
-    λm_rhs(imp_density, χ_m, χ_d, h.kG, h.mP, h.sP; λd=λd, λ_rhs=λ_rhs, verbose=verbose)
+function λm_rhs(χ_m::χT, χ_d::χT, h::lDΓAHelper; λd::Float64=NaN, λ_rhs = :native, verbose=false)
+    λm_rhs(h.imp_density, χ_m, χ_d, h.kG, h.mP, h.sP; λd=λd, λ_rhs=λ_rhs, verbose=verbose)
 end
 
 function λm_rhs(imp_density::Float64, χ_m::χT, χ_d::χT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; λd::Float64=NaN, λ_rhs = :native, verbose=false)
diff --git a/src/ladderDGATools.jl b/src/ladderDGATools.jl
index aa8e254..db3a45c 100644
--- a/src/ladderDGATools.jl
+++ b/src/ladderDGATools.jl
@@ -1,7 +1,7 @@
 # ==================================================================================================== #
 #                                        ladderDGATools.jl                                             #
 # ---------------------------------------------------------------------------------------------------- #
-#   Author          : Julian Stobbe, Jan Frederik Weißler                                              #
+#   Author          : Julian Stobbe                                                                    #
 # ----------------------------------------- Description ---------------------------------------------- #
 #   ladder DΓA related functions                                                                       #
 # -------------------------------------------- TODO -------------------------------------------------- #
@@ -149,25 +149,7 @@ function conv_tmp_add!(res::AbstractVector{ComplexF64}, kG::KGrid, arr1::Vector{
         res[:] += arr1 .* GView
     else
         expandKArr!(kG, kG.cache1, arr1)
-        mul!(kG.cache1, kG.fftw_plan, kG.cache1) # documentation of mul! warns to not use mul!(A, B, A).
-        for i in eachindex(kG.cache1)
-            kG.cache1[i] *= GView[i]
-        end
-        kG.fftw_plan \ kG.cache1
-        Dispersions.conv_post_add!(kG, res, kG.cache1)
-    end
-    return nothing
-end
-
-"""
-    conv_tmp_add_rpa!(res::AbstractVector{ComplexF64}, kG::KGrid, arr1::Vector{ComplexF64}, GView::AbstractArray{ComplexF64,N})::Nothing where N
-
-Expect both input arrays already in fouriertransformed.
-"""
-function conv_tmp_add_rpa!(res::AbstractVector{ComplexF64}, kG::KGrid, GView::AbstractArray{ComplexF64,N})::Nothing where N
-    if Nk(kG) == 1 
-        error("Nk(kG) == 1. That was unexpected!")
-    else
+        mul!(kG.cache1, kG.fftw_plan, kG.cache1)
         for i in eachindex(kG.cache1)
             kG.cache1[i] *= GView[i]
         end
@@ -275,8 +257,6 @@ function Σ_loc_correction(Σ_ladder::AbstractMatrix{ComplexF64}, Σ_ladderLoc::
 end
 
 # -------------------------------------------- EoM: Defs ---------------------------------------------
-@inline eom_rpa(U::Float64, χ_m::Float64, χ_d::Float64, λ₀::ComplexF64)::ComplexF64 = 0.5 * (U^2.0) * ( χ_d + 3.0 * χ_m) + U * λ₀
-
 @inline eom(U::Float64, γ_m::ComplexF64, γ_d::ComplexF64, χ_m::Float64, χ_d::Float64, λ₀::ComplexF64)::ComplexF64 = U*(γ_m * 1.5 * (1 + U * χ_m) - γ_d * 0.5 * (1 - U * χ_d) - 1.5 + 0.5 + λ₀)
 @inline eom_χ_m(U::Float64, γ_m::ComplexF64, γ_d::ComplexF64, χ_m::Float64, χ_d::Float64, λ₀::ComplexF64)::ComplexF64 = U*(γ_m * 1.5 * (U * χ_m) )
 @inline eom_χ_d(U::Float64, γ_m::ComplexF64, γ_d::ComplexF64, χ_m::Float64, χ_d::Float64, λ₀::ComplexF64)::ComplexF64 = -U*(γ_d * 0.5 * ( - U * χ_d))
diff --git a/src/ladderDGATools_singleCore.jl b/src/ladderDGATools_singleCore.jl
index 876be33..a8effff 100644
--- a/src/ladderDGATools_singleCore.jl
+++ b/src/ladderDGATools_singleCore.jl
@@ -160,35 +160,6 @@ function calc_Σ_ω!(eomf::Function, Σ_ladder::OffsetMatrix{ComplexF64}, Kνωq
     end
 end
 
-function calc_Σ_ω_rpa!(eomf::Function, Σ_ladder::OffsetMatrix{ComplexF64}, Kνωq_pre::Vector{ComplexF64}, work_kG_exp::Array{ComplexF64,N},
-                       χm::χT, χd::χT,
-                       Gνω::GνqT, λ₀::AbstractArray{ComplexF64,3}, U::Float64, kG::KGrid,
-                       sP::SimulationParameters) where N
-
-    νdim = ndims(Gνω) > 2 ? length(gridshape(kG))+1 : 2 # TODO: this is a fallback for gIm. RPA: ndims(Gνω) > 2 is expected, todo: remove inline if.
-    fill!(Σ_ladder, zero(ComplexF64))
-    ω_axis = χm.indices_ω
-    for (ωi,ωn) in enumerate(ω_axis)
-        νZero = ν0Index_of_ωIndex(ωi, sP)
-        νlist = νZero:(sP.n_iν*2)
-        length(νlist) > size(Σ_ladder,2) && (νlist = νlist[1:size(Σ_ladder,2)])
-        
-        # evaluate EoM for each element of the brillouin zone
-        for qi in 1:size(Σ_ladder,1)
-            Kνωq_pre[qi] = eomf(U, χm[qi,ωi], χd[qi,ωi], λ₀[qi,begin,ωi]) # note: independent of ν
-        end
-        expandKArr!(kG, work_kG_exp, Kνωq_pre)
-        kG.fftw_plan * work_kG_exp # apply fourier transform to real/position space. technical: kG.fftw_plan is inplace plan!
-
-        # evaluate cross correlation / perform q-integration for each fermionic matsubara frequency
-        for (νii,νi) in enumerate(νlist)
-            #TODO: find a way to not unroll this!
-            copy!(kG.cache1, work_kG_exp)
-            conv_tmp_add_rpa!(view(Σ_ladder,:,νii-1), kG, selectdim(Gνω,νdim,(νii-1) + ωn))
-        end
-    end
-end
-
 function calc_Σ!(Σ_ladder::OffsetMatrix{ComplexF64}, Kνωq_pre::Vector{ComplexF64},
                 χm::χT, γm::γT, χd::χT, γd::γT, 
                 χ_m_sum::Union{Float64,ComplexF64}, λ₀::AbstractArray{_eltype,3},
@@ -200,16 +171,6 @@ function calc_Σ!(Σ_ladder::OffsetMatrix{ComplexF64}, Kνωq_pre::Vector{Comple
     return nothing
 end
 
-function calc_Σ_rpa!(Σ_ladder::OffsetMatrix{ComplexF64}, Kνωq_pre::Vector{ComplexF64}, work_kG_exp::Array{ComplexF64,N},
-                    χm::χT, χd::χT, χ_0_sum::Union{Float64,ComplexF64}, λ₀::AbstractArray{_eltype,3},
-                    Gνω::GνqT, kG::KGrid,
-                    mP::ModelParameters, sP::SimulationParameters; tc::Bool=true) ::Nothing where N
-    calc_Σ_ω_rpa!(eom_rpa, Σ_ladder, Kνωq_pre, work_kG_exp, χm, χd, Gνω, λ₀, mP.U, kG, sP)
-    tail_correction = (tc ? correction_term(mP, kG, χm, χ_0_sum, collect(axes(Σ_ladder)[2])) : zero(iν_array(mP.β, collect(axes(Σ_ladder)[2]))))
-    Σ_ladder.parent[:,:] = Σ_ladder.parent[:,:] ./ mP.β .+ reshape(tail_correction, 1, length(tail_correction)) .+ Σ_hartree(mP)
-    return nothing
-end
-
 function calc_Σ!(Σ_ladder::OffsetMatrix{ComplexF64}, Σ_ladder_ω::OffsetArray{ComplexF64,3}, Kνωq_pre::Vector{ComplexF64},
                 χm::χT, γm::γT, χd::χT, γd::γT, 
                 χ_m_sum::Union{Float64,ComplexF64}, λ₀::AbstractArray{_eltype,3},
diff --git a/test/test_data/config_rpa_example.toml b/test/test_data/config_rpa_example.toml
index c87af5c..f798998 100644
--- a/test/test_data/config_rpa_example.toml
+++ b/test/test_data/config_rpa_example.toml
@@ -1,24 +1,23 @@
 [Model]
 U         = 0.5 # Hubbard on-site interaction parameter
-# n_density = 1.0 # number density/ filling
-# mu        = 0.25 # chemical potential: so far half filling only
-# EPot_DMFT = 0.0 # EPot_DMFT - is never used inside the code...
+n_density = 1.0 # number density/ filling
+mu        = 0.25 # chemical potential: so far half filling only
+EPot_DMFT = 0.0 # EPot_DMFT - what is this used for? How can I substitute this in RPA?
 kGrid     = "3Dsc-0.2041241452319315081831070062254909493304956233880558440360577139"
 
 [Simulation]
-n_pos_fermi_freqs = 25         #  Number of positive fermionic matsubara frequencies. The matsubara frequency will be sampled symmetrically around zero. So the space of fermionic matsubara frequencies will be sampled by 2Nν elements in total. Will be used for the triangular vertex as well as the self energy
-n_pos_bose_freqs  = 25         #  Number of positive bosonic   matsubara frequencies. The matsubara frequency will be sampled symmetrically around zero. So the space of fermionic matsubara frequencies will be sampled by 2Nν elements in total. Will be used for the triangular vertex as well as the self energy
+n_pos_fermi_freqs = 100         #  Number of positive fermionic matsubara frequencies. The matsubara frequency will be sampled symmetrically around zero. So the space of fermionic matsubara frequencies will be sampled by 2Nν elements in total. Will be used for the triangular vertex as well as the self energy
 
 # WARNING: DO NOT TOUCH ANY SIMULATION PARAMETERS BELOW UNLESS YOU KNOW WHAT YOU ARE DOING!!!!
-# chi_asympt_method     = "nothing"   # direct/sc/nothing, see BSE_SC module for more
-# chi_asympt_shell      = 0          # Integer >0 improves nu,nu' asymptotics of the generalized susceptibilityself consistently. Physical susceptibilities must be given in the input file. 0 deactivates this.
-# usable_prct_reduction = 0.0             # safety cutoff for usable ranges, 0.0 means all values where chi is positive and strictly decreasing
-# omega_smoothing       = "nothing"             # nothing, range, full. Smoothes data after nu, nu' sums. Set range to only use smoothing in order to find the usable range (default)
+chi_asympt_method     = "nothing"   # direct/sc/nothing, see BSE_SC module for more
+chi_asympt_shell      = 0          # Integer >0 improves nu,nu' asymptotics of the generalized susceptibilityself consistently. Physical susceptibilities must be given in the input file. 0 deactivates this.
+usable_prct_reduction = 0.0             # safety cutoff for usable ranges, 0.0 means all values where chi is positive and strictly decreasing
+omega_smoothing       = "nothing"             # nothing, range, full. Smoothes data after nu, nu' sums. Set range to only use smoothing in order to find the usable range (default)
 
 
 [Environment]
 inputDir  = "/home/coding/LadderDGA.jl/test/test_data/"                  # path to input dir. Make this a relative path...
-inputVars = "chi0_nq_16_nk_40_nomega_100.h5"
+inputVars = "rpa_test_chi0_5.h5"
 logfile   = "stderr"                      # STDOUT, STDERR, filename
 
 # WARNING: DO NOT TOUCH ANY ENVIRONMENT PARAMETERS BELOW UNLESS YOU KNOW WHAT YOU ARE DOING!!!!
