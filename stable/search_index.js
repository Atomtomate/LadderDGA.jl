var documenterSearchIndex = {"docs":
[{"location":"deps/","page":"Dependencies","title":"Dependencies","text":"There are two functionalities which have been factored out to separate projects: Handeling of frequency sums and operations involving k-grids.","category":"page"},{"location":"deps/#Frequency-Summations","page":"Dependencies","title":"Frequency Summations","text":"","category":"section"},{"location":"deps/","page":"Dependencies","title":"Dependencies","text":"The summation over Matsubara frequencies is defined over a set on infinitely many frequencies. A canonical approach to approximate this sum,","category":"page"},{"location":"deps/#K-Grids","page":"Dependencies","title":"K-Grids","text":"","category":"section"},{"location":"#LadderDGA.jl-Documentation","page":"Home","title":"LadderDGA.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LadderDGA","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#List-of-Functions","page":"Home","title":"List of Functions","text":"","category":"section"},{"location":"#LadderDGA","page":"Home","title":"LadderDGA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [LadderDGA]\nOrder   = [:module, :constant, :type, :function, :marco]","category":"page"},{"location":"#LadderDGA.EnvironmentVars","page":"Home","title":"LadderDGA.EnvironmentVars","text":"EnvironmentVars <: ConfigStruct\n\nContains various settings, controlling the I/O behaviour of this module. This is typically generated from a config.toml file using the readConfig function.\n\nFields\n\ninputDir        : String, Directory of input files\ninputVars       : String, File name of .jld2 file containing input.\nloglevel        : String, Options: disabled, error, warn, info, debug\nlogfile         : String,    Options: STDOUT, STDERR, filename\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.ModelParameters","page":"Home","title":"LadderDGA.ModelParameters","text":"ModelParameters <: ConfigStruct\n\nContains model parameters for the Hubbard model. This is typically generated from a config.toml file using  the readConfig function.\n\nFields\n\nU         : Float64, Hubbard U\nμ         : Float64, chemical potential\nβ         : Float64, inverse temperature\nn         : Float64, filling\nsVk       : Float64, ∑_k Vₖ^2\nEpot_DMFT : Float64, DMFT potential energy\nEkin_DMFT : Float64, DMFT kinetic intergy\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.RPAHelper","page":"Home","title":"LadderDGA.RPAHelper","text":"RPAHelper <: RunHelper\n\nStruct with data needed to run ladder DΓA calculations.\n\nConstructor\n\nsetup_RPA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [; local_correction=true, silent=false])\n\nSee setup_RPA\n\nFields\n\nTODO: documentation for fields\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.SimulationParameters","page":"Home","title":"LadderDGA.SimulationParameters","text":"SimulationParameters <: ConfigStruct\n\nContains simulation parameters for the ladder DGA computations. This is typically generated from a config.toml file using the readConfig function.\n\nFields\n\nn_iω                    : Int, Number of positive bosonic frequencies (full number will be 2*n_iω+1 \nn_iν                    : Int, Number of positive fermionic frequencies (full number will be 2*n_iν \nn_iν_shell              : Int, Number of fermionic frequencies used for asymptotic sum improvement (χ_asym_r arrays with at least these many entries need to be provided)\nshift                   : Bool, Flag specifying if -n_iν:n_iν-1 is shifted by -ωₙ/2 at each ωₙ slice (centering the main features)\nχ_helper                : struct, helper struct for asymptotic sum improvements involving the generalized susceptibility (nothing if n_iν_shell == 0), see also BSE_SC.jl.\nfft_range               : Int, Frequencies used for computations of type f(νₙ + ωₙ). \nusable_prct_reduction   : Float64, percent reduction of usable bosonic frequencies\ndbg_full_eom_omega      : Bool, if true overrides usable ω ranges to n_iω.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.lDΓAHelper","page":"Home","title":"LadderDGA.lDΓAHelper","text":"lDΓAHelper <: RunHelper\n\nStruct with data needed to run ladder DΓA calculations.\n\nConstructor\n\nsetup_LDGA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars; local_correction=true)\n\nSee setup_LDGA\n\nFields\n\nTODO: documentation for fields\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.γT","page":"Home","title":"LadderDGA.γT","text":"γT <: MatsubaraFunction\n\nStruct for the non-local triangular vertex. \n\nFields\n\ndata         : Array{ComplexF64,3}, data\naxis_types   : Dict{Symbol,Int}, Dictionary mapping :q, :ν, :ω to the axis indices.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.χT","page":"Home","title":"LadderDGA.χT","text":"χT <: MatsubaraFunction\n\nStruct for the non-local susceptibilities. \n\nConstructor\n\nχT(data::Array{T, 2}; full_range=true, reduce_range_prct=0.1): if full_range is set to false, the usable range  is determined via find_usable_χ_interval.\n\nFields\n\ndata         : Array{ComplexF64,3}, data\naxis_types   : Dict{Symbol,Int}, Dictionary mapping :q, :ω to the axis indices.\nindices_ω    : Vector{Int}, \ntail_c       : Vector{Float64}, tail coefficients of 1omega^i tails. Index 1 corresponds to i=0.\nλ            : Float64, λ correction parameter.\nβ            : Float64, inverse temperature.\nusable_ω     : AbstractArray{Int}, usable indices for which data is assumed to be correct. See also find_usable_χ_interval\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.χ₀RPA_T","page":"Home","title":"LadderDGA.χ₀RPA_T","text":"χ₀RPA_T <: MatsubaraFunction\n\nStruct for the RPA bubble term.\n\nConstructor\n\nχ₀RPAT(data::Array{eltype,2}, ωnGrid::AbstractVector{Int}, νnGrid::UnitRange{Int64}, β::Float64)\n\nThis constructor does not perform any checks for the entered data array in the currently implemented version. Make sure that the axes match the axis_types field!\n\nFields\n\ndata         : Array{ComplexF64,3}, data.\naxis_types   : Dict{Symbol,Int}, Dictionary mapping :q, :ω to the axis indices.\nindices_ω    : Vector{Int}, m indices m of bosonic omega_m Matsubara frequencies.\nβ            : Float64, inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.χ₀T","page":"Home","title":"LadderDGA.χ₀T","text":"χ₀T <: MatsubaraFunction\n\nStruct for the bubble term. The q, ω dependent asymptotic behavior is computed from the  t1 and t2 input.  See χ₀Asym_coeffs implementation for details.\n\nConstructor\n\nχ₀T(data::Array{_eltype,3}, kG::KGrid, ωnGrid::AbstractVector{Int}, n_iν::Int, shift::Bool, mP::ModelParameters; local_tail=false)\n\nSet local_tail=true in case of the local bubble constructed fro mthe impurity Green's function. This is necessary in order to construct the correct asymptotics.\n\nFields\n\ndata         : Array{ComplexF64,3}, data\nasym         : Array{ComplexF64,2}, [q, ω] dependent asymptotic behavior.\naxis_types   : Dict{Symbol,Int}, Dictionary mapping :q, :ν, :ω to the axis indices.\nindices_νω   : Matrix{Tuple{Int,Int}}, (n,m) indices of fermionic nu_n and bosonic omega_m Matsubara frequencies.\nβ            : Float64, inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"#Base.show-Tuple{IO, ModelParameters}","page":"Home","title":"Base.show","text":"Base.show(io::IO, m::ModelParameters)\n\nCustom output for ModelParameters\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, SimulationParameters}","page":"Home","title":"Base.show","text":"Base.show(io::IO, m::SimulationParameters)\n\nCustom output for SimulationParameters\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.EPot1-Tuple{Dispersions.KGrid, AbstractMatrix{ComplexF64}, Matrix{ComplexF64}, Matrix{ComplexF64}, Vector{Float64}, Float64}","page":"Home","title":"LadderDGA.EPot1","text":"Specialized function for DGA potential energy. Better performance than calc_E.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.F_from_χ-Tuple{Symbol, lDΓAHelper}","page":"Home","title":"LadderDGA.F_from_χ","text":"F_from_χ(type::Symbol, h::lDΓAHelper; diag_term=true)\nF_from_χ(χ::AbstractArray{ComplexF64,3}, G::AbstractArray{ComplexF64,1}, sP::SimulationParameters, β::Float64; diag_term=true)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.F_from_χ_gen-Tuple{χ₀T, Array{ComplexF64, 4}}","page":"Home","title":"LadderDGA.F_from_χ_gen","text":"F_from_χ_gen(χ₀::χ₀T, χr::Array{ComplexF64,4})::Array{ComplexF64,4}\n\nCalculates the full vertex from the generalized susceptibility chi^nunuomega_r and the bubble term chi_0 via F^nunuomega_rmathbfq       =      beta^2 left( chi^nunuomega_0mathbfq right)^-1       - left( chi^nuomega_0mathbfq right)^-1  chi^nunuomega_rmathbfq left( chi^nuomega_0mathbfq right)^-1\n\nFor a version using the physical susceptibilities see F_from_χ_gen.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.F_from_χ_star_gen-Tuple{χ₀T, Array{ComplexF64, 4}, χT, γT, Float64}","page":"Home","title":"LadderDGA.F_from_χ_star_gen","text":"F_from_χ_star_gen(χ₀::χ₀T, χstar_r::Array{ComplexF64,4}, χr::χT, γr::γT, Ur::Float64)\n\nCalculates the full vertex from the generalized susceptibility chi^nunuomega_r, the physical susceptibility chi^omega_r and the triangular vertex gamma^nuomega_r. This is usefull to calculate a lambda-corrected full vertex. \n\nF^nunuomega_rmathbfq       =      beta^2 left( chi^nunuomega_0mathbfq right)^-1       - beta^2 (chi^nuomega_0mathbfq)^-1 chi^*nunuomega_rmathbfq (chi^nuomega_0mathbfq)^-1      + U_r (1 - U_r chi^omega_rmathbfq) gamma^nuomega_rmathbfq gamma^nuomega_rmathbfq For a version using the physical susceptibilities see F_from_χ_gen.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_fft-Tuple{OffsetArrays.OffsetArray, Dispersions.KGrid, SimulationParameters}","page":"Home","title":"LadderDGA.G_fft","text":"G_fft(G::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCalculates fast Fourier transformed lattice Green's functions used for calc_bubble.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_from_Σ-Tuple{Int64, Float64, Float64, Float64, ComplexF64}","page":"Home","title":"LadderDGA.G_from_Σ","text":"G_from_Σ(ind::Int64, β::Float64, μ::Float64, ϵₖ::Float64, Σ::ComplexF64)\nG_from_Σ(mf::ComplexF64, μ::Float64, ϵₖ::Float64, Σ::ComplexF64)\n\nComputes Green's function according to frac(2 n + 1)pi ibeta + mu - epsilon_k - Sigma(kinu_n)^-1, where epsilon_k and Sigma(kinu_n) are given as single values. Convenience wrappers for full grids are provided below.\n\nArguments:\n\nind : Matsubara frequency index\nmf  : Matsubara frequency\nβ   : Inverse temperature (only needs to be set, if index instead of frequency is given)\nμ   : Chemical potential\nϵₖ  : Dispersion relation at fixed k, see below for convenience wrappers.\nΣ   : Self energy at fixed frequency (and potentially fixed k), see below for convenience wrappers.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_from_Σ-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Vector{Float64}, UnitRange{Int64}, ModelParameters}","page":"Home","title":"LadderDGA.G_from_Σ","text":"G_from_Σ(Σ::AbstractVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::AbstractVector{Int}, mP::ModelParameters; μ = mP.μ,  Σloc::AbstractArray = nothing) \nG_from_Σ!(res::Matrix{ComplexF64}, Σ::AbstractVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::AbstractVector{Int}, mP::ModelParameters; μ = mP.μ,  Σloc::AbstractVector = nothing)\n\nComputes Green's function from self energy Σ and dispersion ϵkGrid over given frequency indices range. Optionally, a different chemical potential μ can be provided. When the non-local self energy is used, one typically wants to extend the usefull range of frequencies by attaching the tail of the local self energy in the high frequency regime. This is done by providing a range larger than the array size of Σ and in addition setting Σloc (the size of Σloc must be as large or larger than range).  The inplace version stores the result in res.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_from_Σladder-Tuple{AbstractMatrix{ComplexF64}, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.G_from_Σladder","text":"G_from_Σladder(Σ_ladder::AbstractMatrix{ComplexF64}, Σloc::Vector{ComplexF64}, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; fix_n::Bool=false, μ=mP.μ, improved_sum_filling::Bool=true)\nG_from_Σladder!(G_new::OffsetMatrix{ComplexF64}, Σ_ladder::OffsetMatrix{ComplexF64}, Σloc::AbstractVector{ComplexF64}, kG::KGrid, mP::ModelParameters; fix_n::Bool=false, μ=mP.μ, improved_sum_filling::Bool=true)\n\nComputes Green's function from lDΓA self-energy.\n\nThe resulting frequency range is given by sP.fft_range, if less frequencies are available from Σ_ladder, Σloc is used instead.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_shell_sum-Tuple{Int64, Float64}","page":"Home","title":"LadderDGA.G_shell_sum","text":"G_shell_sum(N::Int, β::Float64)::Float64\n\nCalculate frac1beta sum_n in Omega_mathrmshell frac1(i nu_n)^2 N should be the index of the largest frequency + 1, NOT the total lenth of the array, i.e. 50 for indices = 0:49.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, SimulationParameters}","page":"Home","title":"LadderDGA.OneToIndex_to_Freq","text":"OneToIndex_to_Freq(ωi::Int, νi::Int, sP::SimulationParameters)\n\nConverts (1:N,1:N) index tuple for bosonic (ωi) and fermionic (νi) frequency to Matsubara frequency number. If the array has a ν shell (for example for tail improvements) this will also be taken into account by providing Nν_shell.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA._update_tail!-Tuple{Vector{Float64}}","page":"Home","title":"LadderDGA._update_tail!","text":"_update_tail!(coeffs::Vector{Float64})\n\nUpdates the Ekin/ω^2 tail of physical susceptibilities on worker. Used by update_tail!.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.bse_inv-Tuple{Symbol, Array{ComplexF64, 3}}","page":"Home","title":"LadderDGA.bse_inv","text":"bse_inv(type::Symbol, Γr::Array{ComplexF64,3})\n\nKernel for calculation of susceptibility and triangular vertex. Used by calc_χγ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_E-Tuple{χT, γT, χT, γT, Any, Any, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_E","text":"calc_E(χ_sp::χT, γ_sp::γT, χ_ch::χT, γ_ch::γT, λ₀, gLoc_rfft, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; νmax=sP.n_iν)\ncalc_E([G::Array{ComplexF64,2},] Σ::AbstractArray{ComplexF64,2}, kG::KGrid, mP::ModelParameters; νmax::Int = floor(Int,3*size(Σ,2)/8),  trace::Bool=false)\n\nReturns kinetic and potential energies from given self-energy Σ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_E_ED-Tuple{String}","page":"Home","title":"LadderDGA.calc_E_ED","text":"calc_E_ED(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, GImp::Vector{ComplexF64}, U, n, μ, β)\ncalc_E_ED(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, GImp::Vector{ComplexF64}, mP::ModelParameters)\ncalc_E_ED(fname::String)\n\nComputes kinetic and potential energies from Anderson parameters.\n\nReturns:\n\n(EKin, EPot): Tuple{Float64,Float64}, kinetic and potential energy.\n\nArguments:\n\nfname : jld2-file containing the fields: [gImp, β, ϵₖ, Vₖ, U, nden, μ] (see below)\nϵₖ    : bath levels\nVₖ    : hoppend amplitudes\nGImp  : impurity Green's function. WARNING: the arguments are assumed to by fermionic Matsuabra indices 0:length(GImp)-1!\nU     : Coulomb interaction strength\nn     : number density\nμ     : chemical potential\nβ     : inverse temperature\nmP    : Alternative call with model parameters as Float64. See also ModelParameters.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_bubble-Tuple{Float64, Dispersions.KGrid, SimulationParameters}","page":"Home","title":"LadderDGA.calc_bubble","text":"calc_bubble(h::RPAHelper)\ncalc_bubble(β::Float64, kG::KGrid, sP::SimulationParameters)\n\nCalc RPA-bubble term.\n\nTODO: So far 3d hardcoded. Generalize to d dimensions...\n\nχ0(q,ω)=-Σ{k} Σ_ν G(ν, k) * G(ν+ω, k+q)\n\nwhere     ν  : Fermionic Matsubara frequencies     ω  : Bosonic Matsubara frequencies     k,q: Element of the first Brilluoin zone\n\nThis is a real-valued quantity.\n\nParameters\n\nβ     :: Float64  Inverse temperature in natural units\nkG    :: KGrid    The k-grid on which to perform the calculation\nsP    :: SimulationParameters (to construct a frequency range)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_bubble-Tuple{lDΓAHelper}","page":"Home","title":"LadderDGA.calc_bubble","text":"calc_bubble(Gνω::GνqT, Gνω_r::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; local_tail=false)\ncalc_bubble(h::lDΓAHelper, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; local_tail=false)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_bubble_par-Tuple{lDΓAHelper}","page":"Home","title":"LadderDGA.calc_bubble_par","text":"calc_bubble_par(h::lDΓAHelper; collect_data=true)\ncalc_bubble_par(kG::KGrid, mP::ModelParameters, sP::SimulationParameters; collect_data=true)\n\nCalculates the bubble, based on two fourier-transformed Greens functions where the second one has to be reversed.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_gen_χ-Tuple{Array{ComplexF64, 3}, χ₀T, Dispersions.KGrid}","page":"Home","title":"LadderDGA.calc_gen_χ","text":"calc_gen_χ(Γr::ΓT, χ₀::χ₀T, kG::KGrid)\n\nCalculates generalized susceptibility from Γr by solving the Bethe Salpeter Equation.  See calc_χγ for direct (and more efficient) calculation of physical susceptibility and triangular vertex.\n\nReturns: chi^nunuomega_q as 4-dim array with axis: νi, νpi, qi, ωi.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ-Tuple{χT, γT, χT, γT, AbstractArray{ComplexF64, 3}, lDΓAHelper}","page":"Home","title":"LadderDGA.calc_Σ","text":"calc_Σ(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::AbstractArray{_eltype,3}, h::lDΓAHelper;\n            νmax::Int = h.sP.n_iν, λm::Float64=0.0, λd::Float64=0.0, tc::Bool=true)\ncalc_Σ(χm::χT, γm::γT, χd::χT, γd::γT, χ_m_sum::Union{Float64,ComplexF64}, λ₀::AbstractArray{_eltype,3},\n            Gνω::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; \n            νmax::Int = sP.n_iν, λm::Float64=0.0, λd::Float64=0.0, tc::Bool=true)\n\nCalculates the self-energy from ladder quantities.\n\nThis is the single core variant, see calc_Σ_par for the parallel version.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ_eom_par-Tuple{Float64, Float64}","page":"Home","title":"LadderDGA.calc_Σ_eom_par","text":"calc_Σ_eom_par(νmax::Int)\n\nEquation of motion for self energy. See calc_Σ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ_par-Tuple{}","page":"Home","title":"LadderDGA.calc_Σ_par","text":"calc_Σ_par(; λm::Float64=0.0, λd::Float64=0.0, collect_data=true, tc::Bool=true)\n\nCalculates self-energy on worker pool. Workers must first be initialized using initialize_EoM. #TODO: νrange must be equal to the one used during initialization. remove one.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ_parts-Tuple{χT, γT, χT, γT, AbstractArray{ComplexF64, 3}, lDΓAHelper}","page":"Home","title":"LadderDGA.calc_Σ_parts","text":"calc_Σ_parts(χm::χT,γm::γT,χd::χT,γd::γT,h::lDΓAHelper,λ₀::AbstractArray{ComplexF64,3};λm::Float64=0.0, λd::Float64=0.0)\ncalc_Σ_parts(χm::χT,γm::γT, χd::χT, γd::γT, χ_m_sum::Union{Float64,ComplexF64}, λ₀::AbstractArray{_eltype,3},\n             Gνω::GνqT, kG::KGrid,mP::ModelParameters, sP::SimulationParameters;\n             λm::Float64=0.0, λd::Float64=0.0)\n\nCalculates the lDGammaA self-energy (see also calc_Σ), but split into 7 contributions from: χm, γm, χd, γd, U, Fm + Σ_hartree, tail_correction.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_λ0-Tuple{χ₀T, lDΓAHelper}","page":"Home","title":"LadderDGA.calc_λ0","text":"calc_λ0(χ₀::χ₀T, h::lDΓAHelper)\ncalc_λ0(χ₀::χ₀T, Fr::FT, h::lDΓAHelper)\ncalc_λ0(χ₀::χ₀T, Fr::FT, χ::χT, γ::γT, mP::ModelParameters, sP::SimulationParameters)\n\nCorrection term, TODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_χγ-Tuple{Symbol, lDΓAHelper, χ₀T}","page":"Home","title":"LadderDGA.calc_χγ","text":"calc_χγ(type::Symbol, h::lDΓAHelper, χ₀::χ₀T)\ncalc_χγ(type::Symbol, Γr::ΓT, χ₀::χ₀T, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCalculates susceptibility and triangular vertex in type channel. See calc_χγ_par for parallel calculation.\n\nThis method solves the following equation: `` \\chir = \\chi0 - \\frac{1}{\\beta^2} \\chi0 \\Gammar \\chir \\\n\\Leftrightarrow (1 + \\frac{1}{\\beta^2} \\chi0 \\Gammar) = \\chi0 \\\n\\Leftrightarrow (\\chi^{-1}r - \\chi^{-1}0) = \\frac{1}{\\beta^2} \\Gamma_r ``\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}","page":"Home","title":"LadderDGA.calc_χγ_par","text":"calc_χγ_par(type::Symbol, h::lDΓAHelper)\ncalc_χγ_par(type::Symbol, Γr::ΓT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; collect_data=true)\n\nCalculate susceptibility and triangular vertex parallel on workerpool. \n\nSet collect_data to return both quantities, or call collect_χ and collect_γ at a later point. calc_χγ can be used for single core computations.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.clear_wcache!-Tuple{}","page":"Home","title":"LadderDGA.clear_wcache!","text":"clear_wcache!()\n\nClears cache on all workers. Must be used when recalculating susceptibilities after EoM initialization.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_Σ!-Tuple{OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}}","page":"Home","title":"LadderDGA.collect_Σ!","text":"collect_Σ!(Σ_ladder::OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, mP::ModelParameters; λm=0.0)\n\nCollects self-energy from workers.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_γ-Tuple{Symbol, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.collect_γ","text":"collect_γ(type::Symbol, [kG::KGrid, mP::ModelParameters, sP::SimulationParameters] OR [h::lDΓAHelper])\n\nCollects triangular vertex from workers, after parallel computation (see calc_χγ_par).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_χ-Tuple{Symbol, lDΓAHelper}","page":"Home","title":"LadderDGA.collect_χ","text":"collect_χ(type::Symbol, [kG::KGrid, mP::ModelParameters, sP::SimulationParameters] OR [h::lDΓAHelper])\n\nCollects susceptibility from workers, after parallel computation (see calc_χγ_par).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_χ₀-Tuple{lDΓAHelper}","page":"Home","title":"LadderDGA.collect_χ₀","text":"collect_χ₀(kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCollect non-local bubble chi_0^omega(q) from workers. Values first need to be calculated using calc_bubble_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.core-Tuple{χ₀T}","page":"Home","title":"LadderDGA.core","text":"core(χ₀::χ₀T)\n\nSelect core region (without asymptotic shell) from bubble term.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.estimate_connected_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, ModelParameters}","page":"Home","title":"LadderDGA.estimate_connected_ef","text":"estimate_connected_ef(Σ_ladder::OffsetMatrix, kG::KGrid, mP::ModelParameters; ν0_estimator::Function=lin_fit)\n\nEstimates connected fermi surface. See also estimate_ef and fermi_surface_connected. Returns fermi surface indices and relax_zero_condition (values substantially larger than 1 indicate appearance of fermi arcs).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.estimate_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, ModelParameters}","page":"Home","title":"LadderDGA.estimate_ef","text":"estimate_ef(Σ_ladder::OffsetMatrix, kG::KGrid, mP::ModelParameters; ν0_estimator::Function=lin_fit, relax_zero_condition::Float64=10.0)\n\nEstimate fermi surface of Σ_ladder, using extrapolation to nu = 0 with the function ν0_estimator and the condition lim_nu to 0 Sigma (nu k_f) = mu - epsilon_k_f.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.fermi_surface_connected-Tuple{BitVector, Dispersions.KGrid}","page":"Home","title":"LadderDGA.fermi_surface_connected","text":"fermi_surface_connected(ef_ind::BitVector, kG::KGrid, D::Int)\n\nChecks for connected fermi surface of kG dimensions, given a BitVector of points on the fermi surface. Returns < 0 if fermi surface is not connected, == 0 if it is exactly a line, > 0 if the line is multiple points thick.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filling-Tuple{AbstractVector{ComplexF64}, Float64}","page":"Home","title":"LadderDGA.filling","text":"filling(G::Vector{ComplexF64}, [kG::KGrid, ] β::Float64)\nfilling(G::Vector, U::Float64, μ::Float64, β::Float64, [shell::Float64])\n\nComputes filling of (non-) local Green's function.\n\nIf U, μ and β are provided, asymptotic corrections are used. The shell sum can be precomputed using G_shell_sum If G is defined only over positive Matsubara frequencies filling_pos can be used.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filling_pos-Tuple{AbstractVector{ComplexF64}, Vararg{Float64, 4}}","page":"Home","title":"LadderDGA.filling_pos","text":"filling_pos(G::Vector, U::Float64, μ::Float64, β::Float64[, shell::Float64, improved_sum::Bool=true])::Float64\n\nReturns filling from G only defined over positive Matsubara frequencies.  See filling for further documentation.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filter_KZ-Union{Tuple{T}, Tuple{Int64, Int64, AbstractVector{T}}} where T<:Number","page":"Home","title":"LadderDGA.filter_KZ","text":"filter_KZ(m::Int, k::Int, X::AbstractArray{T,1}) where T <: Number\n\nIterated moving average noise filter for inut data. See also filter_MA.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filter_MA-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}}} where T<:Number","page":"Home","title":"LadderDGA.filter_MA","text":"filter_MA(m::Int, X::AbstractArray{T,1}) where T <: Number\nfilter_MA!(res::AbstractArray{T,1}, m::Int, X::AbstractArray{T,1}) where T <: Number\n\nIterated moving average noise filter for inut data. See also filter_KZ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}","page":"Home","title":"LadderDGA.find_usable_χ_interval","text":"find_usable_χ_interval(χ_ω::Array{Float64,1/2}; sum_type::Union{Symbol,Tuple{Int,Int}}=:common, reduce_range_prct::Float64 = 0.1)\n\nDetermines usable range for physical susceptibilities chi^omega or chi^omega and additionally cut away reduce_range_prct % of the range. The unusable region is given whenever the susceptibility becomes negative, or the first derivative changes sign.\n\nReturns:\n\nrange::AbstractVector{Float64} : Usable omega range for chi\n\nArguments:\n\nχ_ω                : chi^omega \nsum_type           : Optional, default :common. Can be set to :full to enforce full range, or a ::Tuple{Int,Int} to enforce a specific interval size.\nreduce_range_prct  : Optional, default 0.1. After finding the usable interval it is reduced by an additional percentage given by this value.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ν_part-Tuple{AbstractArray{Int64}, SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_ν_part","text":"genνpart(νGrid::AbstractVector{Int}, sP::SimulationParameters, N::Int)\n\nReturns partition of fermionic frequencies grid, according to the number of workers N. The partition is given as a list (of length N) of lists with 4-Tuples (ωi, ωn, νi, νn).  νi and ωi are the indices for the Matsubara frequencies νn and ωn.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ν_part_slices-Tuple{Array{ComplexF64, 3}, Vector{NTuple{4, Int64}}}","page":"Home","title":"LadderDGA.gen_ν_part_slices","text":"gen_ν_part_slices(data::Array{ComplexF64,3}, index_list::Vector{NTuple{4,Int}})\n\nRearragnes data over q, ν and ω axes, for EoM (see calc_Σ_par) given index_list, which is one element of the list of lists obtained from gen_ν_part.\n\nReturns three arrays:      - datares: Rearranged data, only containes values for ν, given in `indexlist, ω values not contained indataare set to 0.     - νn_list: Has lengthsize(datares,3)`. Contained fermionic Matsubara frequency for each index.     - ωnranges: Has length size(data_res,3). Containes bosonic Matsubara frequencies for each ν value.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_νω_part-Tuple{SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_νω_part","text":"gen_νω_part(sP::SimulationParameters, N::Int)\n\nReturns partition of frequency grid, according to the number of workers N.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ω_part-Tuple{SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_ω_part","text":"gen_ω_part(sP::SimulationParameters, N::Int)\n\nReturns partition of bosonic frequencies grid, according to the number of workers N.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gf-Tuple{Int64, Float64, Any}","page":"Home","title":"LadderDGA.gf","text":"gf(n::Int,β::Float64,ϵk)\n\nEvaluates the RPA greensfunction. G(ν,k) = \frac{1}{i ν - ϵ_k}\n\nParameters\n\nn     :: Integer that corresponds to the fermionic matsubara frequency\nβ     :: Float64  Inverse temperature in natural units\nϵk    :: evaluated dispersion relation ... (ϵk-μ)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.initialize_EoM-Tuple{lDΓAHelper, Array{ComplexF64, 3}, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.initialize_EoM","text":"function initialize_EoM([G_fft_reverse, λ₀::Array{ComplexF64,3}, νGrid::AbstractVector{Int}, \n                    kG::KGrid, mP::ModelParameters, sP::SimulationParameters]; \n                    OR [h::lDΓAHelper, λ₀, νGrid];\n                    force_reinit = false,\n                    χm::χT = collect_χ(:sp, kG, mP, sP),\n                    γm::γT = collect_γ(:sp, kG, mP, sP),\n                    χd::χT = collect_χ(:ch, kG, mP, sP),\n                    γd::γT = collect_γ(:ch, kG, mP, sP))\n\nWorker cache initialization. Must be called before calc_Σ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.initialize_EoM_cache!-Tuple{Int64}","page":"Home","title":"LadderDGA.initialize_EoM_cache!","text":"initialize_EoM_cache!()\n\nInitializes cache to correct size. kG and sP must be set first.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.iν_array-Tuple{Real, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.iν_array","text":"iν_array(β::Real, grid::AbstractArray{Int64,1})::Vector{ComplexF64}\niν_array(β::Real, size::Int)::Vector{ComplexF64}\n\nComputes list of fermionic Matsubara frequencies. If length size is given, the grid will have indices 0:size-1. Bosonic arrays can be generated with iω_array.\n\nReturns:\n\nVector of fermionic Matsubara frequencies, given either a list of indices or a length. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.iω_array-Tuple{Real, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.iω_array","text":"iω_array(β::Real, grid::AbstractArray{Int64,1})::Vector{ComplexF64}\niω_array(β::Real, size::Int)::Vector{ComplexF64}\n\nComputes list of bosonic Matsubara frequencies. If length size is given, the grid will have indices 0:size-1. Fermionic arrays can be generated with iν_array.\n\nReturns:\n\nVector of bosonic Matsubara frequencies, given either a list of indices or a length. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.log_q0_χ_check-Tuple{Dispersions.KGrid, SimulationParameters, AbstractMatrix{Float64}, Symbol}","page":"Home","title":"LadderDGA.log_q0_χ_check","text":"log_q0_χ_check(kG::KGrid, sP::SimulationParameters, χ::AbstractArray{_eltype,2}, type::Symbol)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.par_partition-Tuple{AbstractVector, Int64}","page":"Home","title":"LadderDGA.par_partition","text":"par_partition(set::AbstractVector, N::Int)\n\nReturns list of indices for partition of set into N (almost) equally large segements.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.printr_s-Tuple{ComplexF64}","page":"Home","title":"LadderDGA.printr_s","text":"printr_s(x::ComplexF64)\nprintr_s(x::Float64)\n\nprints 4 digits of (the real part of) x\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.q0_index-Tuple{Dispersions.KGrid}","page":"Home","title":"LadderDGA.q0_index","text":"q0_index(kG::KGrid)\n\nIndex of zero k-vector.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.readConfig-Tuple{String}","page":"Home","title":"LadderDGA.readConfig","text":"readConfig(cfg_in::String)\n\nReads a config.toml file either as string or from a file and returns      - workerpool     - ModelParameters     - SimulationParameters     - EnvironmentVars     - kGrid (see Dispersions.jl)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.readFortranχDMFT-Tuple{String}","page":"Home","title":"LadderDGA.readFortranχDMFT","text":"Returns χ_DMFT[ω, ν, ν']\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.reduce_range-Tuple{AbstractArray, Float64}","page":"Home","title":"LadderDGA.reduce_range","text":"reduce_range(range::AbstractArray, red_prct::Float64)\n\nReturns indices for 1D array slice, reduced by red_prct % (compared to initial range). Range is symmetrically reduced fro mstart and end.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.setup_LDGA-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}","page":"Home","title":"LadderDGA.setup_LDGA","text":"setup_LDGA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [; local_correction=true, silent=false])\n\nComputes all needed objects for DΓA calculations.\n\nReturns: lDΓAHelper\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.setup_RPA-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.setup_RPA","text":"setup_RPA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters; [silent=false])\n\nComputes all needed objects for RPA calculations.\n\nReturns: RPAHelper\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.subtract_tail!-Tuple{AbstractVector, AbstractVector, Float64, Vector{ComplexF64}, Int64}","page":"Home","title":"LadderDGA.subtract_tail!","text":"subtract_tail!(outp::AbstractArray{T,1}, inp::AbstractArray{T,1}, c::Float64, iω::Array{ComplexF64,1}, power::Int) where T <: Number\n\nsubtract the c/(iω)^power high frequency tail from inp and store in outp. See also subtract_tail\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.subtract_tail-Tuple{AbstractVector, Float64, Vector{ComplexF64}, Int64}","page":"Home","title":"LadderDGA.subtract_tail","text":"subtract_tail(inp::AbstractArray{T,1}, c::Float64, iω::Array{ComplexF64,1}, power::Int) where T <: Number\n\nsubtract the fracc(iomega)^textpower high frequency tail from input array inp.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.sum_kω-Tuple{Dispersions.KGrid, χT}","page":"Home","title":"LadderDGA.sum_kω","text":"sum_kω(kG::kGrid, χ::χT; ωn_arr=ωn_grid(χ), force_full_range=false, [transform::Function])\nsum_kω(kG::kGrid, χ::χT; ωn_arr=ωn_grid(χ), force_full_range=false, [λ::Float64])\nsum_kω(kG::KGrid, χ::AbstractMatrix{Float64}, β::Float64, ωn2_tail::Vector{Float64}; transform=nothing)::Float64\n\nReturns int_mathrmBZ dk sum_omega chi^omega_k. The bosonic Matsubara grid can be precomputed and given with ωn_arr to increase performance.\n\nTODO: for now this is only implemented for tail correction in the 1  omega^2_n term! Sums first over k, then over ω (see also sum_ω), see sum_kω for the rverse order (results can differ, due to inaccuracies in the asymptotic tail treatment). The transform function needs to have the signature f(in::Float64)::Float64 and will be applied before summation. Alternatively, λ can be given directly as Float64, if the usual λ-correction should be applied.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.sum_ω-Tuple{χT}","page":"Home","title":"LadderDGA.sum_ω","text":"sum_ω(χ::χT)\nsum_ω!(res::Vector{ComplexF64}, ωn_arr::Vector{ComplexF64}, χ::χT; force_full_range=false)::Nothing\nsum_ω!(ωn_arr::Vector{T}, χ::AbstractVector{T}, tail_c::Vector{Float64}, β::Float64; force_full_range=false)::T where T <: Union{Float64,ComplexF64}\n\nSums the physical susceptibility over all usable (if force_full_range is not set to true) bosonic frequencies, including improvd tail summation, if χ.tail_c is set.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.sum_ωk-Tuple{Dispersions.KGrid, χT}","page":"Home","title":"LadderDGA.sum_ωk","text":"sum_ωk(kG::KGrid, χ::χT; force_full_range=false)::Float64\n\nWARNING: This function is a non optimized debugging function! See sum_kω, which should return the same result if the asymptotics are captured correctly. Optional function f transforms χ before summation.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_tail!-Tuple{Vector{Float64}}","page":"Home","title":"LadderDGA.update_tail!","text":"update_tail!(coeffs::Vector{Float64})\n\nUpdates the Ekin/ω^2 tail of physical susceptibilities on all workers.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_tail!-Tuple{χT, Array{Float64}, Array{ComplexF64}}","page":"Home","title":"LadderDGA.update_tail!","text":"update_tail!(χ::χT, new_tail_c::Array{Float64}, ωnGrid::Array{ComplexF64})\n\nUpdates the fracc_iomega_n^i tail for all coefficients given in new_tail_c (index 1 corresponds to i=0).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_wcache!-Tuple{Symbol, Any}","page":"Home","title":"LadderDGA.update_wcache!","text":"update_wcache!(name::Symbol, val; override=true)\n\nUpdates worker cache with given name and value. Typically used through remotecall() on specific worker.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.usable_ωindices-Union{Tuple{N}, Tuple{SimulationParameters, Vararg{χT, N}}} where N","page":"Home","title":"LadderDGA.usable_ωindices","text":"usable_ωindices(sP::SimulationParameters, χ_sp::χT, χ_ch::χT)\n\nHelper function, returning the indices n for omega_n ranges of multiple channels. If dbg_full_eom_omega is set to true in the config, the full range will be returned, otherwise an intersection of the usable ranges obtained from find_usable_χ_interval.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.Δ-Tuple{Vector{Float64}, Vector{Float64}, Vector{ComplexF64}}","page":"Home","title":"LadderDGA.Δ","text":"Δ(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, νₙ::Vector{ComplexF64})::Vector{ComplexF64}\n\nComputes hybridization function Delta(inu_n) = sum_k fracV_k^2nu_n - epsilon_k from Anderson parameters (for example obtained through exact diagonalization).\n\nReturns:\n\nHybridization function  over list of given fermionic Matsubara frequencies.\n\nArguments:\n\nϵₖ : list of bath levels\nVₖ : list of hopping amplitudes\nνₙ : Vector of fermionic Matsubara frequencies, see also: iν_array.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.Σ_Dyson-Tuple{Vector{ComplexF64}, Vector{ComplexF64}}","page":"Home","title":"LadderDGA.Σ_Dyson","text":"Σ_Dyson(GBath::Vector{ComplexF64}, GImp::Vector{ComplexF64})::Vector{ComplexF64}\nΣ_Dyson!(Σ::Vector{ComplexF64}, GBath::Vector{ComplexF64}, GImp::Vector{ComplexF64})::Vector{ComplexF64}\n\nCalculates Sigma = 1  G_textbath - 1  G_textimp.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.λ_from_γ-Tuple{Symbol, γT, χT, Float64}","page":"Home","title":"LadderDGA.λ_from_γ","text":"λ_from_γ(type::Symbol, γ::γT, χ::χT, U::Float64)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ν0Index_of_ωIndex-Tuple{Int64, SimulationParameters}","page":"Home","title":"LadderDGA.ν0Index_of_ωIndex","text":"ν0Index_of_ωIndex(ωi::Int[, sP])::Int\n\nCalculates index of zero fermionic Matsubara frequency (which may depend on the bosonic frequency).  ωi is the index (i.e. starting with 1) of the bosonic Matsubara frequency.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νi_health-Tuple{AbstractArray{Int64}, SimulationParameters}","page":"Home","title":"LadderDGA.νi_health","text":"νi_health(νGrid::AbstractArray{Int}, sP::SimulationParameters)\n\nReturns a list of available bosonic frequencies for each fermionic frequency, given in νGrid. This can be used to estimate the maximum number of usefull frequencies for the equation of motion.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νi_νngrid_pos-Tuple{Int64, Int64, SimulationParameters}","page":"Home","title":"LadderDGA.νi_νngrid_pos","text":"νi_νngrid_pos(ωi::Int, νmax::Int, sP::SimulationParameters)\n\nIndices for positive fermionic Matsubara frequencies, depinding on ωi, the index of the bosonic Matsubara frequency.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νnGrid-Tuple{Int64, SimulationParameters}","page":"Home","title":"LadderDGA.νnGrid","text":"νnGrid(ωn::Int, sP::SimulationParameters)\n\nCalculates grid of fermionic Matsubara frequencies for given bosonic frequency ωn (including shift, if set through sP).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.χ₀Asym-Tuple{Float64, Vector{Float64}, Float64, AbstractVector{Int64}, Int64, Bool, Float64}","page":"Home","title":"LadderDGA.χ₀Asym","text":"χ₀Asym(c1::Float64, c2::Vector{Float64}, c3::Float64, ωnGrid::AbstractVector{Int}, n_iν::Int, shift::Int, β::Float64)\n\nBuilds asymtotic helper array. See calc_bubble implementation for details.\n\nc1, c2 and c3 are the coefficients for the asymtotic tail expansion and can be obtained through χ₀Asym_coeffs. n_iν is the number of positive fermionic Matsubara frequencies, shift is either 1 or 0, depending on the type of frequency grid.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.χ₀Asym_coeffs-Tuple{Dispersions.KGrid, Bool, ModelParameters}","page":"Home","title":"LadderDGA.χ₀Asym_coeffs","text":"χ₀Asym_coeffs(kG::KGrid, local_tail::Bool, mP::ModelParameters)\n\nBuilds tail coefficients for the χ₀ asymptotic helper, obtained through χ₀Asym.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ω0_index-Tuple{SimulationParameters}","page":"Home","title":"LadderDGA.ω0_index","text":"ω0_index(sP::SimulationParameters)\nω0_index(χ::[χT or AbstractMatrix])\n\nIndex of ω₀ frequency. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ω_tail-Tuple{χT, χT, AbstractVector{Float64}, SimulationParameters}","page":"Home","title":"LadderDGA.ω_tail","text":"ω_tail(ωindices::AbstractVector{Int}, coeffs::AbstractVector{Float64}, sP::SimulationParameters) \nω_tail(χ_sp::χT, χ_ch::χT, coeffs::AbstractVector{Float64}, sP::SimulationParameters)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ωn_grid-Tuple{χT}","page":"Home","title":"LadderDGA.ωn_grid","text":"ωn_grid(χ::χT)\n\nComputes bosonic frequencies for χ: 2 i pi n  beta.\n\n\n\n\n\n","category":"method"},{"location":"#LambdaCorrection","page":"Home","title":"LambdaCorrection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This sub-module contains function related to the lambda-correction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LambdaCorrection]\nOrder   = [:module, :constant, :type, :function, :marco]","category":"page"},{"location":"#LadderDGA.LambdaCorrection.bisect-NTuple{4, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.bisect","text":"bisect(λl::T, λm::T, λr::T, Fm::T)::Tuple{T,T} where T <: Union{Float64, Vector{Float64}}\n\nWARNING: Not properly tested! Bisection root finding algorithm. This is a very crude adaption of the 1D case.  The root may therefore lie outside the given region and the search space has to be corrected using correct_margins.\n\nReturns:\n\n(Vector of) new interval borders, according to Fm.\n\nArguments:\n\nλl : (Vector of) left border(s) of bisection area\nλm : (Vector of) central border(s) of bisection area\nλr : (Vector of) right border(s) of bisection area\nFm : (Vector of) Poincare-Miranda condition (s)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.correct_margins-NTuple{4, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.correct_margins","text":"correct_margins(λl::T, λm::T, λr::T, Fm::T, Fr::T)::Tuple{T,T} where T <: Union{Float64, Vector{Float64}}\n\nHelper method for bisect.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.dχ_λ-Tuple{Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.dχ_λ","text":"dχ_λ(χ::[Float64,ComplexF64,AbstractArray], λ::Float64)\n\nFirst derivative of χ_λ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.gen_νω_indices-Tuple{χT, χT, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.LambdaCorrection.gen_νω_indices","text":"gen_νω_indices(χ_m::χT, χ_d::χT, sP::SimulationParameters)\n\nInternal helper to generate usable bosonic and fermionic ranges. Also returns the c_1x^2 tail. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.get_λ_min-Tuple{AbstractMatrix{Float64}}","page":"Home","title":"LadderDGA.LambdaCorrection.get_λ_min","text":"get_λ_min(χr::AbstractArray{Float64,2})::Float64\n\nComputes the smallest possible lambda-correction parameter (i.e. first divergence of chi(q)), given as lambda_textmin = - min_q(1  chi^omega_0_q).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.newton_right-Tuple{Function, Function, Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.newton_right","text":"newton_right(f::Function, [df::Function,] start::[Float64,Vector{Float64},MVector{Float64}], min::[Float64,Vector{Float64},MVector{Float64}]; nsteps=5000, atol=1e-11)\n\nComputes root of function f but under the condition that each compontent of the root is larger than the corresponding component of the start vector. This algorithm also assumes, that f is stricly monotonically decreasing in each component. nsteps sets the maximum number of newton-steps, atol sets the convergence tolerance. df can be omitted. In this case it is approximated using finite differences.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.run_sc_old-Tuple{χT, γT, χT, γT, Union{Float64, ComplexF64}, AbstractArray{ComplexF64, 3}, OffsetArrays.OffsetArray, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Float64, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.LambdaCorrection.run_sc_old","text":"TODO: refactor (especially _par version)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λ_seach_range-Tuple{Matrix{Float64}}","page":"Home","title":"LadderDGA.LambdaCorrection.λ_seach_range","text":"λ_seach_range(χ::Matrix{Float64}; λ_max_default = 50)\n\nCalculates reasonable interval for the search of the lambda-correction parameter. \n\nThe interval is chosen with lambda_textmin, such that all unphysical poles are excluded and lambda_textmax = lambda_textdefault  max_qomega chi(qomega). The λ_max_default parameter may need to be adjusted, depending on the model, since in principal arbitrarily large maximum values are possible.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, lDΓAHelper}","page":"Home","title":"LadderDGA.LambdaCorrection.λdm_correction","text":"λdm_correction(χm, γm, χd, γd, [Σ_loc, gLoc_rfft, λ₀, kG, mP, sP] OR [h::lDΓAHelper, λ₀]; \n    maxit_root = 100, atol_root = 1e-8, λd_min_δ = 0.1, λd_max = 500,\n    maxit::Int = 50, update_χ_tail=false, mixing=0.2, conv_abs=1e-8, par=false)\n\nCalculates lambda_mathrmdm and associated quantities like the self-energy.\n\nTODO: full documentation. Pack results into struct\n\nReturns:\n\nλdm: `Vector`, containing `λm` and `λd`.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λdm_correction_old-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, lDΓAHelper}","page":"Home","title":"LadderDGA.LambdaCorrection.λdm_correction_old","text":"λdm_correction_old(χ_m, γ_m, χ_d, γ_d, [Σ_loc, gLoc_rfft, λ₀, kG, mP, sP] OR [h::lDΓAHelper, λ₀]; \n    maxit_root = 100, atol_root = 1e-8, λd_min_δ = 0.1, λd_max = 500,\n    maxit::Int = 50, update_χ_tail=false, mixing=0.2, conv_abs=1e-8, par=false)\n\nCalculates lambda_mathrmdm and associated quantities like the self-energy.\n\nTODO: full documentation. Pack results into struct\n\nReturns:\n\nΣ_ladder : ladder self-energy\nG_ladder : ladder Green's function obtained from `Σ_ladder`\nE_kin    : kinetic energy, unless `update_χ_tail = true`, this will be not consistent with the susceptibility tail coefficients.\nE_pot    : one-particle potential energy, obtained through galitskii-migdal formula\nμnew:    : chemical potential of `G_ladder`\nλm       : λ-correction for the magnetic channel\nlhs_c1   : check-sum for the Pauli-principle value obtained from the susceptibilities (`λm` fixes this to ``n/2 \\cdot (1-n/2)``) \nE_pot_2  : Potential energy obtained from susceptibilities. `λd` fixes this to `E_pot`\nconverged: error flag. False if no `λd` was found. \nλd       : λ-correction for the density channel.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λm_correction-Tuple{χT, Float64, lDΓAHelper}","page":"Home","title":"LadderDGA.LambdaCorrection.λm_correction","text":"λm_correction(χm::χT, rhs::Float64, h::lDΓAHelper; verbose::Bool=false, validate_threshold::Float64=1e-8)\nλm_correction(χm::χT, rhs::Float64, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; verbose::Bool=false, validate_threshold::Float64=1e-8)\n\nCalculates lambda_mathrmm value, by fixing sum_qomega chi^lambda_mathrmm_uparrowuparrow(qiomega) = fracn2(1-fracn2).\n\nSet verbose to obtain a trace of the checks. validate_threshold sets the threshold for the rhs ≈ lhs condition, set to Inf in order to accept any result. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λm_rhs-Tuple{χT, χT, lDΓAHelper}","page":"Home","title":"LadderDGA.LambdaCorrection.λm_rhs","text":"λm_rhs(χ_m::χT, χ_d::χT, λd::Float64, h::lDΓAHelper; λ_rhs = :native, verbose=false)\nλm_rhs(imp_density::Float64, χ_m::χT, χ_d::χT, λd::Float64, kG::KGrid, mP::ModelParameters, sP::SimulationParameters, λ_rhs = :native)\n\nHelper function for the right hand side of the Pauli principle conditions (λm correction). imp_density can be set to NaN, if the rhs (fracn2(1-fracn2)) should not be error-corrected (not ncessary or usefull when asymptotic improvement are active). TODO: write down formula, explain imp_density as compensation to DMFT.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.χ_λ!-Tuple{χT, χT, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.χ_λ!","text":"χ_λ!(χ_destination::[AbstractArray,χT], [χ::[AbstractArray,χT], ] λ::Float64)\n\nInplace version of χ_λ. If the second argument is omitted, results are stored in the input χ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.χ_λ-Tuple{Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.χ_λ","text":"χ_λ(χ::[Float64,ComplexF64,AbstractArray,χT], λ::Float64)\n\nComputes the λ-corrected susceptibility:  chi^lambdaomega_q = frac11  chi^lambdaomega_q + lambda. The susceptibility chi can be either given element wise, or as χT See also χT in LadderDGA.jl.\n\n\n\n\n\n","category":"method"}]
}
