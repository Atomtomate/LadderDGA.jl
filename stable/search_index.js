var documenterSearchIndex = {"docs":
[{"location":"deps/","page":"Dependencies","title":"Dependencies","text":"There are two functionalities which have been factored out to separate projects: Handeling of frequency sums and operations involving k-grids.","category":"page"},{"location":"deps/#Frequency-Summations","page":"Dependencies","title":"Frequency Summations","text":"","category":"section"},{"location":"deps/","page":"Dependencies","title":"Dependencies","text":"The summation over Matsubara frequencies is defined over a set on infinitely many frequencies. A canonical approach to approximate this sum,","category":"page"},{"location":"deps/#K-Grids","page":"Dependencies","title":"K-Grids","text":"","category":"section"},{"location":"#LadderDGA.jl-Documentation","page":"Home","title":"LadderDGA.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LadderDGA","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#List-of-Functions","page":"Home","title":"List of Functions","text":"","category":"section"},{"location":"#LadderDGA","page":"Home","title":"LadderDGA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [LadderDGA]\nOrder   = [:module, :constant, :type, :function, :marco]","category":"page"},{"location":"#LadderDGA.EnvironmentVars","page":"Home","title":"LadderDGA.EnvironmentVars","text":"EnvironmentVars <: ConfigStruct\n\nContains various settings, controlling the I/O behaviour of this module. This is typically generated from a config.toml file using the readConfig function.\n\nFields\n\ninputDir        : String, Directory of input files\ninputVars       : String, File name of .jld2 file containing input.\nloglevel        : String, Options: disabled, error, warn, info, debug\nlogfile         : String,    Options: STDOUT, STDERR, filename\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.ModelParameters","page":"Home","title":"LadderDGA.ModelParameters","text":"ModelParameters <: ConfigStruct\n\nContains model parameters for the Hubbard model. This is typically generated from a config.toml file using  the readConfig function.\n\nFields\n\nU         : Float64, Hubbard U\nμ         : Float64, chemical potential\nβ         : Float64, inverse temperature\nn         : Float64, filling\nEpot_1Pt : Float64, DMFT potential energy\nEkin_1Pt : Float64, DMFT kinetic energy\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.RPAHelper","page":"Home","title":"LadderDGA.RPAHelper","text":"RPAHelper <: RunHelper\n\nStruct with data needed to run ladder RPA calculations.\n\nConstructor\n\nsetup_RPA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [; silent=false])\n\nSee setup_RPA\n\nFields\n\nTODO: documentation\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.SimulationParameters","page":"Home","title":"LadderDGA.SimulationParameters","text":"SimulationParameters <: ConfigStruct\n\nContains simulation parameters for the ladder DGA computations. This is typically generated from a config.toml file using the readConfig function.\n\nFields\n\nn_iω                    : Int, Number of positive bosonic frequencies (full number will be 2*n_iω+1 \nn_iν                    : Int, Number of positive fermionic frequencies (full number will be 2*n_iν \nn_iν_shell              : Int, Number of fermionic frequencies used for asymptotic sum improvement (χ_asym_r arrays with at least these many entries need to be provided)\nshift                   : Bool, Flag specifying if -n_iν:n_iν-1 is shifted by -ωₙ/2 at each ωₙ slice (centering the main features)\nχ_helper                : struct, helper struct for asymptotic sum improvements involving the generalized susceptibility (nothing if n_iν_shell == 0), see also BSE_SC.jl.\nsVk                     : Float64, ∑_k Vₖ^2\nfft_range               : Int, Frequencies used for computations of type f(νₙ + ωₙ). \nusable_prct_reduction   : Float64, percent reduction of usable bosonic frequencies\ndbg_full_eom_omega      : Bool, if true overrides usable ω ranges to n_iω.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.lDΓAHelper","page":"Home","title":"LadderDGA.lDΓAHelper","text":"lDΓAHelper <: RunHelper\n\nStruct with data needed to run ladder DΓA calculations.\n\nConstructor\n\nsetup_LDGA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars)\n\nSee setup_LDGA\n\nFields\n\nTODO: documentation for fields\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.γT","page":"Home","title":"LadderDGA.γT","text":"γT <: MatsubaraFunction\n\nStruct for the non-local triangular vertex. \n\nFields\n\ndata         : Array{ComplexF64,3}, data\naxis_types   : Dict{Symbol,Int}, Dictionary mapping :q, :ν, :ω to the axis indices.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.χT","page":"Home","title":"LadderDGA.χT","text":"χT <: MatsubaraFunction\n\nStruct for the non-local susceptibilities. \n\nConstructor\n\nχT(data::Array{T, 2}; full_range=true, reduce_range_prct=0.1): if full_range is set to false, the usable range  is determined via find_usable_χ_interval.\n\nFields\n\ndata         : Array{ComplexF64,3}, data\naxis_types   : Dict{Symbol,Int}, Dictionary mapping :q, :ω to the axis indices.\nindices_ω    : Vector{Int}, \ntail_c       : Vector{Float64}, tail coefficients of 1omega^i tails. Index 1 corresponds to i=0.\nλ            : Float64, λ correction parameter.\nβ            : Float64, inverse temperature.\nusable_ω     : AbstractArray{Int}, usable indices for which data is assumed to be correct. See also find_usable_χ_interval\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.χ₀RPA_T","page":"Home","title":"LadderDGA.χ₀RPA_T","text":"χ₀RPA_T <: MatsubaraFunction\n\nStruct for the RPA bubble term.\n\nTODO: this does not use the χ₀Asym function and mixes thermodynamic quantities (kinetic energy) with       tail coefficients (they are the same, but should not be stored this way here).\n\nConstructor\n\nχ₀RPAT(data::Array{eltype,2}, ωnGrid::AbstractVector{Int}, νnGrid::UnitRange{Int64}, β::Float64)\n\nThis constructor does not perform any checks for the entered data array in the currently implemented version. Make sure that the axes match the axis_types field!\n\nFields\n\ndata         : Array{ComplexF64,3}, data.\naxis_types   : Dict{Symbol,Int}, Dictionary mapping :q, :ω to the axis indices.\nindices_ω    : Vector{Int}, m indices m of bosonic omega_m Matsubara frequencies.\nβ            : Float64, inverse temperature.\ne_kin        : Float64, kinetic energy.\nNq           : Int, Number of points per dimension that are used to sample the reciprocal space\nNgl           : Int, Number of gauß-legendre sample points per dimension that where used to calculate each element\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.χ₀T","page":"Home","title":"LadderDGA.χ₀T","text":"χ₀T <: MatsubaraFunction\n\nStruct for the bubble term. The q, ω dependent asymptotic behavior is computed from the  t1 and t2 input.  See χ₀Asym_coeffs implementation for details.\n\nConstructor\n\nχ₀T(type::Symbol, data::Array{_eltype,3}, kG::KGrid, ωnGrid::AbstractVector{Int}, n_iν::Int, shift::Bool, mP::ModelParameters)\n\nSet local_tail=true in case of the local bubble constructed fro mthe impurity Green's function. This is necessary in order to construct the correct asymptotics.\n\nFields\n\ntype         : Symbol, can be DMFT, local, RPA, RPA_exact. TODO: documentation\ndata         : Array{ComplexF64,3}, data\nasym         : Array{ComplexF64,2}, [q, ω] dependent asymptotic behavior.\naxis_types   : Dict{Symbol,Int}, Dictionary mapping :q, :ν, :ω to the axis indices.\nindices_νω   : Matrix{Tuple{Int,Int}}, (n,m) indices of fermionic nu_n and bosonic omega_m Matsubara frequencies.\nβ            : Float64, inverse temperature.\n\n\n\n\n\n","category":"type"},{"location":"#Base.show-Tuple{IO, ModelParameters}","page":"Home","title":"Base.show","text":"Base.show(io::IO, m::ModelParameters)\n\nCustom output for ModelParameters\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, SimulationParameters}","page":"Home","title":"Base.show","text":"Base.show(io::IO, m::SimulationParameters)\n\nCustom output for SimulationParameters\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.EPot1-Tuple{Dispersions.KGrid, AbstractMatrix{ComplexF64}, Matrix{ComplexF64}, Matrix{ComplexF64}, Vector{Float64}, Float64}","page":"Home","title":"LadderDGA.EPot1","text":"Specialized function for DGA potential energy. Better performance than calc_E.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.EPot_p1-Tuple{χT, χT, Vararg{Float64, 4}}","page":"Home","title":"LadderDGA.EPot_p1","text":"EPot_p1(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64, U::Float64)::Float64\n\nPauli-Principle on 2-particle level: sum_knu G^lambdanu_k Sigma^lambdanu_k.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.EPot_p2-Tuple{χT, χT, Float64, Float64, Float64, Float64, Dispersions.KGrid}","page":"Home","title":"LadderDGA.EPot_p2","text":"EPot_p2(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64, U::Float64)::Float64\n\nPauli-Principle on 2-particle level: U(sum_komega chi^lambdaomega_mk - sum_komega chi^lambdaomega_dk)2 + U n^24.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.F_from_χ-Tuple{Symbol, lDΓAHelper}","page":"Home","title":"LadderDGA.F_from_χ","text":"F_from_χ(type::Symbol, h::lDΓAHelper; diag_term=true)\nF_from_χ(χ::AbstractArray{ComplexF64,3}, G::AbstractArray{ComplexF64,1}, sP::SimulationParameters, β::Float64; diag_term=true)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.F_from_χ_gen-Tuple{χ₀T, Array{ComplexF64, 4}}","page":"Home","title":"LadderDGA.F_from_χ_gen","text":"F_from_χ_gen(χ₀::χ₀T, χr::Array{ComplexF64,4})::Array{ComplexF64,4}\n\nCalculates the full vertex from the generalized susceptibility chi^nunuomega_r and the bubble term chi_0 via F^nunuomega_rmathbfq       =      beta^2 left( chi^nunuomega_0mathbfq right)^-1       - left( chi^nuomega_0mathbfq right)^-1  chi^nunuomega_rmathbfq left( chi^nuomega_0mathbfq right)^-1\n\nFor a version using the physical susceptibilities see F_from_χ_gen.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.F_from_χ_star_gen-Tuple{χ₀T, Array{ComplexF64, 4}, χT, γT, Float64}","page":"Home","title":"LadderDGA.F_from_χ_star_gen","text":"F_from_χ_star_gen(χ₀::χ₀T, χstar_r::Array{ComplexF64,4}, χr::χT, γr::γT, Ur::Float64)\n\nCalculates the full vertex from the generalized susceptibility chi^nunuomega_r, the physical susceptibility chi^omega_r and the triangular vertex gamma^nuomega_r. This is usefull to calculate a lambda-corrected full vertex. \n\nF^nunuomega_rmathbfq       =      beta^2 left( chi^nunuomega_0mathbfq right)^-1       - beta^2 (chi^nuomega_0mathbfq)^-1 chi^*nunuomega_rmathbfq (chi^nuomega_0mathbfq)^-1      + U_r (1 - U_r chi^omega_rmathbfq) gamma^nuomega_rmathbfq gamma^nuomega_rmathbfq For a version using the physical susceptibilities see F_from_χ_gen.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_fft-Tuple{OffsetArrays.OffsetArray, Dispersions.KGrid, SimulationParameters}","page":"Home","title":"LadderDGA.G_fft","text":"G_fft(G::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCalculates fast Fourier transformed lattice Green's functions used for calc_bubble.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_from_Σ-Tuple{Int64, Float64, Float64, Float64, ComplexF64}","page":"Home","title":"LadderDGA.G_from_Σ","text":"G_from_Σ(ind::Int64, β::Float64, μ::Float64, ϵₖ::Float64, Σ::ComplexF64)\nG_from_Σ(mf::ComplexF64, μ::Float64, ϵₖ::Float64, Σ::ComplexF64)\n\nComputes Green's function according to frac(2 n + 1)pi ibeta + mu - epsilon_k - Sigma(kinu_n)^-1, where epsilon_k and Sigma(kinu_n) are given as single values. Convenience wrappers for full grids are provided below.\n\nArguments:\n\nind : Matsubara frequency index\nmf  : Matsubara frequency\nβ   : Inverse temperature (only needs to be set, if index instead of frequency is given)\nμ   : Chemical potential\nϵₖ  : Dispersion relation at fixed k, see below for convenience wrappers.\nΣ   : Self energy at fixed frequency (and potentially fixed k), see below for convenience wrappers.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_from_Σ-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Vector{Float64}, UnitRange{Int64}, ModelParameters}","page":"Home","title":"LadderDGA.G_from_Σ","text":"G_from_Σ(Σ::OffsetVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::UnitRange{Int}, mP::ModelParameters;\n              μ = mP.μ, Σloc::OffsetVector{ComplexF64} = OffsetVector(ComplexF64[], 0:-1),\n        )\nG_from_Σ!(res::OffsetMatrix{ComplexF64}, Σ::OffsetVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::UnitRange{Int},\n            mP::ModelParameters; μ = mP.μ, Σloc::OffsetVector{ComplexF64} = OffsetVector(ComplexF64[], 0:-1),\n        )::Nothing\n\nmP::ModelParameters; μ = mP.μ, Σloc::OffsetVector{ComplexF64} = OffsetVector(ComplexF64[], 0:-1),\n\nG_from_Σ(Σ::AbstractVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::AbstractVector{Int}, mP::ModelParameters; μ = mP.μ,  Σloc::AbstractArray = nothing) \nG_from_Σ!(res::Matrix{ComplexF64}, Σ::AbstractVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::AbstractVector{Int}, mP::ModelParameters; μ = mP.μ,  Σloc::AbstractVector = nothing)\n\n#TODO: unify API, redo documentation\n\nComputes Green's function from self energy Σ and dispersion ϵkGrid over given frequency indices range. Optionally, a different chemical potential μ can be provided. When the non-local self energy is used, one typically wants to extend the usefull range of frequencies by attaching the tail of the local self energy in the high frequency regime. This is done by providing a range larger than the array size of Σ and in addition setting Σloc (the size of Σloc must be as large or larger than range).  The inplace version stores the result in res.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_from_Σladder-Tuple{AbstractMatrix{ComplexF64}, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.G_from_Σladder","text":"G_from_Σladder(Σ_ladder::AbstractMatrix{ComplexF64}, Σloc::Vector{ComplexF64}, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; \n               fix_n::Bool=false, μ=mP.μ, improved_sum_filling::Bool=true, νRange = sP.fft_range, n = mP.n, νFitRange=0:last(axes(Σ_ladder, 2)) )\nG_from_Σladder!(G_new::OffsetMatrix{ComplexF64}, Σ_ladder::OffsetMatrix{ComplexF64}, Σloc::AbstractVector{ComplexF64}, kG::KGrid, mP::ModelParameters; \n                fix_n::Bool=false, μ=mP.μ, improved_sum_filling::Bool=true, n = mP.n, νFitRange=0:last(axes(Σ_ladder, 2)) )\n\nComputes Green's function from lDΓA self-energy. This is the Greensfunction used in eq. (8) of Stobbe, J., & Rohringer, G. (2022). Consistency of potential energy in the dynamical vertex approximation. Physical Review B, 106(20), 205101.\n\nThe resulting frequency range is given by default as νRange = sP.fft_range, if less frequencies are available from Σ_ladder, Σloc is used instead. TODO: documentation for arguments TODO: fit function computes loads of unnecessary frequencies\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_rfft!-Tuple{OffsetArrays.OffsetArray, OffsetArrays.OffsetArray, Dispersions.KGrid, UnitRange}","page":"Home","title":"LadderDGA.G_rfft!","text":"G_rfft!(G_rfft::GνqT, G::GνqT, kG::KGrid, fft_range::UnitRange)::Nothing\n\nCalculates fast Fourier transformed lattice Green's functions used for calc_bubble. Inplace version of G_fft.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, Int64, SimulationParameters}","page":"Home","title":"LadderDGA.OneToIndex_to_Freq","text":"OneToIndex_to_Freq(ωi::Int, νpi::Int, νi::Int, sP::SimulationParameters)\nFreq_to_OneToIndex(ωn::Int, νn::Int, νpn::Int, shift::Int, nBose::Int, nFermi::Int)\n\nConverts Matsubara frequency index to array indices, starting at 1. This is the inverse function of OneToIndex_to_Freq.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, SimulationParameters}","page":"Home","title":"LadderDGA.OneToIndex_to_Freq","text":"OneToIndex_to_Freq(ωi::Int, νi::Int, sP::SimulationParameters)\nOneToIndex_to_Freq(ωi::Int, νi::Int, shift::Int, nBose::Int, nFermi::Int)\n\nConverts (1:N,1:N) index tuple for bosonic (ωi) and fermionic (νi) frequency to Matsubara frequency number. If the array has a ν shell (for example for tail improvements) this will also be taken into account by providing Nν_shell. This is the inverse function of Freq_to_OneToIndex.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.PP_p1-Tuple{χT, χT, Vararg{Float64, 4}}","page":"Home","title":"LadderDGA.PP_p1","text":"PP_p1(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64, U::Float64)::Float64\n\nPauli-Principle on 1-particle level: n2 (1-n2).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.PP_p2-Tuple{χT, χT, Float64, Float64, Float64, Float64, Dispersions.KGrid}","page":"Home","title":"LadderDGA.PP_p2","text":"PP_p2(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64, U::Float64)::Float64\n\nPauli-Principle on 2-particle level: (sum_komega chi^lambdaomega_mk + sum_komega chi^lambdaomega_dk)2.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA._update_tail!-Tuple{Vector{Float64}}","page":"Home","title":"LadderDGA._update_tail!","text":"_update_tail!(coeffs::Vector{Float64})\n\nUpdates the Ekin/ω^2 tail of physical susceptibilities on worker. Used by update_tail!.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.attach_Σloc-Tuple{OffsetArrays.OffsetMatrix{T} where T, OffsetArrays.OffsetVector{T} where T}","page":"Home","title":"LadderDGA.attach_Σloc","text":"attach_Σloc(Σ_ladder::OffsetMatrix, Σ_loc::OffsetVector; \n            ν_first::Int=last(axis(Σ_ladder,2))+1, ν_last::Int=last(axes(Σloc,1)))\n\nAttach the local self energy tail, starting at ν_first up to ν_last to the ladder self energy. #TODO: attach this smoothely by also considering derivatives\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.bse_inv-Tuple{Symbol, Array{ComplexF64, 3}}","page":"Home","title":"LadderDGA.bse_inv","text":"bse_inv(type::Symbol, Γr::Array{ComplexF64,3})\n\nKernel for calculation of susceptibility and triangular vertex. Used by calc_χγ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.build_GG-Tuple{Dispersions.KGrid, OffsetArrays.OffsetMatrix{T} where T, AbstractVector{Int64}, AbstractVector}","page":"Home","title":"LadderDGA.build_GG","text":"build_GG(GF::OffsetMatrix, νnGrid::AbstractVector{Int}, kVecs::AbstractVector{NTuple})::Matrix{ComplexF64}\n\nBuilds helper array A, defined as: A^nu_k = G^nu_k G^-nu_-k. Used, for example, by build_Γs.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.build_q_access_G-Tuple{Dispersions.KGrid, AbstractVector}","page":"Home","title":"LadderDGA.build_q_access_G","text":"build_q_access(kG::KGrid, k_vecs::AbstractVector{NTuple})::Array{Int,2}\n\nBuilds helper array A, defined as: A^nu_k = G^nu_k G^-nu_-k. Used, for example, by build_Γs.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_E-Tuple{χT, γT, χT, γT, Any, Any, Any, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_E","text":"calcE(χsp::χT, γsp::γT, χch::χT, γch::γT, λ₀, Σloc, gLocrfft, kG::KGrid, mP::ModelParameters, sP::SimulationParameters;          νmax::Int = eomνcutoff(sP), tc::Bool=true) calcE([G::Array{ComplexF64,2},] Σ::AbstractArray{ComplexF64,2}, kG::KGrid, mP::ModelParameters; trace::Bool=false)\n\nReturns kinetic and potential energies from given      * self-energy Σ or     * the ingredients of the equation of motion: the physical susceptibilies as well as the triangular vertices in spin and charge channel, the correction term and the greensfunction to be used.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_E_ED-Tuple{String}","page":"Home","title":"LadderDGA.calc_E_ED","text":"calc_E_ED(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, GImp::Vector{ComplexF64}, U, n, μ, β)\ncalc_E_ED(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, GImp::Vector{ComplexF64}, mP::ModelParameters)\ncalc_E_ED(fname::String)\n\nComputes kinetic and potential energies from Anderson parameters.\n\nReturns:\n\n(EKin, EPot): Tuple{Float64,Float64}, kinetic and potential energy.\n\nArguments:\n\nfname : jld2-file containing the fields: [gImp, β, ϵₖ, Vₖ, U, nden, μ] (see below)\nϵₖ    : bath levels\nVₖ    : hoppend amplitudes\nGImp  : impurity Green's function. WARNING: the arguments are assumed to by fermionic Matsuabra indices 0:length(GImp)-1!\nU     : Coulomb interaction strength\nn     : number density\nμ     : chemical potential\nβ     : inverse temperature\nmP    : Alternative call with model parameters as Float64. See also ModelParameters.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_bubble-Tuple{Symbol, LadderDGA.RunHelper}","page":"Home","title":"LadderDGA.calc_bubble","text":"calc_bubble(type::Symbol, h <: RunHelper; mode=:ph)\ncalc_bubble(type::Symbol, Gνω::GνqT, Gνω_r::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; mode=:ph)\n\nCalculates bubble term.\n\nchi^omega_0mathbfq = -Sigma_mathbfk Sigma_nu G^nu_mathbfk cdot G^nu+omega_mathbfk+mathbfq\n\nwhere     nu     : Fermionic Matsubara frequencies     omega  : Bosonic Matsubara frequencies     mathbfk mathbfq: Element of the first Brillouin zone\n\nThis is a real-valued quantity.\n\nReturns\n\nBubble, χ₀::χ₀T\n\nArguments\n\ntype      : Symbol, can be DMFT, local, RPA, RPA_exact. TODO: documentation\nRPAHelper :  Helper struct generated by setup_RPA.\nβ         : Float64, Inverse temperature in natural units\nkG        : KGrid,   The k-grid on which to perform the calculation\nsP        : SimulationParameters, (to construct a frequency range)\nmode      : selects particle-hole (:ph, default) or particle-particle (:pp) notation \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_bubble_par-Tuple{lDΓAHelper}","page":"Home","title":"LadderDGA.calc_bubble_par","text":"calc_bubble_par(h::lDΓAHelper; collect_data=true)\ncalc_bubble_par(kG::KGrid, mP::ModelParameters, sP::SimulationParameters; collect_data=true)\n\nCalculates the bubble, based on two fourier-transformed Greens functions where the second one has to be reversed.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_gen_χ-Tuple{Array{ComplexF64, 3}, χ₀T, Dispersions.KGrid}","page":"Home","title":"LadderDGA.calc_gen_χ","text":"calc_gen_χ(Γr::ΓT, χ₀::χ₀T, kG::KGrid)\n\nCalculates generalized susceptibility from Γr by solving the Bethe Salpeter Equation.  See calc_χγ for direct (and more efficient) calculation of physical susceptibility and triangular vertex.\n\nReturns: chi^nunuomega_q as 4-dim array with axis: νi, νpi, qi, ωi.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Γs_ud-Tuple{Any, Any, Any, lDΓAHelper, OffsetArrays.OffsetMatrix{T} where T}","page":"Home","title":"LadderDGA.calc_Γs_ud","text":"calc_Γs_ud(Fm, Fd, Phi_ud, h::lDΓAHelper)\n\nCalculates the Γs in particle-particle notation from the ladder vertices.  \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}","page":"Home","title":"LadderDGA.calc_Σ","text":"calc_Σ(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::λ₀T, h::lDΓAHelper;\n       νmax=eom_ν_cutoff(h), λm::Float64=0.0, λd::Float64=0.0, tc::Bool=true)\ncalc_Σ(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::λ₀T, gLoc_rfft, h; \n       νmax::Int=eom_ν_cutoff(h), λm::Float64 = 0.0, λd::Float64 = 0.0, tc::Bool = true)\ncalc_Σ(χm::χT, γm::γT, χd::χT, γd::γT, χ_m_sum::Union{Float64,ComplexF64}, λ₀::λ₀T,\n       Gνω::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; \n       νmax=eom_ν_cutoff(sP), λm::Float64=0.0, λd::Float64=0.0, tc::Bool=true)\n\nCalculates the self-energy from ladder quantities.\n\nThis is the single core variant, see calc_Σ_par for the parallel version.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ_eom_par-Tuple{Float64, Float64}","page":"Home","title":"LadderDGA.calc_Σ_eom_par","text":"calc_Σ_eom_par(νmax::Int)\n\nEquation of motion for self energy. See calc_Σ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ_par-Tuple{}","page":"Home","title":"LadderDGA.calc_Σ_par","text":"calc_Σ_par(; λm::Float64=0.0, λd::Float64=0.0, collect_data=true, tc::Bool=true)\n\nCalculates self-energy on worker pool. Workers must first be initialized using initialize_EoM. #TODO: νrange must be equal to the one used during initialization. remove one.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ_parts-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, lDΓAHelper}","page":"Home","title":"LadderDGA.calc_Σ_parts","text":"calc_Σ_parts(χm::χT,γm::γT,χd::χT,γd::γT,h::lDΓAHelper,λ₀::AbstractArray{ComplexF64,3};λm::Float64=0.0, λd::Float64=0.0)\ncalc_Σ_parts(χm::χT,γm::γT, χd::χT, γd::γT, χ_m_sum::Union{Float64,ComplexF64}, λ₀::λ₀T,\n             Gνω::GνqT, kG::KGrid,mP::ModelParameters, sP::SimulationParameters;\n             λm::Float64=0.0, λd::Float64=0.0)\n\nCalculates the lDGammaA self-energy (see also calc_Σ), but split into 7 contributions from: χm, γm, χd, γd, U, Fm + Σ_hartree, tail_correction.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_λ0-Tuple{χ₀RPA_T, RPAHelper}","page":"Home","title":"LadderDGA.calc_λ0","text":"calcλ0(χ₀::χ₀RPAT, helper::RPAHelper) calcλ0(χ₀::χ₀RPAT, sP::SimulationParameters, mP::ModelParameters)\n\nThis function corresponds to the following mapping\n\nλ0: BZ × π(2N + 1)/β × 2πN/β → C, (q, ν, ω)↦ -U χ₀(q,ω)\n\nwhere ...\n    ... U is the Hubbard on-site interaction parameter\n    ... χ₀ is the RPA bubble term\n\nTODO: λ0 is constant in the fermionic matsubara frequency. This should be refactured.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_λ0-Tuple{χ₀T, lDΓAHelper}","page":"Home","title":"LadderDGA.calc_λ0","text":"calc_λ0(χ₀::χ₀T, h::lDΓAHelper)\ncalc_λ0(χ₀::χ₀T, Fr::FT, h::lDΓAHelper)\ncalc_λ0(χ₀::χ₀T, Fr::FT, χ::χT, γ::γT, mP::ModelParameters, sP::SimulationParameters)\n\nCorrection term, TODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_λmax_linEliashberg-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}","page":"Home","title":"LadderDGA.calc_λmax_linEliashberg","text":"calc_λmax_linEliashberg(bubble::χ₀T, χm::χT, χd::χT, γm::γT, γd::γT, h::lDΓAHelper, env;\n                         GF=h.gLoc, max_Nk::Int=h.kG.Ns, χm_star_gen=nothing, χd_star_gen=nothing)\n\nCalculates largest and smallest (real) eigen value of Gamma_mathrmsuparrowdownarrow.\n\nTODO: TeX/DOCU...\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_λmax_linEliashberg_MatrixFree-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}","page":"Home","title":"LadderDGA.calc_λmax_linEliashberg_MatrixFree","text":"calc_λmax_linEliashberg_MatrixFree(bubble::χ₀T, χm::χT, χd::χT, γm::γT, γd::γT, h::lDΓAHelper)\n\nThis is a slower, but memory efficient versuion of calc_λmax_linEliashberg.\n\nTODO: TeX/DOCU...\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_χγ-Tuple{Symbol, lDΓAHelper, χ₀T}","page":"Home","title":"LadderDGA.calc_χγ","text":"calc_χγ(type::Symbol, h::lDΓAHelper, χ₀::χ₀T)\ncalc_χγ(type::Symbol, Γr::ΓT, χ₀::χ₀T, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCalculates susceptibility and triangular vertex in type channel. See calc_χγ_par for parallel calculation.\n\nThis method solves the following equation: `` \\chir = \\chi0 - \\frac{1}{\\beta^2} \\chi0 \\Gammar \\chir \\\n\\Leftrightarrow (1 + \\frac{1}{\\beta^2} \\chi0 \\Gammar) = \\chi0 \\\n\\Leftrightarrow (\\chi^{-1}r - \\chi^{-1}0) = \\frac{1}{\\beta^2} \\Gamma_r ``\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_χγ-Tuple{Symbol, χ₀RPA_T, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_χγ","text":"calc_χγ(type::Symbol, χ₀::χ₀RPA_T, kG::KGrid, mP::ModelParameters)\n\nThis function corresponds to the following mappings\n\n    χ: BZ × 2πN/β → R, (q, ω)↦ χ₀(q,ω) / ( 1 + U_r⋅χ₀(q,ω) )\n    \n    γ: BZ × π(2N + 1)/β × 2πN/β → C, (q, ν, ω)↦ 1\n\n    where ...\n        ... U_r is the Hubbard on-site interaction parameter multiplied by +1 if type = d and -1 if type = m.\n        ... χ₀ is the RPA bubble term\n        ... ν is a fermionic matsubara frequency\n        ... ω is a bosonic matsubara frequency\n        ... N is the set of natural numbers\n        ... β is the inverse temperature\n        ... q is a point in reciprocal space\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}","page":"Home","title":"LadderDGA.calc_χγ_par","text":"calc_χγ_par(type::Symbol, h::lDΓAHelper)\ncalc_χγ_par(type::Symbol, Γr::ΓT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; collect_data=true)\n\nCalculate susceptibility and triangular vertex parallel on workerpool. \n\nSet collect_data to return both quantities, or call collect_χ and collect_γ at a later point. calc_χγ can be used for single core computations.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.clear_wcache!-Tuple{}","page":"Home","title":"LadderDGA.clear_wcache!","text":"clear_wcache!()\n\nClears cache on all workers. Must be used when recalculating susceptibilities after EoM initialization.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_Σ!-Tuple{OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}}","page":"Home","title":"LadderDGA.collect_Σ!","text":"collect_Σ!(Σ_ladder::OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, mP::ModelParameters; λm=0.0)\n\nCollects self-energy from workers.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_γ-Tuple{Symbol, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.collect_γ","text":"collect_γ(type::Symbol, [kG::KGrid, mP::ModelParameters, sP::SimulationParameters] OR [h::lDΓAHelper])\n\nCollects triangular vertex from workers, after parallel computation (see calc_χγ_par).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_χ-Tuple{Symbol, lDΓAHelper}","page":"Home","title":"LadderDGA.collect_χ","text":"collect_χ(type::Symbol, [kG::KGrid, mP::ModelParameters, sP::SimulationParameters] OR [h::lDΓAHelper])\n\nCollects susceptibility from workers, after parallel computation (see calc_χγ_par).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_χ₀-Tuple{lDΓAHelper}","page":"Home","title":"LadderDGA.collect_χ₀","text":"collect_χ₀(kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCollect non-local bubble chi_0^omega(q) from workers. Values first need to be calculated using calc_bubble_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.conv_tmp_add_rpa!-Union{Tuple{N}, Tuple{AbstractVector{ComplexF64}, Dispersions.KGrid, AbstractArray{ComplexF64, N}}} where N","page":"Home","title":"LadderDGA.conv_tmp_add_rpa!","text":"conv_tmp_add_rpa!(res::AbstractVector{ComplexF64}, kG::KGrid, arr1::Vector{ComplexF64}, GView::AbstractArray{ComplexF64,N})::Nothing where N\n\nExpect both input arrays already in fouriertransformed.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.core-Tuple{χ₀T}","page":"Home","title":"LadderDGA.core","text":"core(χ₀::χ₀T)\n\nSelect core region (without asymptotic shell) from bubble term.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.core_sum_bosonic-Tuple{Int64, Float64, Int64}","page":"Home","title":"LadderDGA.core_sum_bosonic","text":"core_sum_bosonic(N::Int, β::Float64, power::Int)\n\nFast evaluation of sum_n=1^N frac1(pi i (2n)  beta)^l\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.core_sum_fermionic-Tuple{Int64, Float64, Int64}","page":"Home","title":"LadderDGA.core_sum_fermionic","text":"core_sum_fermionic(N::Int, β::Float64, power::Int)\n\nFast evaluation of sum_n=0^N frac1(pi i (2n+1)  beta)^l\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.correction_term-Tuple{ModelParameters, Dispersions.KGrid, χT, Union{Float64, ComplexF64}, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.correction_term","text":"correction_term(mP::ModelParameters, kG::KGrid, χm::χT, χ_m_sum::Union{Float64,ComplexF64}, grid::AbstractArray{Int64,1})\n\nCalculates the so called tail correcion term of the ladder self energy. The purpose of this term is to enforce the limit\n\n\\lim_{n\\rightarrow\\infty}i\\nu_n\\Sigma_{\\mathbf{q}}^{\\nu_n}=U^2\\frac{n}{2}\\left(1-\\frac{n}{2} \\right ).\n\nThis can be archived by adding the term     * RPA: -\\frac{U^2}{i\\nu}\\sum_{\\omega,\\mathbf{q}}\\left( \\chi_{m,\\mathbf{q}}^{\\omega}-\\chi_{0,\\mathbf{q}}^{\\omega}\\right )     * ladder-DGA: -\\frac{U^2}{i\\nu}\\left(\\sum_{\\omega,\\mathbf{q}}\\chi_{m,\\mathbf{q}}^{\\omega}-\\chi_{m,loc} \\right ) from the ladder self energy.\n\nArguments\n\nmP         : ModelParameters\nkG         : KGrid\nχm         : χT\nχ_m_sum    : Union{Float64,ComplexF64}. RPA: \\sum_{\\omega,\\mathbf{q}}\\chi_{0,\\mathbf{q}}^{\\omega}, lDGA: 'χmsum'.\ngrid       : AbstractArray{Int64,1}\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.eom_ν_cutoff-Tuple{Int64, Bool}","page":"Home","title":"LadderDGA.eom_ν_cutoff","text":"eom_ν_cutoff(Niν::Int, grid_shifted::Bool)::Int\neom_ν_cutoff(sP::SimulationParameters)\neom_ν_cutoff(h::lDΓAHelper)\n\nReturns number of positive fermionic frequencies to be used in self-energy after calculation of EoM (as a function of available positive frequency from DMFT Niν).\n\nThis is especially necessary for shifted grids, since there fewer bosonic frequencies available for large ν, leading to an error in the high frequency tail of the self energy. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.estimate_connected_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}","page":"Home","title":"LadderDGA.estimate_connected_ef","text":"estimate_connected_ef(Σ_ladder::OffsetMatrix, kG::KGrid, μ::Float64, β::Float64; ν0_estimator::Function=lin_fit)\n\nEstimates connected fermi surface. See also estimate_ef and fermi_surface_connected. Returns fermi surface indices and relax_zero_condition (values substantially larger than 1 indicate appearance of fermi arcs).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.estimate_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}","page":"Home","title":"LadderDGA.estimate_ef","text":"estimate_ef(Σ_ladder::OffsetMatrix, kG::KGrid, μ::Float64, β::Float64; ν0_estimator::Function=lin_fit, relax_zero_condition::Float64=10.0)\n\nEstimate fermi surface of Σ_ladder, using extrapolation to nu = 0 with the function ν0_estimator and the condition lim_nu to 0 Sigma (nu k_f) = mu - epsilon_k_f.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.expand_ω-Tuple{Any}","page":"Home","title":"LadderDGA.expand_ω","text":"expand_ω(χ₀qω)\n\nHelper function for reading RPA input. It holds χ₀(q,ω)=χ₀(q,-ω). Take an array for χ₀(q,ω) with ω-integers {0, 1, ..., m} and map onto array with ω-integers {-m, -(m-1), ..., -1, 0, 1, ..., m-1, m}.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.fermi_surface_connected-Tuple{BitVector, Dispersions.KGrid}","page":"Home","title":"LadderDGA.fermi_surface_connected","text":"fermi_surface_connected(ef_ind::BitVector, kG::KGrid, D::Int)\n\nChecks for connected fermi surface of kG dimensions, given a BitVector of points on the fermi surface. Returns < 0 if fermi surface is not connected, == 0 if it is exactly a line, > 0 if the line is multiple points thick.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filling-Tuple{AbstractVector{ComplexF64}, Float64}","page":"Home","title":"LadderDGA.filling","text":"filling(G::Vector{ComplexF64}, [kG::KGrid, ] β::Float64)\nfilling(G::Vector, U::Float64, μ::Float64, β::Float64, [shell::Float64])\n\nComputes filling of (non-) local Green's function.\n\nIf U, μ and β are provided, asymptotic corrections are used. The shell sum can be precomputed using shell_sum_fermionic If G is defined only over positive Matsubara frequencies filling_pos can be used.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filling_pos-Tuple{AbstractVector{ComplexF64}, Vararg{Float64, 4}}","page":"Home","title":"LadderDGA.filling_pos","text":"filling_pos(G::Vector, U::Float64, μ::Float64, β::Float64[, shell::Float64, improved_sum::Bool=true])::Float64\nfilling_pos(G::AbstractMatrix{ComplexF64},kG::KGrid,U::Float64,μ::Float64,β::Float64; improved_sum::Bool = true)::Float64\nfilling_pos(G::AbstractMatrix{ComplexF64},kG::KGrid,)::Float64\n\nReturns filling from G only defined over positive Matsubara frequencies.  See filling for further documentation.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filter_KZ-Union{Tuple{T}, Tuple{Int64, Int64, AbstractVector{T}}} where T<:Number","page":"Home","title":"LadderDGA.filter_KZ","text":"filter_KZ(m::Int, k::Int, X::AbstractArray{T,1}) where T <: Number\n\nIterated moving average noise filter for inut data. See also filter_MA.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filter_MA-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}}} where T<:Number","page":"Home","title":"LadderDGA.filter_MA","text":"filter_MA(m::Int, X::AbstractArray{T,1}) where T <: Number\nfilter_MA!(res::AbstractArray{T,1}, m::Int, X::AbstractArray{T,1}) where T <: Number\n\nIterated moving average noise filter for inut data. See also filter_KZ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}","page":"Home","title":"LadderDGA.find_usable_χ_interval","text":"find_usable_χ_interval(χ_ω::Array{Float64,1/2}; sum_type::Union{Symbol,Tuple{Int,Int}}=:common, reduce_range_prct::Float64 = 0.1)\n\nDetermines usable range for physical susceptibilities chi^omega or chi^omega and additionally cut away reduce_range_prct % of the range. The unusable region is given whenever the susceptibility becomes negative, or the first derivative changes sign.\n\nReturns:\n\nrange::AbstractVector{Float64} : Usable omega range for chi\n\nArguments:\n\nχ_ω                : chi^omega \nsum_type           : Optional, default :common. Can be set to :full to enforce full range, or a ::Tuple{Int,Int} to enforce a specific interval size.\nreduce_range_prct  : Optional, default 0.1. After finding the usable interval it is reduced by an additional percentage given by this value.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ν_part-Tuple{AbstractArray{Int64}, SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_ν_part","text":"genνpart(νGrid::AbstractVector{Int}, sP::SimulationParameters, N::Int)\n\nReturns partition of fermionic frequencies grid, according to the number of workers N. The partition is given as a list (of length N) of lists with 4-Tuples (ωi, ωn, νi, νn).  νi and ωi are the indices for the Matsubara frequencies νn and ωn.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ν_part_slices-Tuple{Array{ComplexF64, 3}, Vector{NTuple{4, Int64}}}","page":"Home","title":"LadderDGA.gen_ν_part_slices","text":"gen_ν_part_slices(data::Array{ComplexF64,3}, index_list::Vector{NTuple{4,Int}})\n\nRearragnes data over q, ν and ω axes, for EoM (see calc_Σ_par) given index_list, which is one element of the list of lists obtained from gen_ν_part.\n\nReturns three arrays:      - datares: Rearranged data, only containes values for ν, given in `indexlist, ω values not contained indataare set to 0.     - νn_list: Has lengthsize(datares,3)`. Contained fermionic Matsubara frequency for each index.     - ωnranges: Has length size(data_res,3). Containes bosonic Matsubara frequencies for each ν value.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_νω_part-Tuple{SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_νω_part","text":"gen_νω_part(sP::SimulationParameters, N::Int)\n\nReturns partition of frequency grid, according to the number of workers N.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ω_part-Tuple{SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_ω_part","text":"gen_ω_part(sP::SimulationParameters, N::Int)\n\nReturns partition of bosonic frequencies grid, according to the number of workers N.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.initialize_EoM-Tuple{lDΓAHelper, Array{ComplexF64, 3}, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.initialize_EoM","text":"function initialize_EoM([G_fft_reverse, λ₀::Array{ComplexF64,3}, νGrid::AbstractVector{Int}, \n                    kG::KGrid, mP::ModelParameters, sP::SimulationParameters]; \n                    OR [h::lDΓAHelper, λ₀, νGrid];\n                    force_reinit = false,\n                    χm::χT = collect_χ(:sp, kG, mP, sP),\n                    γm::γT = collect_γ(:sp, kG, mP, sP),\n                    χd::χT = collect_χ(:ch, kG, mP, sP),\n                    γd::γT = collect_γ(:ch, kG, mP, sP))\n\nWorker cache initialization. Must be called before calc_Σ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.initialize_EoM_cache!-Tuple{Int64}","page":"Home","title":"LadderDGA.initialize_EoM_cache!","text":"initialize_EoM_cache!()\n\nInitializes cache to correct size. kG and sP must be set first.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.is_okay-Tuple{Any}","page":"Home","title":"LadderDGA.is_okay","text":"is_okay(χ₀qω)\n\ncheck whether the given χ₀qω Array satisfies a set of expected conditions.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.iν_array-Tuple{Real, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.iν_array","text":"iν_array(β::Real, grid::AbstractArray{Int64,1})::Vector{ComplexF64}\niν_array(β::Real, size::Int)::Vector{ComplexF64}\n\nComputes list of fermionic Matsubara frequencies. If length size is given, the grid will have indices 0:size-1. Bosonic arrays can be generated with iω_array.\n\nReturns:\n\nVector of fermionic Matsubara frequencies, given either a list of indices or a length. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.iω_array-Tuple{Real, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.iω_array","text":"iω_array(β::Real, grid::AbstractArray{Int64,1})::Vector{ComplexF64}\niω_array(β::Real, size::Int)::Vector{ComplexF64}\n\nComputes list of bosonic Matsubara frequencies. If length size is given, the grid will have indices 0:size-1. Fermionic arrays can be generated with iν_array.\n\nReturns:\n\nVector of bosonic Matsubara frequencies, given either a list of indices or a length. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.log_q0_χ_check-Tuple{Dispersions.KGrid, SimulationParameters, AbstractMatrix{Float64}, Symbol}","page":"Home","title":"LadderDGA.log_q0_χ_check","text":"log_q0_χ_check(kG::KGrid, sP::SimulationParameters, χ::AbstractArray{_eltype,2}, type::Symbol)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.par_partition-Tuple{AbstractVector, Int64}","page":"Home","title":"LadderDGA.par_partition","text":"par_partition(set::AbstractVector, N::Int)\n\nReturns list of indices for partition of set into N (almost) equally large segements.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.printr_s-Tuple{ComplexF64}","page":"Home","title":"LadderDGA.printr_s","text":"printr_s(x::ComplexF64)\nprintr_s(x::Float64)\n\nprints 4 digits of (the real part of) x\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.q0_index-Tuple{Dispersions.KGrid}","page":"Home","title":"LadderDGA.q0_index","text":"q0_index(kG::KGrid)\n\nIndex of zero k-vector.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.readConfig-Tuple{String}","page":"Home","title":"LadderDGA.readConfig","text":"readConfig(cfg_in::String)\n\nReads a config.toml file either as string or from a file and returns      - workerpool     - ModelParameters     - SimulationParameters     - EnvironmentVars     - kGrid (see Dispersions.jl)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.readConfig_RPA-Tuple{String}","page":"Home","title":"LadderDGA.readConfig_RPA","text":"readConfig_RPA(cfg_in::String)\n\nReads a config.toml file either as string or from a file and returns      - workerpool     - ModelParameter, \"../test/test_data/rpa_chi0_1.h5\")     # χ₀ = read_χ₀_RPA(inputfile)s     - SimulationParameters     - EnvironmentVars     - kGrid (see Dispersions.jl)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.readFortranχDMFT-Tuple{String}","page":"Home","title":"LadderDGA.readFortranχDMFT","text":"Returns χ_DMFT[ω, ν, ν']\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.read_χ₀_RPA-Tuple{String, Int64}","page":"Home","title":"LadderDGA.read_χ₀_RPA","text":"read_χ₀_RPA(file::String)\n\nNω :: Int, Number of positive bosonic frequencies to be used. Make sure that the given χ₀-file has at least this many bosonic frequencies!\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.reduce_range-Tuple{AbstractArray, Float64}","page":"Home","title":"LadderDGA.reduce_range","text":"reduce_range(range::AbstractArray, red_prct::Float64)\n\nReturns indices for 1D array slice, reduced by red_prct % (compared to initial range). Range is symmetrically reduced fro mstart and end.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.setupConfig_RPA-Tuple{String, Int64, Float64, Float64, Float64, Float64, Float64, Float64, Int64, Int64, Int64, Bool}","page":"Home","title":"LadderDGA.setupConfig_RPA","text":"setupConfig_RPA(KGridStr, Nk::Int)\n\nSets up RPA calculation directly. Usually one should use readConfig_RPA as entry point.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.setup_LDGA-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}","page":"Home","title":"LadderDGA.setup_LDGA","text":"setup_LDGA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [;silent=false])\n\nComputes all needed objects for DΓA calculations.\n\nReturns: lDΓAHelper\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.setup_LDGAa-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}","page":"Home","title":"LadderDGA.setup_LDGAa","text":"setup_LDGAa(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [;silent=false])\n\nComputes all needed objects for DΓA-asymptotic calculations.\n\nReturns: lDΓAaHelper\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.shell_sum_fermionic-Tuple{Int64, Float64, Int64}","page":"Home","title":"LadderDGA.shell_sum_fermionic","text":"shell_sum_fermionic(N::Int, β::Float64, power::Int)::Float64\n\nCalculate frac1beta sum_n in Omega_mathrmshell frac1(i nu_n)^power N-1 is the largest frequency index (i.e. sum_n=-N^(N-1)  u_n is in the core region)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.subtract_tail!-Tuple{AbstractVector, AbstractVector, Float64, Vector{ComplexF64}, Int64}","page":"Home","title":"LadderDGA.subtract_tail!","text":"subtract_tail!(outp::AbstractArray{T,1}, inp::AbstractArray{T,1}, c::Float64, iω::Array{ComplexF64,1}, power::Int) where T <: Number\n\nsubtract the c/(iω)^power high frequency tail from inp and store in outp. See also subtract_tail\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.subtract_tail-Tuple{AbstractVector, Float64, Vector{ComplexF64}, Int64}","page":"Home","title":"LadderDGA.subtract_tail","text":"subtract_tail(inp::AbstractArray{T,1}, c::Float64, iω::Array{ComplexF64,1}, power::Int) where T <: Number\n\nsubtract the fracc(iomega)^textpower high frequency tail from input array inp.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.sum_kω-Tuple{Dispersions.KGrid, Union{χT, χ₀RPA_T}}","page":"Home","title":"LadderDGA.sum_kω","text":"sum_kω(kG::kGrid, χ::χT; ωn_arr=ωn_grid(χ), force_full_range=false, [transform::Function])\nsum_kω(kG::kGrid, χ::χT; ωn_arr=ωn_grid(χ), force_full_range=false, [λ::Float64])\nsum_kω(kG::KGrid, χ::AbstractMatrix{Float64}, β::Float64, ωn2_tail::Vector{Float64}; transform=nothing)::Float64\n\nReturns int_mathrmBZ dk sum_omega chi^omega_k. The bosonic Matsubara grid can be precomputed and given with ωn_arr to increase performance.\n\nTODO: for now this is only implemented for tail correction in the 1  omega^2_n term! Sums first over k, then over ω (see also sum_ω), see sum_kω for the reverse order (results can differ, due to inaccuracies in the asymptotic tail treatment). The transform function needs to have the signature f(in::Float64)::Float64 and will be applied before summation. Alternatively, λ can be given directly as Float64, if the usual λ-correction should be applied.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.sum_ω-Tuple{χT}","page":"Home","title":"LadderDGA.sum_ω","text":"sum_ω(χ::χT)\nsum_ω!(res::Vector{ComplexF64}, ωn_arr::Vector{ComplexF64}, χ::χT; force_full_range=false)::Nothing\nsum_ω!(ωn_arr::Vector{T}, χ::AbstractVector{T}, tail_c::Vector{Float64}, β::Float64; force_full_range=false)::T where T <: Union{Float64,ComplexF64}\n\nSums the physical susceptibility over all usable (if `force_full_range` is not set to `true`) bosonic frequencies, including improvd tail summation, if `χ.tail_c` is set.\n\nWARNING: This function might be buggy!\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.sum_ωk-Tuple{Dispersions.KGrid, χT}","page":"Home","title":"LadderDGA.sum_ωk","text":"sum_ωk(kG::KGrid, χ::χT; force_full_range=false)::Float64\n\nWARNING: This function is a non optimized debugging function! See sum_kω, which should return the same result if the asymptotics are captured correctly. Optional function f transforms χ before summation.\n\nWARNING: This function might be buggy!\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.tail_correction_term-Tuple{Float64, Float64, Vector{ComplexF64}}","page":"Home","title":"LadderDGA.tail_correction_term","text":"tail_correction_term(χm_nl::Float64, χm_loc::Float64, tail_factor::Vector{ComplexF64})\n\ntail_correction_term(U::Float64, β::Float64, n::Float64, χm_nl::Float64, χm_loc::Float64,\n                          Σ_loc::OffsetVector{ComplexF64}, iν::Vector{ComplexF64}; \n                          δ::Real=10.0*length(iν))\n\nCalculates correction term for high frequency behavior of self energy.\n\nw_nu = e^(-Delta^2_nudelta) with Delta_nu = nu cdot Sigma^nu_mathrmDMFT - U^2 fracn2 (1 - fracn2). See also tail_factor.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.tail_factor-Tuple{Float64, Float64, Float64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA<:AbstractVector{ComplexF64}, Vector{ComplexF64}}","page":"Home","title":"LadderDGA.tail_factor","text":"tail_factor(U::Float64, β::Float64, n::Float64, Σ_loc::OffsetVector{ComplexF64}, iν::Vector{ComplexF64}; \n                          δ::Real=min(0.01, 1 ./ length(iν)))\n\nCalculates the tail factor for tail_correction_term.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_tail!-Tuple{Vector{Float64}}","page":"Home","title":"LadderDGA.update_tail!","text":"update_tail!(coeffs::Vector{Float64})\n\nUpdates the Ekin/ω^2 tail of physical susceptibilities on all workers.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_tail!-Tuple{χT, Array{Float64}, Array{ComplexF64}}","page":"Home","title":"LadderDGA.update_tail!","text":"update_tail!(χ::χT, new_tail_c::Array{Float64}, ωnGrid::Array{ComplexF64})\n\nUpdates the fracc_iomega_n^i tail for all coefficients given in new_tail_c (index 1 corresponds to i=0). #TODO: ONLY UPDATES 1/w^2 AT THE MOMENT!!!\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_wcache!-Tuple{Symbol, Any}","page":"Home","title":"LadderDGA.update_wcache!","text":"update_wcache!(name::Symbol, val; override=true)\n\nUpdates worker cache with given name and value. Typically used through remotecall() on specific worker.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.usable_ωindices-Union{Tuple{N}, Tuple{SimulationParameters, Vararg{χT, N}}} where N","page":"Home","title":"LadderDGA.usable_ωindices","text":"usable_ωindices(sP::SimulationParameters, χ_sp::χT, χ_ch::χT)\n\nHelper function, returning the indices n for omega_n ranges of multiple channels. If dbg_full_eom_omega is set to true in the config, the full range will be returned, otherwise an intersection of the usable ranges obtained from find_usable_χ_interval.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.Δ-Tuple{Vector{Float64}, Vector{Float64}, Vector{ComplexF64}}","page":"Home","title":"LadderDGA.Δ","text":"Δ(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, νₙ::Vector{ComplexF64})::Vector{ComplexF64}\n\nComputes hybridization function Delta(inu_n) = sum_k fracV_k^2nu_n - epsilon_k from Anderson parameters (for example obtained through exact diagonalization).\n\nReturns:\n\nHybridization function  over list of given fermionic Matsubara frequencies.\n\nArguments:\n\nϵₖ : list of bath levels\nVₖ : list of hopping amplitudes\nνₙ : Vector of fermionic Matsubara frequencies, see also: iν_array.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.Σ_Dyson-Tuple{Vector{ComplexF64}, Vector{ComplexF64}}","page":"Home","title":"LadderDGA.Σ_Dyson","text":"Σ_Dyson(GBath::Vector{ComplexF64}, GImp::Vector{ComplexF64})::Vector{ComplexF64}\nΣ_Dyson!(Σ::Vector{ComplexF64}, GBath::Vector{ComplexF64}, GImp::Vector{ComplexF64})::Vector{ComplexF64}\n\nCalculates Sigma = 1  G_textbath - 1  G_textimp.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.Σ_hartree-Tuple{ModelParameters}","page":"Home","title":"LadderDGA.Σ_hartree","text":"Σ_hartree(mP::ModelParameters)\n\nCalculates the hartree term of the self energy\n\n\\Sigma_{hartree}=\\frac{U\\cdot n}{2}.\n\nArguments\n\nmP : ModelParameters\n\nReturns\n\nFloat64 : Hartree term \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.λ_from_γ-Tuple{Symbol, γT, χT, Float64}","page":"Home","title":"LadderDGA.λ_from_γ","text":"λ_from_γ(type::Symbol, γ::γT, χ::χT, U::Float64)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ν0Index_of_ωIndex-Tuple{Int64, SimulationParameters}","page":"Home","title":"LadderDGA.ν0Index_of_ωIndex","text":"ν0Index_of_ωIndex(ωi::Int[, sP])::Int\n\nCalculates index of zero fermionic Matsubara frequency (which may depend on the bosonic frequency).  ωi is the index (i.e. starting with 1) of the bosonic Matsubara frequency.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νi_health-Tuple{AbstractArray{Int64}, SimulationParameters}","page":"Home","title":"LadderDGA.νi_health","text":"νi_health(νGrid::AbstractArray{Int}, sP::SimulationParameters)\n\nReturns a list of available bosonic frequencies for each fermionic frequency, given in νGrid. This can be used to estimate the maximum number of usefull frequencies for the equation of motion.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νi_νngrid_pos-Tuple{Int64, Int64, SimulationParameters}","page":"Home","title":"LadderDGA.νi_νngrid_pos","text":"νi_νngrid_pos(ωi::Int, νmax::Int, sP::SimulationParameters)\n\nIndices for positive fermionic Matsubara frequencies, depinding on ωi, the index of the bosonic Matsubara frequency.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νnGrid-Tuple{Int64, SimulationParameters}","page":"Home","title":"LadderDGA.νnGrid","text":"νnGrid(ωn::Int, sP::SimulationParameters)\n\nCalculates grid of fermionic Matsubara frequencies for given bosonic frequency ωn (including shift, if set through sP).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.χ₀Asym-Tuple{Float64, Vector{Float64}, Float64, AbstractVector{Int64}, Int64, Bool, Float64}","page":"Home","title":"LadderDGA.χ₀Asym","text":"χ₀Asym(c1::Float64, c2::Vector{Float64}, c3::Float64, ωnGrid::AbstractVector{Int}, n_iν::Int, shift::Int, β::Float64)\n\nBuilds asymtotic helper array. See calc_bubble implementation for details.\n\nc1, c2 and c3 are the coefficients for the asymtotic tail expansion and can be obtained through χ₀Asym_coeffs. n_iν is the number of positive fermionic Matsubara frequencies, shift is either 1 or 0, depending on the type of frequency grid.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.χ₀Asym_coeffs-Tuple{Symbol, Dispersions.KGrid, ModelParameters}","page":"Home","title":"LadderDGA.χ₀Asym_coeffs","text":"χ₀Asym_coeffs(type::Symbol, kG::KGrid, mP::ModelParameters; sVk=NaN)\n\nBuilds tail coefficients for the χ₀ asymptotic helper, obtained through χ₀Asym.\n\nTODO: full documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ω0_index-Tuple{SimulationParameters}","page":"Home","title":"LadderDGA.ω0_index","text":"ω0_index(sP::SimulationParameters)\nω0_index(χ::[χT or AbstractMatrix])\n\nIndex of ω₀ frequency. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ω2_tail-Tuple{χT}","page":"Home","title":"LadderDGA.ω2_tail","text":"ω2_tail(χ, h)\n\nComputes bosonic frequency tail for χ: mathrmtail(n) = frac1(2 i pi n  beta)^2. Sets mathrmtail(n) = 0.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ω_tail-Tuple{χT, χT, AbstractVector{Float64}, SimulationParameters}","page":"Home","title":"LadderDGA.ω_tail","text":"ω_tail(ωindices::AbstractVector{Int}, coeffs::AbstractVector{Float64}, sP::SimulationParameters) \nω_tail(χ_sp::χT, χ_ch::χT, coeffs::AbstractVector{Float64}, β::Float64, sP::SimulationParameters)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ωn_grid-Tuple{Union{χT, χ₀RPA_T}}","page":"Home","title":"LadderDGA.ωn_grid","text":"ωn_grid(χ::χT)\n\nComputes bosonic frequencies for χ: 2 i pi n  beta.\n\n\n\n\n\n","category":"method"},{"location":"#LambdaCorrection","page":"Home","title":"LambdaCorrection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This sub-module contains function related to the lambda-correction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LambdaCorrection]\nOrder   = [:module, :constant, :type, :function, :marco]","category":"page"},{"location":"#LadderDGA.LambdaCorrection.λ_result","page":"Home","title":"LadderDGA.LambdaCorrection.λ_result","text":"λ_result\n\nContaines result and auxilliary information of λ correction, is returned by λ_correction, should not be constructed explicitly!\n\nFields\n\nλm           : Float64, Magnetic channel correction parameter.\nλd           : Float64, Density channel correction parameter.\ntype         : CorrectionMethod, Type of λ correction: \n:m, only magnetic channel\n:dm, magnetic and density channel \n:m_sc, only magnetic channel, partial self-consistency in EoM \n:dm_sc, magnetic and density channel, partial self-consistency in EoM \n:m_tsc, only magnetic channel, partial self-consistency in EoM, updated kinetic energy term in susceptibility tail\n:dm_tsc, magnetic and density channel, partial self-consistency in EoM, updated kinetic energy term in susceptibility tail\nsc_converged : Bool, convergence parameter for self-consistency methods. Always True for non self-consist methods. See also sc_converged\neps_abs      : Float64, Threshold for convergence. Convergence is assumed when the potential energies and Pauli principle values (depending on method both or one) are equal up to this value.\nsc_eps_abs   : Float64, Threshold for sc convergence. Convergence is assumed when the potential energies and Pauli principle values (for 1- and 2-particle quantities) individually change by less than sc_eps_abs.\nEKin         : Float64, 2-Particle kinetic energy\nEPot_p1      : Float64, 1-Particle potential energy, G^mathbflambda_mathrmladder Sigma^mathbflambda_mathrmladder, see calc_E\nEPot_p2      : Float64, 2-Particle potential energy, fracU2 sum_omegaq (chi^lambda_mathrmdomega_mathrmdq - chi^lambda_mathrmmomega_mathrmmq + Ufracn^22\nPP_p1        : Float64, 1-Particle Pauli principle, fracn2 (1 - fracn2)\nPP_p2        : Float64, 2-Particle Pauli principle, frac12 sum_omegaq (chi^lambda_mathrmdomega_mathrmdq + chi^lambda_mathrmmomega_mathrmmq \ntrace        : DataFrame/Nothing, intermediate values of λ_result (Σ_ladder and G_ladder are only stored as checksums) for each self-consistency iteration.\nG_ladder     : Nothing/OffsetMatrix, Green's function after covnergence of λ-correction \nΣ_ladder     : Nothing/OffsetMatrix, self-energy after λ-correction \nμ            : Float64, chemical potential after λ-correction\nn            : Float64, electron density. This is used as check, μ should have been internally adjustet to keep this value fixed (i.e. n ≈ n_dmft)\nn_dmft       : Float64, input electron density\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.LambdaCorrection.λ_result-Tuple{Any, χT, γT, χT, γT, Array{ComplexF64, 3}, Float64, Float64, Bool, LadderDGA.RunHelper}","page":"Home","title":"LadderDGA.LambdaCorrection.λ_result","text":"λ_result(χm::χT,γm::γT,χd::χT, γd::γT, λ₀::Array{ComplexF64,3}, λm, λd, h; \n              validation_threshold::Float64 = 1e-8, max_steps_m::Int = 2000)\nλ_result(χm::χT,γm::γT,χd::χT, γd::γT, λ₀::Array{ComplexF64,3}, μ_new, G_ladder, Σ_ladder, λm, λd, h; \n              validation_threshold::Float64 = 1e-8, max_steps_m::Int = 2000)\n\nConstructs λ_result object, runs all checks and stores them.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.EPot_diff-Tuple{λ_result}","page":"Home","title":"LadderDGA.LambdaCorrection.EPot_diff","text":"EPot_diff(result::λ_result)\n\nDifference between potential energies on one- and two particle level (may be negative if EPot_p2 > EPot_p1).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.PP_diff-Tuple{λ_result}","page":"Home","title":"LadderDGA.LambdaCorrection.PP_diff","text":"PP_diff(result::λ_result)\n\nDifference between Pauli principle on one- and two particle level (may be negative if PP_p2 > PP_p1).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.bisect-NTuple{4, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.bisect","text":"bisect(λl::T, λm::T, λr::T, Fm::T)::Tuple{T,T} where T <: Union{Float64, Vector{Float64}}\n\nWARNING: Not properly tested! Bisection root finding algorithm. This is a very crude adaption of the 1D case.  The root may therefore lie outside the given region and the search space has to be corrected using correct_margins.\n\nReturns:\n\n(Vector of) new interval borders, according to Fm.\n\nArguments:\n\nλl : (Vector of) left border(s) of bisection area\nλm : (Vector of) central border(s) of bisection area\nλr : (Vector of) right border(s) of bisection area\nFm : (Vector of) Poincare-Miranda condition (s)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.calc_G_Σ-Tuple{χT, γT, χT, γT, AbstractArray{ComplexF64, 3}, Float64, Float64, LadderDGA.RunHelper}","page":"Home","title":"LadderDGA.LambdaCorrection.calc_G_Σ","text":"calc_G_Σ(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::AbstractArray{ComplexF64,3}, \n         λm::Float64, λd::Float64,\n         h::RunHelper, sP::SimulationParameters, mP::ModelParameters; \n         tc::Bool = true, fix_n::Bool = true\n\n)\n\nReturns μ_new, G_ladder, Σ_ladder with λ correction according to function parameters.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.converged-Union{Tuple{λ_result{T}}, Tuple{T}} where T","page":"Home","title":"LadderDGA.LambdaCorrection.converged","text":"converged(r::λ_result, eps_abs::Float64=1e-6)\n\nChecks convergences for appropriate parameters of method.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.correct_margins-NTuple{4, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.correct_margins","text":"correct_margins(λl::T, λm::T, λr::T, Fm::T, Fr::T)::Tuple{T,T} where T <: Union{Float64, Vector{Float64}}\n\nHelper method for bisect.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.dχ_λ-Tuple{Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.dχ_λ","text":"dχ_λ(χ::[Float64,ComplexF64,AbstractArray], λ::Float64)\n\nFirst derivative of χ_λ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.gen_νω_indices-Tuple{χT, χT, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.LambdaCorrection.gen_νω_indices","text":"gen_νω_indices(χ_m::χT, χ_d::χT, sP::SimulationParameters)\n\nInternal helper to generate usable bosonic and fermionic ranges. Also returns the c_1x^2 tail. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.get_λ_min-Tuple{AbstractMatrix{Float64}}","page":"Home","title":"LadderDGA.LambdaCorrection.get_λ_min","text":"get_λ_min(χr::AbstractArray{Float64,2})::Float64\n\nComputes the smallest possible lambda-correction parameter (i.e. first divergence of chi(q)), given as lambda_textmin = - min_q(1  chi^omega_0_q).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.linear_approx-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T1, T2, T2, T2}} where {T1, T2}","page":"Home","title":"LadderDGA.LambdaCorrection.linear_approx","text":"linear_approx(f1::T2, f2::T2, x1::T1, x2::T1, xm::T1) where {T1, T2}\n\nLinear approximation of function sampled at f1 = f(x1) and f2 = f(x2) at point xm, x1 <= xm <= x2.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.n_diff-Tuple{λ_result}","page":"Home","title":"LadderDGA.LambdaCorrection.n_diff","text":"n_diff(result::λ_result)\n\nDifference between density before and after λ-correction (this should always be close to 0!) \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.newton-Tuple{Function, Function, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.newton","text":"newton(f::Function, df::Function, xi::Float64; nsteps::Int = 500, atol::Float64 = 1e-10)::Float64\n\nNormal Newton method, used for example by newton_transformed and newton_secular.\n\nxi is the initial guess, for functions with multiple roots, the result will depend on this guess.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.newton_right-Tuple{Function, Function, Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.newton_right","text":"newton_right(f::Function, [df::Function,] start::[Float64,Vector{Float64},MVector{Float64}], min::[Float64,Vector{Float64},MVector{Float64}]; nsteps=5000, atol=1e-11)\n\nComputes root of function f but under the condition that each compontent of the root is larger than the corresponding component of the start vector. This algorithm also assumes, that f is stricly monotonically decreasing in each component. nsteps sets the maximum number of newton-steps, atol sets the convergence tolerance. df can be omitted. In this case it is approximated using finite differences.\n\nThis is a legacy method. For better convergence performance and reliability please consider using newton_secular.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.newton_secular-Tuple{Function, Function, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.newton_secular","text":"newton_secularEq(f::Function, [df::Function,], pole::Float64)\n\nComputes largest root of function f, assuming it corresponds to a secular equaiton f(x) = 1 + sum_j fracb_jd_j - x. Adapted from Example 2,  https://doi.org/10.48550/arXiv.2204.02326 Given the largest pole x_p we transform the input according to w(x_i) = frac1x + x_p and then  procede with the modified Newton algorithm (using the chain rule): x_(n+1) = x_(n) + f(w(x_i)) cdot  (f(w(x_i)))^-1 (w(x_i))^-1\n\nFor debugging purposes, there are also newton_secular_trace and trace_f available.\n\nArguments:\n\nf      : function, with structure as given above.\ndf     : derivative function, will be constructed by finite differences, if not provided.\nxp     : largest pole, it is guaranteed, that there is exactly one root larger than this, which will be returned by the algorithm. \nnsteps : maximum number of steps\natol   : convergence criterion, i.e. f(x_0)  atol will return root x0.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.newton_secular_trace-Tuple{Function, Function, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.newton_secular_trace","text":"newton_secular_trace(f::Function, df::Function, xp::Float64; nsteps::Int = 500, atol::Float64 = 1e-10)::Float64\n\nThis is the same as newton_secular, but also returns a trace of the intermediate values (xi,xi_tf,fi,dfii).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.reset!-Tuple{χT}","page":"Home","title":"LadderDGA.LambdaCorrection.reset!","text":"reset!(χ::χT)\n\nResets the λ-correction of the χ struct.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.sample_f-Union{Tuple{T}, Tuple{Function, T, T}} where T","page":"Home","title":"LadderDGA.LambdaCorrection.sample_f","text":"sample_f(f::Function, xmin::T, xmax::T; feps_abs::Float64=1e-8, xeps_abs::Float64=1e-8, maxit::Int=1000) where T\n\nSample a function f mathbbR to mathbbR over the interval xmin xmax by repeatedly bisecting intervals, that cannot be approximated linearly. \n\nx values will be sampled with a distance of at least ϵ. delta is the bisection criterion. i.e. if f(x_i) L_f(x_i)   feps_abs for a proposed bisection point, the interval is supposed to be converged. Algorithm will stop bisection after maxit samples\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.sc_converged-Tuple{λ_result}","page":"Home","title":"LadderDGA.LambdaCorrection.sc_converged","text":"sc_converged(r::λ_result)\n\nChecks for self-consistency convergence. Returns true if method does not invlove a self-consistency loop.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.validate-Tuple{λ_result}","page":"Home","title":"LadderDGA.LambdaCorrection.validate","text":"validation(r::λ_result)\n\nReturns Tuple with check for (density, Pauli-principle, potential energy), both checked between one- and two-particle level against λ_result.eps_abs.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.validate_EPot-Tuple{Float64, χT, χT, Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.validate_EPot","text":"validate_EPot(χm::χT, χd::χT, λm::Float64, n::Float64)\n\nReturns .\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.validate_PP-Tuple{χT, χT, Float64, Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.validate_PP","text":"validate_PP(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64)\n\nReturns .\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.validate_sums-Tuple{Dispersions.KGrid, χT, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.validate_sums","text":"validate_sums(kG::KGrid, χr::χT[, λr::Float64])\n\nReturns sum_k sum_omega chi^lambda_romega_rq - sum_omega sum_k chi^lambda_romega_rq.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λ_correction-Tuple{Symbol, χT, γT, χT, γT, Any, lDΓAHelper}","page":"Home","title":"LadderDGA.LambdaCorrection.λ_correction","text":"λ_correction(type::Symbol, χm::χT, γm::γT, χd::χT, γd::γT, λ₀, h::lDΓAHelper; \n             λm_rhs_type::Symbol=:native, fit_μ::Bool=true, \n             νmax::Int=eom_ν_cutoff(h), λ_min_δ::Float64 = 0.0001,\n             maxit::Int=100, mixing::Float64=0.2, conv_abs::Float64=1e-8, trace::Bool=false,\n             λ_val_only::Bool=false, verbose::Bool=false, validation_threshold::Float64=1e-8, tc::Bool=true)\n\nExecutes λ-correction.  TODO: finish docu\n\nArguments\n\ntype : Symbol, options are :m, :dm, :m_sc, :dm_sc, :m_tsc and :dm_tsc\nχm   :\nγm   :\nχd   :\nγd   :\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}","page":"Home","title":"LadderDGA.LambdaCorrection.λdm_correction","text":"λdm_correction(χm::χT,γm::γT,χd::χT, γd::γT,λ₀::Array{ComplexF64,3}, h;\n                    validation_threshold::Float64 = 1e-8, max_steps_m::Int = 2000, max_steps_dm::Int = 2000, log_io = devnull\n)\n\nComputes the λm and λd parameters for the consistency of Pauli principle and potential energie on one- and two-particle level. Returns a λ_result object.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λdm_correction_val-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}","page":"Home","title":"LadderDGA.LambdaCorrection.λdm_correction_val","text":"λdm_correction_val(χm::χT,γm::γT,χd::χT, γd::γT,λ₀::Array{ComplexF64,3}, h;\n                    validation_threshold::Float64 = 1e-8, max_steps_m::Int = 2000, max_steps_dm::Int = 2000, log_io = devnull\n)\n\nComputes the λm and λd parameters for the consistency of Pauli principle and potential energie on one- and two-particle level. Returns the bare λ-values, usually one should run λdm_correction, which returns a λ_result object  that stores additional consistency checks.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λdm_sc_correction_clean-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}","page":"Home","title":"LadderDGA.LambdaCorrection.λdm_sc_correction_clean","text":"λdm_sc_correction(χm::χT,γm::γT,χd::χT, γd::γT,λ₀::λ₀T, h;\n                       validation_threshold::Float64 = 1e-8,\n                       max_steps_m::Int = 2000, max_steps_dm::Int = 2000, max_steps_sc::Int = 2000,\n                       log_io = devnull, tc = true)\n\nRuns partial self-consistency loop (update of propagators in equation of motion) within λdm correction\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λdm_tsc_correction_clean-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}","page":"Home","title":"LadderDGA.LambdaCorrection.λdm_tsc_correction_clean","text":"λdm_tsc_correction(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::Array{ComplexF64,3}, h, sP, mP;\n                    validation_threshold::Float64 = 1e-8, log_io = devnull\n)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}","page":"Home","title":"LadderDGA.LambdaCorrection.λm_correction","text":"λm_correction(χm::χT,γm::γT,χd::χT,γd::γT,λ₀::Array{ComplexF64,3},h::lDΓAHelper;\n                   νmax::Int = eom_ν_cutoff(h), fit_μ::Bool = true, tc = true, \n                   validation_threshold::Float64 = 1e-8, log_io = devnull\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λm_correction_val-Tuple{χT, Float64, Any}","page":"Home","title":"LadderDGA.LambdaCorrection.λm_correction_val","text":"λm_correction_val(χm::χT, rhs::Float64, h::lDΓAHelper)\nλm_correction_val(χm::χT, rhs::Float64, kG::KGrid, ωn2_tail)\n\nUsed internally for performance reasons (because the lambda_mathrmd correction needs this calculation repeatedly), see λm_correction for the user-sided version. Calculates lambda_mathrmm value, by fixing sum_qomega chi^lambdaomega_uparrowuparrow(qiomega) = fracn2(1-fracn2). This is only calculates the value and validation numbers and does not return a full λ_result object. \n\nTODO: finish docu\n\nArguments\n\nχm        :\nrhs       :\nh         :\nωn2_tail :\nverbose   :\nωn2_tail :\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λm_rhs-Tuple{χT, χT, LadderDGA.RunHelper}","page":"Home","title":"LadderDGA.LambdaCorrection.λm_rhs","text":"λm_rhs(χm::χT, χd::χT, h::RunHelper; λd::Float64=NaN, λ_rhs = :native, verbose=false)\nλm_rhs(imp_density::Float64, χm::χT, χd::χT, λd::Float64, kG::KGrid, mP::ModelParameters, sP::SimulationParameters, λ_rhs = :native)\n\nHelper function for the right hand side of the Pauli principle conditions (λm correction). imp_density can be set to NaN, if the rhs (fracn2(1-fracn2)) should not be error-corrected (not ncessary or usefull when asymptotic improvement are active). TODO: write down formula, explain imp_density as compensation to DMFT.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λm_sc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}","page":"Home","title":"LadderDGA.LambdaCorrection.λm_sc_correction","text":"λm_sc_correction(χm::χT,γm::γT,χd::χT, γd::γT,λ₀::λ₀T, h;\n                       validation_threshold::Float64 = 1e-8,\n                       max_steps_m::Int = 2000, max_steps_dm::Int = 2000, max_steps_sc::Int = 2000,\n                       log_io = devnull, tc = true)\n\nRuns partial self-consistency loop (update of propagators in equation of motion) within λdm correction\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λm_tsc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}","page":"Home","title":"LadderDGA.LambdaCorrection.λm_tsc_correction","text":"λm_tsc_correction(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::Array{ComplexF64,3}, h, sP, mP;\n                    validation_threshold::Float64 = 1e-8, log_io = devnull\n)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.χ_λ!-Tuple{χT, χT, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.χ_λ!","text":"χ_λ!(χ_destination::[AbstractArray,χT], [χ::[AbstractArray,χT], ] λ::Float64)\n\nInplace version of χ_λ. If the second argument is omitted, results are stored in the input χ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.χ_λ-Tuple{Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.χ_λ","text":"χ_λ(χ::[Float64,ComplexF64,AbstractArray,χT], λ::Float64)\n\nComputes the λ-corrected susceptibility:  chi^lambdaomega_q = frac11  chi^lambdaomega_q + lambda. The susceptibility chi can be either given element wise, or as χT See also χT in LadderDGA.jl.\n\n\n\n\n\n","category":"method"}]
}
