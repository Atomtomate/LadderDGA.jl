var documenterSearchIndex = {"docs":
[{"location":"deps/","page":"Dependencies","title":"Dependencies","text":"There are two functionalities which have been factored out to separate projects: Handeling of frequency sums and operations involving k-grids.","category":"page"},{"location":"deps/#Frequency-Summations","page":"Dependencies","title":"Frequency Summations","text":"","category":"section"},{"location":"deps/","page":"Dependencies","title":"Dependencies","text":"The summation over Matsubara frequencies is defined over a set on infinitely many frequencies. A canonical approach to approximate this sum,","category":"page"},{"location":"deps/#K-Grids","page":"Dependencies","title":"K-Grids","text":"","category":"section"},{"location":"#LadderDGA.jl-Documentation","page":"Home","title":"LadderDGA.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LadderDGA","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#List-of-Functions","page":"Home","title":"List of Functions","text":"","category":"section"},{"location":"#LadderDGA","page":"Home","title":"LadderDGA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [LadderDGA]\nOrder   = [:module, :constant, :type, :function, :marco]","category":"page"},{"location":"#LadderDGA.EnvironmentVars","page":"Home","title":"LadderDGA.EnvironmentVars","text":"EnvironmentVars <: ConfigStruct\n\nContains various settings, controlling the I/O behaviour of this module. This is typically generated from a config.toml file using the readConfig function.\n\nFields\n\ninputDir        : String, Directory of input files\ninputVars       : String, File name of .jld2 file containing input.\nloglevel        : String, Options: disabled, error, warn, info, debug\nlogfile         : String,    Options: STDOUT, STDERR, filename\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.ModelParameters","page":"Home","title":"LadderDGA.ModelParameters","text":"ModelParameters <: ConfigStruct\n\nContains model parameters for the Hubbard model. This is typically generated from a config.toml file using  the readConfig function.\n\nFields\n\nU         : Float64, Hubbard U\nμ         : Float64, chemical potential\nβ         : Float64, inverse temperature\nn         : Float64, filling\nsVk       : Float64, ∑_k Vₖ^2\nEpot_DMFT : Float64, DMFT potential energy\nEkin_DMFT : Float64, DMFT kinetic intergy\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.SimulationParameters","page":"Home","title":"LadderDGA.SimulationParameters","text":"SimulationParameters <: ConfigStruct\n\nContains simulation parameters for the ladder DGA computations. This is typically generated from a config.toml file using the readConfig function.\n\nFields\n\nn_iω                    : Int, Number of positive bosonic frequencies (full number will be 2*n_iω+1 \nn_iν                    : Int, Number of positive fermionic frequencies (full number will be 2*n_iν \nn_iν_shell              : Int, Number of fermionic frequencies used for asymptotic sum improvement (χ_asym_r arrays with at least these many entries need to be provided)\nshift                   : Bool, Flag specifying if -n_iν:n_iν-1 is shifted by -ωₙ/2 at each ωₙ slice (centering the main features)\nχ_helper                : struct, helper struct for asymptotic sum improvements involving the generalized susceptibility (nothing if n_iν_shell == 0), see also BSE_SC.jl.\nfft_range               : Int, Frequencies used for computations of type f(νₙ + ωₙ). \nusable_prct_reduction   : Float64, percent reduction of usable bosonic frequencies\ndbg_full_eom_omega      : Bool, if true overrides usable ω ranges to n_iω.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.γT","page":"Home","title":"LadderDGA.γT","text":"γT <: MatsubaraFunction\n\nStruct for the non-local triangular vertex. \n\nFields\n\ndata         : Array{ComplexF64,3}, data\naxes         : Dict{Symbol,Int}, Dictionary mapping :q, :ν, :ω to the axis indices.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.χT","page":"Home","title":"LadderDGA.χT","text":"χT <: MatsubaraFunction\n\nStruct for the non-local susceptibilities. \n\nConstructor\n\nχT(data::Array{T, 2}; full_range=true, reduce_range_prct=0.1): if full_range is set to false, the usable range  is determined via find_usable_χ_interval.\n\nFields\n\ndata         : Array{ComplexF64,3}, data\naxes         : Dict{Symbol,Int}, Dictionary mapping :q, :ω to the axis indices.\nλ            : Float64, λ correction parameter.\nusable_ω     : AbstractArray{Int}, usable indices for which data is assumed to be correct. See also find_usable_interval\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.χ₀T","page":"Home","title":"LadderDGA.χ₀T","text":"χ₀T <: MatsubaraFunction\n\nStruct for the bubble term. The q, ω dependent asymptotic behavior is computed from the  t1 and t2 input.\n\nConstructor\n\nχ₀T(data::Array{_eltype,3}, kG::KGrid, ω_grid::AbstractVector{Int}, n_iν::Int, shift::Bool, mP::ModelParameters; local_tail=false)\n\nSet local_tail=true in case of the local bubble constructed fro mthe impurity Green's function. This is necessary in order to construct the correct asymptotics.\n\nFields\n\ndata         : Array{ComplexF64,3}, data\nasym         : Array{ComplexF64,2}, [q, ω] dependent asymptotic behavior.\naxes         : Dict{Symbol,Int}, Dictionary mapping :q, :ν, :ω to the axis indices.\n\n\n\n\n\n","category":"type"},{"location":"#Base.show-Tuple{IO, ModelParameters}","page":"Home","title":"Base.show","text":"Base.show(io::IO, m::ModelParameters)\n\nCustom output for ModelParameters\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, SimulationParameters}","page":"Home","title":"Base.show","text":"Base.show(io::IO, m::SimulationParameters)\n\nCustom output for SimulationParameters\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.EPot1-Tuple{Dispersions.KGrid, AbstractMatrix{ComplexF64}, Matrix{ComplexF64}, Matrix{ComplexF64}, Vector{Float64}, Float64}","page":"Home","title":"LadderDGA.EPot1","text":"Specialized function for DGA potential energy. Better performance than calc_E.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.F_from_χ-Tuple{AbstractArray{ComplexF64, 3}, AbstractVector{ComplexF64}, SimulationParameters, Float64}","page":"Home","title":"LadderDGA.F_from_χ","text":"F_from_χ(χ::AbstractArray{ComplexF64,3}, G::AbstractArray{ComplexF64,1}, sP::SimulationParameters, β::Float64[; diag_term=true])\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_fft-Tuple{OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.G_fft","text":"G_fft(G::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCalculates fast Fourier transformed lattice Green's functions used for calc_bubble.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_from_Σ-Tuple{Int64, Float64, Float64, Float64, ComplexF64}","page":"Home","title":"LadderDGA.G_from_Σ","text":"G_from_Σ(ind::Int64, β::Float64, μ::Float64, ϵₖ::Float64, Σ::ComplexF64)\nG_from_Σ(mf::ComplexF64, μ::Float64, ϵₖ::Float64, Σ::ComplexF64)\n\nComputes Green's function according to frac(2 n + 1)pi ibeta + mu - epsilon_k - Sigma(kinu_n)^-1, where epsilon_k and Sigma(kinu_n) are given as single values. Convenience wrappers for full grids are provided below.\n\nArguments:\n\nind : Matsubara frequency index\nmf  : Matsubara frequency\nβ   : Inverse temperature (only needs to be set, if index instead of frequency is given)\nμ   : Chemical potential\nϵₖ  : Dispersion relation at fixed k, see below for convenience wrappers.\nΣ   : Self energy at fixed frequency (and potentially fixed k), see below for convenience wrappers.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_from_Σ-Tuple{Vector{ComplexF64}, Vector{Float64}, AbstractVector{Int64}, ModelParameters}","page":"Home","title":"LadderDGA.G_from_Σ","text":"G_from_Σ(Σ::AbstractVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::AbstractVector{Int}, mP::ModelParameters; μ = mP.μ,  Σloc::AbstractArray = nothing) \nG_from_Σ!(res::Matrix{ComplexF64}, Σ::AbstractVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::AbstractVector{Int}, mP::ModelParameters; μ = mP.μ,  Σloc::AbstractVector = nothing)\n\nComputes Green's function from self energy Σ and dispersion ϵkGrid over given frequency indices range. Optionally, a different chemical potential μ can be provided. When the non-local self energy is used, one typically wants to extend the usefull range of frequencies by attaching the tail of the local self energy in the high frequency regime. This is done by providing a range larger than the array size of Σ and in addition setting Σloc (the size of Σloc must be as large or larger than range).  The inplace version stores the result in res.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.G_shell_sum-Tuple{Int64, Float64}","page":"Home","title":"LadderDGA.G_shell_sum","text":"G_shell_sum(N::Int, β::Float64)::Float64\n\nCalculate frac1beta sum_n in Omega_mathrmshell frac1(i nu_n)^2 N should be the index of the largest frequency + 1, NOT the total lenth of the array, i.e. 50 for indices = 0:49.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, SimulationParameters}","page":"Home","title":"LadderDGA.OneToIndex_to_Freq","text":"OneToIndex_to_Freq(ωi::Int, νi::Int, sP::SimulationParameters)\n\nConverts (1:N,1:N) index tuple for bosonic (ωi) and fermionic (νi) frequency to Matsubara frequency number. If the array has a ν shell (for example for tail improvements) this will also be taken into account by providing Nν_shell.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA._update_tail!-Tuple{Vector{Float64}}","page":"Home","title":"LadderDGA._update_tail!","text":"_update_tail!(coeffs::Vector{Float64})\n\nUpdates the Ekin/ω^2 tail of physical susceptibilities on worker. Used by update_tail!.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.bse_inv-Tuple{Symbol, Array{ComplexF64, 3}}","page":"Home","title":"LadderDGA.bse_inv","text":"bse_inv(type::Symbol, Γr::Array{ComplexF64,3})\n\nKernel for calculation of susceptibility and triangular vertex. Used by calc_χγ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_E_ED-Tuple{String}","page":"Home","title":"LadderDGA.calc_E_ED","text":"calc_E_ED(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, GImp::Vector{ComplexF64}, U, n, μ, β)\ncalc_E_ED(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, GImp::Vector{ComplexF64}, mP::ModelParameters)\ncalc_E_ED(fname::String)\n\nComputes kinetic and potential energies from Anderson parameters.\n\nReturns:\n\n(EKin, EPot): Tuple{Float64,Float64}, kinetic and potential energy.\n\nArguments:\n\nfname : jld2-file containing the fields: [gImp, β, ϵₖ, Vₖ, U, nden, μ] (see below)\nϵₖ    : bath levels\nVₖ    : hoppend amplitudes\nGImp  : impurity Green's function. WARNING: the arguments are assumed to by fermionic Matsuabra indices 0:length(GImp)-1!\nU     : Coulomb interaction strength\nn     : number density\nμ     : chemical potential\nβ     : inverse temperature\nmP    : Alternative call with model parameters as Float64. See also ModelParameters.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_bubble-Tuple{OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_bubble","text":"calc_bubble(Gνω::GνqT, Gνω_r::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; local_tail=false)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_bubble_par-Tuple{Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_bubble_par","text":"calc_bubble_par(kG::KGrid, mP::ModelParameters, sP::SimulationParameters; collect_data=true)\n\nCalculates the bubble, based on two fourier-transformed Greens functions where the second one has to be reversed.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ_eom_par-Tuple{Float64, Float64}","page":"Home","title":"LadderDGA.calc_Σ_eom_par","text":"calc_Σ_eom_par(νmax::Int)\n\nEquation of motion for self energy. See calc_Σ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_Σ_par-Tuple{Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_Σ_par","text":"calc_Σ_par(mP::ModelParameters, sP::SimulationParameters; νmax=sP.n_iν; collect_data=true)\n\nCalculates self-energy on worker pool. Workers must first be initialized using initialize_EoM. #TODO: νrange must be equal to the one used during initialization. remove one.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_λ0-Tuple{χ₀T, Array{ComplexF64, 3}, χT, γT, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_λ0","text":"calc_λ0(χ₀::χ₀T, Fr::FT, χ::χT, γ::γT, mP::ModelParameters, sP::SimulationParameters)\n\nCorrection term, TODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_χγ-Tuple{Symbol, Array{ComplexF64, 3}, χ₀T, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_χγ","text":"calc_χγ(type::Symbol, Γr::ΓT, χ₀::χ₀T, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCalculates susceptibility and triangular vertex in type channel. See calc_χγ_par for parallel calculation.\n\nThis method solves the following equation: `` \\chir = \\chi0 - \\frac{1}{\\beta^2} \\chi0 \\Gammar \\chir \\\n\\Leftrightarrow (1 + \\frac{1}{\\beta^2} \\chi0 \\Gammar) = \\chi0 \\\n\\Leftrightarrow (\\chi^{-1}r - \\chi^{-1}0) = \\frac{1}{\\beta^2} \\Gamma_r ``\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_χγ_par-Tuple{Symbol, Array{ComplexF64, 3}, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.calc_χγ_par","text":"calc_χγ_par(type::Symbol, Γr::ΓT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; collect_data=true)\n\nCalculate susceptibility and triangular vertex parallel on workerpool. \n\nSet collect_data to return both quantities, or call collect_χγ at a later point. calc_χγ can be used for single core computations.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_Σ-Tuple{Int64, AbstractVector{Int64}, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.collect_Σ","text":"collect_Σ(Nk::Int, νrange::AbstractVector{Int}, mP::ModelParameters, sP::SimulationParameters)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_χ-Tuple{Symbol, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.collect_χ","text":"collect_χ(type::Symbol, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\ncollect_γ(type::Symbol, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCollects susceptibility and triangular vertex from workers, after parallel computation (see calc_χγ_par).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.collect_χ₀-Tuple{Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.collect_χ₀","text":"collect_χ₀(kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCollect non-local bubble chi_0^omega(q) from workers. Values first need to be calculated using calc_bubble_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filling-Tuple{Vector{ComplexF64}, Float64}","page":"Home","title":"LadderDGA.filling","text":"filling(G::Vector{ComplexF64}, [kG::KGrid, ] β::Float64)\nfilling(G::Vector, U::Float64, μ::Float64, β::Float64, [shell::Float64])\n\nComputes filling of (non-) local Green's function.\n\nIf U, μ and β are provided, asymptotic corrections are used. The shell sum can be precomputed using G_shell_sum If G is defined only over positive Matsubara frequencies filling_pos can be used.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filling_pos-Tuple{Vector{ComplexF64}, Float64, Float64, Float64, Float64}","page":"Home","title":"LadderDGA.filling_pos","text":"filling_pos(G::Vector, U::Float64, μ::Float64, β::Float64[, shell::Float64])::Float64\n\nReturns filling from G only defined over positive Matsubara frequencies.  See filling for further documentation.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filter_KZ-Union{Tuple{T}, Tuple{Int64, Int64, AbstractVector{T}}} where T<:Number","page":"Home","title":"LadderDGA.filter_KZ","text":"filter_KZ(m::Int, k::Int, X::AbstractArray{T,1}) where T <: Number\n\nIterated moving average noise filter for inut data. See also filter_MA.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.filter_MA-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}}} where T<:Number","page":"Home","title":"LadderDGA.filter_MA","text":"filter_MA(m::Int, X::AbstractArray{T,1}) where T <: Number\nfilter_MA!(res::AbstractArray{T,1}, m::Int, X::AbstractArray{T,1}) where T <: Number\n\nIterated moving average noise filter for inut data. See also filter_KZ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}","page":"Home","title":"LadderDGA.find_usable_χ_interval","text":"find_usable_χ_interval(χ_ω::Array{Float64,1/2}; sum_type::Union{Symbol,Tuple{Int,Int}}=:common, reduce_range_prct::Float64 = 0.1)\n\nDetermines usable range for physical susceptibilities chi^omega or chi^omega and additionally cut away reduce_range_prct % of the range. The unusable region is given whenever the susceptibility becomes negative, or the first derivative changes sign.\n\nReturns:\n\nrange::AbstractVector{Float64} : Usable omega range for chi\n\nArguments:\n\nχ_ω                : chi^omega \nsum_type           : Optional, default :common. Can be set to :full to enforce full range, or a ::Tuple{Int,Int} to enforce a specific interval size.\nreduce_range_prct  : Optional, default 0.1. After finding the usable interval it is reduced by an additional percentage given by this value.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ν_part-Tuple{AbstractArray{Int64}, SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_ν_part","text":"genνpart(νGrid::AbstractVector{Int}, sP::SimulationParameters, N::Int)\n\nReturns partition of fermionic frequencies grid, according to the number of workers N. The partition is given as a list (of length N) of lists with 4-Tuples (ωi, ωn, νi, νn).  νi and ωi are the indices for the Matsubara frequencies νn and ωn.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ν_part_slices-Tuple{Array{ComplexF64, 3}, Vector{NTuple{4, Int64}}}","page":"Home","title":"LadderDGA.gen_ν_part_slices","text":"gen_ν_part_slices(data::Array{ComplexF64,3}, index_list::Vector{NTuple{4,Int}})\n\nRearragnes data over q, ν and ω axes, for EoM (see calc_Σ_par) given index_list, which is one element of the list of lists obtained from gen_ν_part.\n\nReturns three arrays:      - datares: Rearranged data, only containes values for ν, given in `indexlist, ω values not contained indataare set to 0.     - νn_list: Has lengthsize(datares,3)`. Contained fermionic Matsubara frequency for each index.     - ωnranges: Has length size(data_res,3). Containes bosonic Matsubara frequencies for each ν value.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_νω_part-Tuple{SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_νω_part","text":"gen_νω_part(sP::SimulationParameters, N::Int)\n\nReturns partition of frequency grid, according to the number of workers N.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_ω_part-Tuple{SimulationParameters, Int64}","page":"Home","title":"LadderDGA.gen_ω_part","text":"gen_ω_part(sP::SimulationParameters, N::Int)\n\nReturns partition of bosonic frequencies grid, according to the number of workers N.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.initialize_EoM-Tuple{Any, Array{ComplexF64, 3}, AbstractVector{Int64}, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.initialize_EoM","text":"function initializeEoM(Gfftreverse, λ₀::Array{ComplexF64,3}, νGrid::AbstractVector{Int},                          kG::KGrid, mP::ModelParameters, sP::SimulationParameters;                          forcereinit = false,                         χsp::χT = collectχ(:sp, kG, mP, sP),                         γsp::γT = collectγ(:sp, kG, mP, sP),                         χch::χT = collectχ(:ch, kG, mP, sP),                         γch::γT = collectγ(:ch, kG, mP, sP))\n\nWorker cache initialization. Must be called before calc_Σ_par.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.initialize_EoM_cache!-Tuple{Int64}","page":"Home","title":"LadderDGA.initialize_EoM_cache!","text":"initialize_EoM_cache!()\n\nInitializes cache to correct size. kG and sP must be set first.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.iν_array-Tuple{Real, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.iν_array","text":"iν_array(β::Real, grid::AbstractArray{Int64,1})::Vector{ComplexF64}\niν_array(β::Real, size::Int)::Vector{ComplexF64}\n\nComputes list of fermionic Matsubara frequencies. If length size is given, the grid will have indices 0:size-1. Bosonic arrays can be generated with iω_array.\n\nReturns:\n\nVector of fermionic Matsubara frequencies, given either a list of indices or a length. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.iω_array-Tuple{Real, AbstractVector{Int64}}","page":"Home","title":"LadderDGA.iω_array","text":"iω_array(β::Real, grid::AbstractArray{Int64,1})::Vector{ComplexF64}\niω_array(β::Real, size::Int)::Vector{ComplexF64}\n\nComputes list of bosonic Matsubara frequencies. If length size is given, the grid will have indices 0:size-1. Fermionic arrays can be generated with iν_array.\n\nReturns:\n\nVector of bosonic Matsubara frequencies, given either a list of indices or a length. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.log_q0_χ_check-Tuple{Dispersions.KGrid, SimulationParameters, AbstractMatrix{ComplexF64}, Symbol}","page":"Home","title":"LadderDGA.log_q0_χ_check","text":"log_q0_χ_check(kG::KGrid, sP::SimulationParameters, χ::AbstractArray{_eltype,2}, type::Symbol)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.par_partition-Tuple{AbstractVector, Int64}","page":"Home","title":"LadderDGA.par_partition","text":"par_partition(set::AbstractVector, N::Int)\n\nReturns list of indices for partition of set into N (almost) equally large segements.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.printr_s-Tuple{ComplexF64}","page":"Home","title":"LadderDGA.printr_s","text":"printr_s(x::ComplexF64)\nprintr_s(x::Float64)\n\nprints 4 digits of (the real part of) x\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.q0_index-Tuple{Dispersions.KGrid}","page":"Home","title":"LadderDGA.q0_index","text":"q0_index(kG::KGrid)\n\nIndex of zero k-vector.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.readConfig-Tuple{String}","page":"Home","title":"LadderDGA.readConfig","text":"readConfig(cfg_in::String)\n\nReads a config.toml file either as string or from a file and returns      - workerpool     - ModelParameters     - SimulationParameters     - EnvironmentVars     - kGrid (see Dispersions.jl)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.readFortranχDMFT-Tuple{String}","page":"Home","title":"LadderDGA.readFortranχDMFT","text":"Returns χ_DMFT[ω, ν, ν']\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.reduce_range-Tuple{AbstractArray, Float64}","page":"Home","title":"LadderDGA.reduce_range","text":"reduce_range(range::AbstractArray, red_prct::Float64)\n\nReturns indices for 1D array slice, reduced by red_prct % (compared to initial range). Range is symmetrically reduced fro mstart and end.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.setup_LDGA-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}","page":"Home","title":"LadderDGA.setup_LDGA","text":"setup_LDGA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [; local_correction=true])\n\nComputes all needed objects for DΓA calculations.\n\nReturns:\n\nNTuple{16, Any}[     ΣladderLoc,      Σloc,      impdensity,      kGrid,     gLocfft,     gLocrfft,      Γsp,     Γch,      χDMFTsp,     χDMFTch,     χsploc,     γsploc,     χchloc,     γch_loc,     χ₀Loc,     gImp ]\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.subtract_tail!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, Float64, Vector{ComplexF64}, Int64}} where T<:Number","page":"Home","title":"LadderDGA.subtract_tail!","text":"subtract_tail!(outp::AbstractArray{T,1}, inp::AbstractArray{T,1}, c::Float64, iω::Array{ComplexF64,1}, power::Int) where T <: Number\n\nsubtract the c/(iω)^power high frequency tail from inp and store in outp. See also subtract_tail\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.subtract_tail-Union{Tuple{T}, Tuple{AbstractVector{T}, Float64, Vector{ComplexF64}, Int64}} where T<:Number","page":"Home","title":"LadderDGA.subtract_tail","text":"subtract_tail(inp::AbstractArray{T,1}, c::Float64, iω::Array{ComplexF64,1}, power::Int) where T <: Number\n\nsubtract the fracc(iomega)^textpower high frequency tail from input array inp.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_tail!-Tuple{Vector{Float64}}","page":"Home","title":"LadderDGA.update_tail!","text":"update_tail!(coeffs::Vector{Float64})\n\nUpdates the Ekin/ω^2 tail of physical susceptibilities on all workers.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_tail!-Tuple{χT, Array{Float64}, Array{ComplexF64}}","page":"Home","title":"LadderDGA.update_tail!","text":"update_tail!(χ::χT, new_tail_c::Array{Float64}, ωnGrid::Array{ComplexF64})\n\nUpdates the fracc_iomega_n^i tail for all coefficients given in new_tail_c (index 1 corresponds to i=0).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.update_wcache!-Tuple{Symbol, Any}","page":"Home","title":"LadderDGA.update_wcache!","text":"update_wcache!(name::Symbol, val; override=true)\n\nUpdates worker cache with given name and value. Typically used through remotecall() on specific worker.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.usable_ωindices-Union{Tuple{N}, Tuple{SimulationParameters, Vararg{χT, N}}} where N","page":"Home","title":"LadderDGA.usable_ωindices","text":"usable_ωindices(sP::SimulationParameters, χ_sp::χT, χ_ch::χT)\n\nHelper function, returning the indices n for omega_n ranges of multiple channels. If dbg_full_eom_omega is set to true in the config, the full range will be returned, otherwise an intersection of the usable ranges obtained from find_usable_χ_interval.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.Δ-Tuple{Vector{Float64}, Vector{Float64}, Vector{ComplexF64}}","page":"Home","title":"LadderDGA.Δ","text":"Δ(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, νₙ::Vector{ComplexF64})::Vector{ComplexF64}\n\nComputes hybridization function Delta(inu_n) = sum_k fracV_k^2nu_n - epsilon_k from Anderson parameters (for example obtained through exact diagonalization).\n\nReturns:\n\nHybridization function  over list of given fermionic Matsubara frequencies.\n\nArguments:\n\nϵₖ : list of bath levels\nVₖ : list of hopping amplitudes\nνₙ : Vector of fermionic Matsubara frequencies, see also: iν_array.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.Σ_Dyson-Tuple{Vector{ComplexF64}, Vector{ComplexF64}}","page":"Home","title":"LadderDGA.Σ_Dyson","text":"Σ_Dyson(GBath::Vector{ComplexF64}, GImp::Vector{ComplexF64})::Vector{ComplexF64}\nΣ_Dyson!(Σ::Vector{ComplexF64}, GBath::Vector{ComplexF64}, GImp::Vector{ComplexF64})::Vector{ComplexF64}\n\nCalculates Sigma = 1  G_textbath - 1  G_textimp.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.λ_from_γ-Tuple{Symbol, γT, χT, Float64}","page":"Home","title":"LadderDGA.λ_from_γ","text":"λ_from_γ(type::Symbol, γ::γT, χ::χT, U::Float64)\n\nTODO: documentation\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ν0Index_of_ωIndex-Tuple{Int64, SimulationParameters}","page":"Home","title":"LadderDGA.ν0Index_of_ωIndex","text":"ν0Index_of_ωIndex(ωi::Int[, sP])::Int\n\nCalculates index of zero fermionic Matsubara frequency (which may depend on the bosonic frequency).  ωi is the index (i.e. starting with 1) of the bosonic Matsubara frequency.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νi_health-Tuple{AbstractArray{Int64}, SimulationParameters}","page":"Home","title":"LadderDGA.νi_health","text":"νi_health(νGrid::AbstractArray{Int}, sP::SimulationParameters)\n\nReturns a list of available bosonic frequencies for each fermionic frequency, given in νGrid. This can be used to estimate the maximum number of usefull frequencies for the equation of motion.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νi_νngrid_pos-Tuple{Int64, Int64, SimulationParameters}","page":"Home","title":"LadderDGA.νi_νngrid_pos","text":"νi_νngrid_pos(ωi::Int, νmax::Int, sP::SimulationParameters)\n\nIndices for positive fermionic Matsubara frequencies, depinding on ωi, the index of the bosonic Matsubara frequency.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.νnGrid-Tuple{Int64, SimulationParameters}","page":"Home","title":"LadderDGA.νnGrid","text":"νnGrid(ωn::Int, sP::SimulationParameters)\n\nCalculates grid of fermionic Matsubara frequencies for given bosonic frequency ωn (including shift, if set through sP).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.χ₀Asym-Tuple{Float64, Vector{Float64}, Float64, AbstractVector{Int64}, Int64, Bool, Float64}","page":"Home","title":"LadderDGA.χ₀Asym","text":"χ₀Asym(c1::Float64, c2::Vector{Float64}, c3::Float64, ω_grid::AbstractVector{Int}, n_iν::Int, shift::Int, β::Float64)\n\nBuilds asymtotic helper array. See calc_bubble implementation for details.\n\nc1, c2 and c3 are the coefficients for the asymtotic tail expansion and can be obtained through χ₀Asym_coeffs. n_iν is the number of positive fermionic Matsubara frequencies, shift is either 1 or 0, depending on the type of freqiency grid.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.χ₀Asym_coeffs-Tuple{Dispersions.KGrid, Bool, ModelParameters}","page":"Home","title":"LadderDGA.χ₀Asym_coeffs","text":"χ₀Asym_coeffs(kG::KGrid, local_tail::Bool, mP::ModelParameters)\n\nBuilds tail coefficients for the χ₀ asymptotic helper, obtained through χ₀Asym.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ω0_index-Tuple{SimulationParameters}","page":"Home","title":"LadderDGA.ω0_index","text":"ω0_index(sP::SimulationParameters)\nω0_index(χ::[χT or AbstractMatrix])\n\nIndex of ω₀ frequency. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.ω_tail-Tuple{χT, χT, AbstractVector{Float64}, SimulationParameters}","page":"Home","title":"LadderDGA.ω_tail","text":"ω_tail(ωindices::AbstractVector{Int}, coeffs::AbstractVector{Float64}, sP::SimulationParameters) \nω_tail(χ_sp::χT, χ_ch::χT, coeffs::AbstractVector{Float64}, sP::SimulationParameters)\n\n\n\n\n\n","category":"method"},{"location":"#LambdaCorrection","page":"Home","title":"LambdaCorrection","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This sub-module contains function related to the lambda-correction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LambdaCorrection]\nOrder   = [:module, :constant, :type, :function, :marco]","category":"page"},{"location":"#LadderDGA.LambdaCorrection.bisect-NTuple{4, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.bisect","text":"bisect(λl::T, λm::T, λr::T, Fm::T)::Tuple{T,T} where T <: Union{Float64, Vector{Float64}}\n\nWARNING: Not properly tested! Bisection root finding algorithm. This is a very crude adaption of the 1D case.  The root may therefore lie outside the given region and the search space has to be corrected using correct_margins.\n\nReturns:\n\n(Vector of) new interval borders, according to Fm.\n\nArguments:\n\nλl : (Vector of) left border(s) of bisection area\nλm : (Vector of) central border(s) of bisection area\nλr : (Vector of) right border(s) of bisection area\nFm : (Vector of) Poincare-Miranda condition (s)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.correct_margins-NTuple{4, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.correct_margins","text":"correct_margins(λl::T, λm::T, λr::T, Fm::T, Fr::T)::Tuple{T,T} where T <: Union{Float64, Vector{Float64}}\n\nHelper method for bisect.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.dχ_λ-Union{Tuple{T}, Tuple{T, Float64}} where T<:Union{Float64, ComplexF64}","page":"Home","title":"LadderDGA.LambdaCorrection.dχ_λ","text":"dχ_λ(χ::[Float64,ComplexF64,AbstractArray], λ::Float64)\n\nFirst derivative of χ_λ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.find_lin_interp_root-Tuple{AbstractVector{Float64}, AbstractVector{Float64}}","page":"Home","title":"LadderDGA.LambdaCorrection.find_lin_interp_root","text":"find_lin_interp_root(xdata::AbstractVector{Float64}, ydata::AbstractVector{Float64})\n\nWARNING: this is a specialized function which assumes strictly monotonic data! Given sampled xdata and ydata, find the root using linear interpolation. Returns estimated x₀.\n\nReturns:\n\nx₀ : Float64, root of sampled function data.\n\nArguments:\n\nxdata : x-data of samples from strictly monotonic decreasing function.\nydata : y-data of samples from strictly monotonic decreasing function\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.find_lin_interp_root-Tuple{Matrix{Float64}}","page":"Home","title":"LadderDGA.LambdaCorrection.find_lin_interp_root","text":"find_lin_interp_root(c2_data::Array{Float64,2})\n\nDetermines root (i.e. (lambda_textsp lambda_textch)) from residual curve computed via residuals. The root is determined via linear interpolation from the given data.\n\nReturns:\n\n(lambda_textsp lambda_textch textcheck), roots for lambda values and a check (Boolean). Check is false, if the lambda values could not be determined (NaN )\n\nArguments:\n\nc2_data : Matrix{Float64}, data from residuals.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.gen_νω_indices-Tuple{χT, χT, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.LambdaCorrection.gen_νω_indices","text":"gen_νω_indices(χsp::χT, χch::χT, sP::SimulationParameters)\n\nInternal helper to generate usable bosonic and fermionic ranges. Also returns the c_1x^2 tail. \n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.get_λ_min-Tuple{AbstractMatrix{Float64}}","page":"Home","title":"LadderDGA.LambdaCorrection.get_λ_min","text":"get_λ_min(χr::AbstractArray{Float64,2})::Float64\n\nComputes the smallest possible lambda-correction parameter (i.e. first divergence of chi(q)), given as lambda_textmin = - min_q(1  chi^omega_0_q).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.lhs_int-Tuple{Matrix, Matrix, Float64, Float64, Vector{ComplexF64}, Vector{Float64}, Int64, Float64, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.lhs_int","text":"lhs_int(χsp::Matrix, χch::Matrix, χ_tail::Vector{ComplexF64}, kMult::Vector{Float64}, k_norm::Int, Ekin::Float64, β::Float64)\n\nInternal function. This calculates the sum over up-up and up-down susceptibilities, used in cond_both_int, avoiding allocations.\n\nReturns:\n\nTuple{ComplexF64/Float64}[     lhsc1, # ``\\sum{q,\\omega} \\chi{\\uparrow,\\downarrow}``     lhsc2  # sum_qomega chi_uparrowuparrow ]\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.newton_right-Tuple{Function, Function, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.newton_right","text":"newton_right(f::Function, df::Function, start::[Float64,Vector{Float64}; nsteps=5000, atol=1e-11)\n\nWARNING: Not properly tested! This is an adaption of the traditional Newton root finding algorithm, searching  only to the right of start.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.residuals-Tuple{Int64, χT, γT, χT, γT, Vector{ComplexF64}, OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, Array{ComplexF64, 3}, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.LambdaCorrection.residuals","text":"residuals(N_subdivisions::Int, \n        χ_m::χT, γ_m::γT, χ_d::χT, γ_d::γT, Σ_loc::Vector{ComplexF64},\n        Gνω::GνqT, λ₀::Array{ComplexF64,3},\n        kG::KGrid, mP::ModelParameters, sP::SimulationParameters; \n        method = :lingrid, \n        νmax::Int = -1, λd_min_δ = 0.1, λd_max = 500,\n        maxit::Int = 50, update_χ_tail=false, mixing=0.2, conv_abs=1e-6, par=false)\n\nArguments:\n\nmethod: Options are :bisection, :lingrid. The first two try and esstimate the position of the 0, while lingrid yields a linear grid of residuals.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.run_sc-Tuple{χT, γT, χT, γT, AbstractArray{ComplexF64, 3}, OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, Vector{ComplexF64}, Float64, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.LambdaCorrection.run_sc","text":"TODO: refactor (especially _par version)\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λ_seach_range-Tuple{Matrix{Float64}}","page":"Home","title":"LadderDGA.LambdaCorrection.λ_seach_range","text":"λ_seach_range(χ::Matrix{Float64}; λ_max_default = 50)\n\nCalculates reasonable interval for the search of the lambda-correction parameter. \n\nThe interval is chosen with lambda_textmin, such that all unphysical poles are excluded and lambda_textmax = lambda_textdefault  max_qomega chi(qomega). The λ_max_default parameter may need to be adjusted, depending on the model, since in principal arbitrarily large maximum values are possible.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Vector{ComplexF64}, OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, Array{ComplexF64, 3}, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.LambdaCorrection.λdm_correction","text":"λdm_correction(χ_m, γ_m, χ_d, γ_d, Σ_loc, gLoc_rfft, λ₀, kG, mP, sP; \n    maxit_root = 100, atol_root = 1e-8, λd_min_δ = 0.1, λd_max = 500,\n    maxit::Int = 50, update_χ_tail=false, mixing=0.2, conv_abs=1e-6, par=false)\n\nCalculates lambda_mathrmdm and associated quantities like the self-energy.\n\nTODO: full documentation. Pack results into struct\n\nReturns:\n\nΣ_ladder : ladder self-energy\nG_ladder : ladder Green's function obtained from `Σ_ladder`\nE_kin    : kinetic energy, unless `update_χ_tail = true`, this will be not consistent with the susceptibility tail coefficients.\nE_pot    : one-particle potential energy, obtained through galitskii-migdal formula\nμnew:    : chemical potential of `G_ladder`\nλm       : λ-correction for the magnetic channel\nlhs_c1   : check-sum for the Pauli-principle value obtained from the susceptibilities (`λm` fixes this to ``n/2 \\cdot (1-n/2)``) \nE_pot_2  : Potential energy obtained from susceptibilities. `λd` fixes this to `E_pot`\nconverged: error flag. False if no `λd` was found. \nλd       : λ-correction for the density channel.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λm_correction-Tuple{χT, Float64, Dispersions.KGrid, ModelParameters, SimulationParameters}","page":"Home","title":"LadderDGA.LambdaCorrection.λm_correction","text":"λm_correction(χsp::χT, rhs::Float64, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)\n\nCalculates lambda_mathrmm value, by fixing sum_qomega chi^lambda_mathrmm_uparrowdownarrow(qiomega) = fracn2(1-fracn2).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.λsp_rhs","page":"Home","title":"LadderDGA.LambdaCorrection.λsp_rhs","text":"λsp_rhs([imp_density::Float64, ]χsp::χT, χch::χT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters, λ_rhs = :native)\n\nHelper function for the right hand side of the Pauli principle conditions (old λ correction). TODO: write down formula, explain imp_density as compensation to DMFT.\n\n\n\n\n\n","category":"function"},{"location":"#LadderDGA.LambdaCorrection.χ_λ!-Tuple{χT, χT, Float64}","page":"Home","title":"LadderDGA.LambdaCorrection.χ_λ!","text":"χ_λ!(χ_destination::[AbstractArray,χT], [χ::[AbstractArray,χT], ] λ::Float64)\n\nInplace version of χ_λ. If the second argument is omitted, results are stored in the input χ.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.LambdaCorrection.χ_λ-Union{Tuple{T}, Tuple{T, Float64}} where T<:Union{Float64, ComplexF64}","page":"Home","title":"LadderDGA.LambdaCorrection.χ_λ","text":"χ_λ(χ::[Float64,ComplexF64,AbstractArray,χT], λ::Float64)\n\nComputes the λ-corrected susceptibility:  chi^lambdaomega_q = frac11  chi^lambdaomega_q + lambda. The susceptibility chi can be either given element wise, or as χT See also χT in LadderDGA.jl.\n\n\n\n\n\n","category":"method"}]
}
