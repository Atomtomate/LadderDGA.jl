var documenterSearchIndex = {"docs":
[{"location":"#LadderDGA.jl","page":"Home","title":"LadderDGA.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LadderDGA","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LadderDGA]","category":"page"},{"location":"#LadderDGA.EnvironmentVars","page":"Home","title":"LadderDGA.EnvironmentVars","text":"EnvironmentVars <: ConfigStruct\n\nContains various settings, controlling the I/O behaviour  of this module. This is typically generated from a config.toml file using  the readConfig function.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.ImpurityQuantities","page":"Home","title":"LadderDGA.ImpurityQuantities","text":"ImpurityQuantities\n\nContains all quantities of a given channel, computed by DMFT\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.ModelParameters","page":"Home","title":"LadderDGA.ModelParameters","text":"ModelParameters <: ConfigStruct\n\nContains model parameters for the Hubbard model. This is typically generated from a config.toml file using  the readConfig function.\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.NonLocalQuantities","page":"Home","title":"LadderDGA.NonLocalQuantities","text":"NonLocalQuantities\n\nContains all non local quantities computed by the lDGA code\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.SimulationParameters","page":"Home","title":"LadderDGA.SimulationParameters","text":"SimulationParameters <: ConfigStruct\n\nContains simulation parameters for the ladder DGA computations. This is typically generated from a config.toml file using  the readConfig function.\n\nFields\n\nTODO: describe implications of all fields\n\n\n\n\n\n","category":"type"},{"location":"#LadderDGA.G-Tuple{Int64, Vector{ComplexF64}, Union{Base.Generator, Vector{Float64}}, Float64, Float64}","page":"Home","title":"LadderDGA.G","text":"G(ind::Int64, Σ::Array{Complex{Float64},1}, ϵkGrid, β::Float64, μ)\n\nConstructs GF from k-independent self energy, using the Dyson equation and the dispersion relation of the lattice.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.build_fνmax_fast-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T<:Number","page":"Home","title":"LadderDGA.build_fνmax_fast","text":"build_fνmax_fast(f::AbstractArray{T,1}, nmin::Int)::Array{T, 1} where T <: Number\nbuild_fνmax_fast(f::AbstractArray{T,2}, nmin::Int)::Array{T, 1} where T <: Number\n\nDescription\n\nConstructs array of partial sums of one or two-dimensional array f starting at with rmin summands. This assumes, that the array is symmetric around the mid index.\n\nExamples\n\njulia> LadderDGA.build_fνmax_fast([3,2,1,2,3],2)\n[5, 11]\njulia> arr = [3 3 3 3 3; 3 2 2 2 3; 3 2 1 2 3; 3 2 2 2 3; 3 3 3 3 3\njulia> LadderDGA.build_fνmax_fast(arr,2)\n[17, 65]\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_E_pot-NTuple{6, Any}","page":"Home","title":"LadderDGA.calc_E_pot","text":"Specialized function for DGA potential energy. Better performance than calc_E.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.calc_χ_trilex-Union{Tuple{T}, Tuple{SharedArrays.SharedArray{ComplexF64, 3}, SharedArrays.SharedArray{ComplexF64, 3}, Vector{Float64}, Any, T, Float64, ModelParameters, SimulationParameters}} where T<:SeriesAcceleration.SumHelper","page":"Home","title":"LadderDGA.calc_χ_trilex","text":"Solve χ = χ₀ - 1/β² χ₀ Γ χ     ⇔ (1 + 1/β² χ₀ Γ) χ = χ₀     ⇔      (χ⁻¹ - χ₀⁻¹) = 1/β² Γ     with indices: χ[ω, q] = χ₀[]\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.expand_kGrid-Tuple{Any, Array}","page":"Home","title":"LadderDGA.expand_kGrid","text":"expand_kGrid(reducedInd, reducedArr)\n\nExpands arbitrary Array on reduced k-Grid back to full grid. This includes restoration of mirror symmetry if the index array  reducedInd indicates uncomplete grid (by having no (1,1,1) index). #Examples\n\n    mapslices(x->expand_kGrid(qIndices, x, simParams.Nk),sdata(bubble), dims=[2])\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.extend_Σ-Tuple{Any, Any, Any}","page":"Home","title":"LadderDGA.extend_Σ","text":"extend_Σ(Σ_ladder, Σ_loc, range)\n\nBuilds new  self energy with Σ_loc tail, extending the frequency range of Σ_ladder. If range contains negative frequencies, the results are obtaind from get_symm_f(Σ, i).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.extend_γ-Tuple{Any, Any}","page":"Home","title":"LadderDGA.extend_γ","text":"extend_γ(arr, usable_ν)\n\nNot tested yet!\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.find_usable_interval-Tuple{Vector{Float64}}","page":"Home","title":"LadderDGA.find_usable_interval","text":"find_usable_interval(arr::Array{Float64,1}; sum_type::Union{Symbol,Tuple{Int,Int}}=:common, reduce_range_prct::Float64 = 0.0)\n\nFinds a usable interval of indices for chi (omega_i), i.e. an interval where known physical properties hold.\n\nDescription\n\nReturns range of indices i where the following conditions hold:\n\narr[i] is positive\narr[i] is decreasing (for i-i_0, i_0 index of 0 frequency).\n\nArguments\n\narr      : array, containing chi (omega_i)\nsum_type : Optional. :full will always return eachindex(), any Tuple{Int,Int}                   will be itnerpreted as fixed limits and the range will be fixed to these.\nreduce_range_prct : Optional. Will reduce the range by given percentage (usefull to                  reduce effect of bad tails).\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.find_usable_γ-Tuple{Any}","page":"Home","title":"LadderDGA.find_usable_γ","text":"find_usable_γ(arr)\n\nNot tested yet!\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.gen_kGrid-Tuple{Int64, Int64}","page":"Home","title":"LadderDGA.gen_kGrid","text":"gen_kGrid(Nk, D[; min = 0, max = π, include_min=true]) =\n\nGenerates an Iterator for the Cartesian product of k vectors.  This can be collected to reduce into a Nk times Nk array, containing tuples of length D.\n\nExamples\n\njulia> gen_kGrid(2, 2; min = 0, max = 2π, include_min = false)\nBase.Iterators.ProductIterator{Tuple{Array{Float64,1},Array{Float64,1}}}(([3.141592653589793, 6.283185307179586], [3.141592653589793, 6.283185307179586]))\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.get_sum_helper-Tuple{Any, SimulationParameters}","page":"Home","title":"LadderDGA.get_sum_helper","text":"get_sum_helper(range, sP::SimulationParameters)\n\nDescription\n\nConstruct helper for (improved) sums from setting in sP over a given fit range range.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.padlength-Tuple{Any, Any}","page":"Home","title":"LadderDGA.padlength","text":"padlength(a,b)\n\ncomputes the length of zero-padding required for convolution, using fft This is the next larger or equally large number to max(a,b) TODO: does only support padding for cube like arrays (i.e. all dimension have the same size).\n\nExamples\n\njulia> padlength(1:5,1:14)\n8\njulia> padlength(1:4,1:13)\n4\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.printr_s-Tuple{ComplexF64}","page":"Home","title":"LadderDGA.printr_s","text":"print 4 digits of the real part of `x`\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.readFortranχDMFT-Tuple{String}","page":"Home","title":"LadderDGA.readFortranχDMFT","text":"Returns χ_DMFT[ω, ν, ν']\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.reduce_kGrid-Tuple{Any}","page":"Home","title":"LadderDGA.reduce_kGrid","text":"reduce_kGrid(kGrid)\n\nFilters the grid, so that only the lower triangle remains, i.e. for any (x1, x2, ...) the condition x1 >= x2 >= x_3 ...  is fulfilled.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.squareLattice_ekGrid-Tuple{Any}","page":"Home","title":"LadderDGA.squareLattice_ekGrid","text":"squareLattice_ek_grid(kgrid)\n\nComputes 0.5 [cos(kx) + ... + cos(kD)] and returns a grid with Nk points.\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.sum_freq-Union{Tuple{T2}, Tuple{T1}, Tuple{AbstractArray{T1, N} where N, Vector{Int64}, T2, Float64}} where {T1<:Number, T2<:SeriesAcceleration.SumHelper}","page":"Home","title":"LadderDGA.sum_freq","text":"sum_freq(f, dims::AbstractArray{Int,1}, type::T, β::Float64; \n              corr::Float64=0.0) where T <: SumHelper\n\nDescription\n\nWrapper for estimation of initite Matsubara sums from a finite set of samples. Computes frac1beta^D sum_n f(iomega_n). For convenience, a correction term (being the analytic sum over a previously subtracted tail) can also be provided throught the corr argument.\n\nArguments\n\nf    : array containing function of Matsubara frequencies\ndims : dimensions over which to sum\ntype : SumHelper object, used for estimation of limit\nβ    : Inverse Temperature for normalization\ncorr : When tail coefficients are know, the subtraction and               subsequent addition of the analytic infinite sum over              the tail can be added back here.\n\nExamples\n\njulia> arr = ones(3,5,5)\njulia> sum_freq(arr, [2,3], Naive(), 1.0)\n3×1×1 Array{Float64, 3}:\n    [:, :, 1] =\n     25.0\n     25.0\n     25.0\n\n\n\n\n\n","category":"method"},{"location":"#LadderDGA.sum_q-Tuple{Any, Any}","page":"Home","title":"LadderDGA.sum_q","text":"sum_q(arr, qMult)\n\nComputes normalized sum over all q-Points.\n\n\n\n\n\n","category":"method"}]
}
