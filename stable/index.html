<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LadderDGA</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://Atomtomate.github.io/LadderDGA.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>LadderDGA</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li><li class="toplevel"><a class="tocitem" href="#List-of-Functions"><span>List of Functions</span></a></li><li><a class="tocitem" href="#LadderDGA"><span>LadderDGA</span></a></li><li><a class="tocitem" href="#LambdaCorrection"><span>LambdaCorrection</span></a></li></ul></li><li><a class="tocitem" href="deps/">Dependencies</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Atomtomate/LadderDGA.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="LadderDGA.jl-Documentation"><a class="docs-heading-anchor" href="#LadderDGA.jl-Documentation">LadderDGA.jl Documentation</a><a id="LadderDGA.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#LadderDGA.jl-Documentation" title="Permalink"></a></h1><ul><li class="no-marker"><ul><li><a href="deps/#Frequency-Summations">Frequency Summations</a></li><li><a href="deps/#K-Grids">K-Grids</a></li></ul></li><li><a href="#LadderDGA.jl-Documentation">LadderDGA.jl Documentation</a></li><li><a href="#Index">Index</a></li><li><a href="#List-of-Functions">List of Functions</a></li><li class="no-marker"><ul><li><a href="#LadderDGA">LadderDGA</a></li><li><a href="#LambdaCorrection">LambdaCorrection</a></li></ul></li></ul><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#LadderDGA.EnvironmentVars"><code>LadderDGA.EnvironmentVars</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λ_result-Tuple{Any, χT, γT, χT, γT, Array{ComplexF64, 3}, Float64, Float64, Bool, LadderDGA.RunHelper}"><code>LadderDGA.LambdaCorrection.λ_result</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λ_result"><code>LadderDGA.LambdaCorrection.λ_result</code></a></li><li><a href="#LadderDGA.ModelParameters"><code>LadderDGA.ModelParameters</code></a></li><li><a href="#LadderDGA.RPAHelper"><code>LadderDGA.RPAHelper</code></a></li><li><a href="#LadderDGA.SimulationParameters"><code>LadderDGA.SimulationParameters</code></a></li><li><a href="#LadderDGA.lDΓAHelper"><code>LadderDGA.lDΓAHelper</code></a></li><li><a href="#LadderDGA.γT"><code>LadderDGA.γT</code></a></li><li><a href="#LadderDGA.χT"><code>LadderDGA.χT</code></a></li><li><a href="#LadderDGA.χ₀RPA_T"><code>LadderDGA.χ₀RPA_T</code></a></li><li><a href="#LadderDGA.χ₀T"><code>LadderDGA.χ₀T</code></a></li><li><a href="#Base.show-Tuple{IO, SimulationParameters}"><code>Base.show</code></a></li><li><a href="#Base.show-Tuple{IO, ModelParameters}"><code>Base.show</code></a></li><li><a href="#LadderDGA.EPot1-Tuple{Dispersions.KGrid, AbstractMatrix{ComplexF64}, Matrix{ComplexF64}, Matrix{ComplexF64}, Vector{Float64}, Float64}"><code>LadderDGA.EPot1</code></a></li><li><a href="#LadderDGA.EPot_p1-Tuple{χT, χT, Vararg{Float64, 4}}"><code>LadderDGA.EPot_p1</code></a></li><li><a href="#LadderDGA.EPot_p2-Tuple{χT, χT, Float64, Float64, Float64, Float64, Dispersions.KGrid}"><code>LadderDGA.EPot_p2</code></a></li><li><a href="#LadderDGA.F_from_χ-Tuple{Symbol, lDΓAHelper}"><code>LadderDGA.F_from_χ</code></a></li><li><a href="#LadderDGA.F_from_χ_gen-Tuple{χ₀T, Array{ComplexF64, 4}}"><code>LadderDGA.F_from_χ_gen</code></a></li><li><a href="#LadderDGA.F_from_χ_star_gen-Tuple{χ₀T, Array{ComplexF64, 4}, χT, γT, Float64}"><code>LadderDGA.F_from_χ_star_gen</code></a></li><li><a href="#LadderDGA.G_fft-Tuple{OffsetArrays.OffsetArray, Dispersions.KGrid, SimulationParameters}"><code>LadderDGA.G_fft</code></a></li><li><a href="#LadderDGA.G_from_Σ-Tuple{Int64, Float64, Float64, Float64, ComplexF64}"><code>LadderDGA.G_from_Σ</code></a></li><li><a href="#LadderDGA.G_from_Σ-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Vector{Float64}, UnitRange{Int64}, ModelParameters}"><code>LadderDGA.G_from_Σ</code></a></li><li><a href="#LadderDGA.G_from_Σladder-Tuple{AbstractMatrix{ComplexF64}, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Dispersions.KGrid, ModelParameters, SimulationParameters}"><code>LadderDGA.G_from_Σladder</code></a></li><li><a href="#LadderDGA.G_rfft!-Tuple{OffsetArrays.OffsetArray, OffsetArrays.OffsetArray, Dispersions.KGrid, UnitRange}"><code>LadderDGA.G_rfft!</code></a></li><li><a href="#LadderDGA.LambdaCorrection.EPot_diff-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.EPot_diff</code></a></li><li><a href="#LadderDGA.LambdaCorrection.PP_diff-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.PP_diff</code></a></li><li><a href="#LadderDGA.LambdaCorrection.bisect-NTuple{4, Float64}"><code>LadderDGA.LambdaCorrection.bisect</code></a></li><li><a href="#LadderDGA.LambdaCorrection.calc_G_Σ-Tuple{χT, γT, χT, γT, AbstractArray{ComplexF64, 3}, Float64, Float64, LadderDGA.RunHelper}"><code>LadderDGA.LambdaCorrection.calc_G_Σ</code></a></li><li><a href="#LadderDGA.LambdaCorrection.converged-Union{Tuple{λ_result{T}}, Tuple{T}} where T"><code>LadderDGA.LambdaCorrection.converged</code></a></li><li><a href="#LadderDGA.LambdaCorrection.correct_margins-NTuple{4, Float64}"><code>LadderDGA.LambdaCorrection.correct_margins</code></a></li><li><a href="#LadderDGA.LambdaCorrection.dχ_λ-Tuple{Float64, Float64}"><code>LadderDGA.LambdaCorrection.dχ_λ</code></a></li><li><a href="#LadderDGA.LambdaCorrection.gen_νω_indices-Tuple{χT, χT, ModelParameters, SimulationParameters}"><code>LadderDGA.LambdaCorrection.gen_νω_indices</code></a></li><li><a href="#LadderDGA.LambdaCorrection.get_λ_min-Tuple{AbstractMatrix{Float64}}"><code>LadderDGA.LambdaCorrection.get_λ_min</code></a></li><li><a href="#LadderDGA.LambdaCorrection.linear_approx-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T1, T2, T2, T2}} where {T1, T2}"><code>LadderDGA.LambdaCorrection.linear_approx</code></a></li><li><a href="#LadderDGA.LambdaCorrection.n_diff-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.n_diff</code></a></li><li><a href="#LadderDGA.LambdaCorrection.newton-Tuple{Function, Function, Float64}"><code>LadderDGA.LambdaCorrection.newton</code></a></li><li><a href="#LadderDGA.LambdaCorrection.newton_right-Tuple{Function, Function, Float64, Float64}"><code>LadderDGA.LambdaCorrection.newton_right</code></a></li><li><a href="#LadderDGA.LambdaCorrection.newton_secular-Tuple{Function, Function, Float64}"><code>LadderDGA.LambdaCorrection.newton_secular</code></a></li><li><a href="#LadderDGA.LambdaCorrection.newton_secular_trace-Tuple{Function, Function, Float64}"><code>LadderDGA.LambdaCorrection.newton_secular_trace</code></a></li><li><a href="#LadderDGA.LambdaCorrection.reset!-Tuple{χT}"><code>LadderDGA.LambdaCorrection.reset!</code></a></li><li><a href="#LadderDGA.LambdaCorrection.sample_f-Union{Tuple{T}, Tuple{Function, T, T}} where T"><code>LadderDGA.LambdaCorrection.sample_f</code></a></li><li><a href="#LadderDGA.LambdaCorrection.sc_converged-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.sc_converged</code></a></li><li><a href="#LadderDGA.LambdaCorrection.validate-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.validate</code></a></li><li><a href="#LadderDGA.LambdaCorrection.validate_EPot-Tuple{Float64, χT, χT, Float64, Float64}"><code>LadderDGA.LambdaCorrection.validate_EPot</code></a></li><li><a href="#LadderDGA.LambdaCorrection.validate_PP-Tuple{χT, χT, Float64, Float64, Float64}"><code>LadderDGA.LambdaCorrection.validate_PP</code></a></li><li><a href="#LadderDGA.LambdaCorrection.validate_sums-Tuple{Dispersions.KGrid, χT, Float64}"><code>LadderDGA.LambdaCorrection.validate_sums</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λ_correction-Tuple{Symbol, χT, γT, χT, γT, Any, lDΓAHelper}"><code>LadderDGA.LambdaCorrection.λ_correction</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λdm_correction</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λdm_correction_val-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λdm_correction_val</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λdm_sc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λdm_sc_correction</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λdm_tsc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λdm_tsc_correction</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λm_correction</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λm_correction_val-Tuple{χT, Float64, Any}"><code>LadderDGA.LambdaCorrection.λm_correction_val</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λm_rhs-Tuple{χT, χT, LadderDGA.RunHelper}"><code>LadderDGA.LambdaCorrection.λm_rhs</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λm_sc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λm_sc_correction</code></a></li><li><a href="#LadderDGA.LambdaCorrection.λm_tsc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λm_tsc_correction</code></a></li><li><a href="#LadderDGA.LambdaCorrection.χ_λ-Tuple{Float64, Float64}"><code>LadderDGA.LambdaCorrection.χ_λ</code></a></li><li><a href="#LadderDGA.LambdaCorrection.χ_λ!-Tuple{χT, χT, Float64}"><code>LadderDGA.LambdaCorrection.χ_λ!</code></a></li><li><a href="#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, Int64, SimulationParameters}"><code>LadderDGA.OneToIndex_to_Freq</code></a></li><li><a href="#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, SimulationParameters}"><code>LadderDGA.OneToIndex_to_Freq</code></a></li><li><a href="#LadderDGA.PP_p1-Tuple{χT, χT, Vararg{Float64, 4}}"><code>LadderDGA.PP_p1</code></a></li><li><a href="#LadderDGA.PP_p2-Tuple{χT, χT, Float64, Float64, Float64, Float64, Dispersions.KGrid}"><code>LadderDGA.PP_p2</code></a></li><li><a href="#LadderDGA._update_tail!-Tuple{Vector{Float64}}"><code>LadderDGA._update_tail!</code></a></li><li><a href="#LadderDGA.attach_Σloc-Tuple{OffsetArrays.OffsetMatrix{T} where T, OffsetArrays.OffsetVector{T} where T}"><code>LadderDGA.attach_Σloc</code></a></li><li><a href="#LadderDGA.bse_inv-Tuple{Symbol, Array{ComplexF64, 3}}"><code>LadderDGA.bse_inv</code></a></li><li><a href="#LadderDGA.build_GG-Tuple{Dispersions.KGrid, OffsetArrays.OffsetMatrix{T} where T, AbstractVector{Int64}, AbstractVector}"><code>LadderDGA.build_GG</code></a></li><li><a href="#LadderDGA.build_q_access_G-Tuple{Dispersions.KGrid, AbstractVector}"><code>LadderDGA.build_q_access_G</code></a></li><li><a href="#LadderDGA.calc_E-Tuple{χT, γT, χT, γT, Any, Any, Any, Dispersions.KGrid, ModelParameters, SimulationParameters}"><code>LadderDGA.calc_E</code></a></li><li><a href="#LadderDGA.calc_E_ED-Tuple{String}"><code>LadderDGA.calc_E_ED</code></a></li><li><a href="#LadderDGA.calc_bubble-Tuple{Symbol, LadderDGA.RunHelper}"><code>LadderDGA.calc_bubble</code></a></li><li><a href="#LadderDGA.calc_bubble_par-Tuple{lDΓAHelper}"><code>LadderDGA.calc_bubble_par</code></a></li><li><a href="#LadderDGA.calc_gen_χ-Tuple{Array{ComplexF64, 3}, χ₀T, Dispersions.KGrid}"><code>LadderDGA.calc_gen_χ</code></a></li><li><a href="#LadderDGA.calc_Γs_ud-Tuple{Any, Any, Any, lDΓAHelper, OffsetArrays.OffsetMatrix{T} where T}"><code>LadderDGA.calc_Γs_ud</code></a></li><li><a href="#LadderDGA.calc_Σ-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.calc_Σ</code></a></li><li><a href="#LadderDGA.calc_Σ_eom_par-Tuple{Float64, Float64}"><code>LadderDGA.calc_Σ_eom_par</code></a></li><li><a href="#LadderDGA.calc_Σ_par-Tuple{}"><code>LadderDGA.calc_Σ_par</code></a></li><li><a href="#LadderDGA.calc_Σ_parts-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, lDΓAHelper}"><code>LadderDGA.calc_Σ_parts</code></a></li><li><a href="#LadderDGA.calc_λ0-Tuple{χ₀T, lDΓAHelper}"><code>LadderDGA.calc_λ0</code></a></li><li><a href="#LadderDGA.calc_λ0-Tuple{χ₀RPA_T, RPAHelper}"><code>LadderDGA.calc_λ0</code></a></li><li><a href="#LadderDGA.calc_λmax_linEliashberg-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}"><code>LadderDGA.calc_λmax_linEliashberg</code></a></li><li><a href="#LadderDGA.calc_λmax_linEliashberg_MatrixFree-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}"><code>LadderDGA.calc_λmax_linEliashberg_MatrixFree</code></a></li><li><a href="#LadderDGA.calc_χγ-Tuple{Symbol, χ₀RPA_T, ModelParameters, SimulationParameters}"><code>LadderDGA.calc_χγ</code></a></li><li><a href="#LadderDGA.calc_χγ-Tuple{Symbol, lDΓAHelper, χ₀T}"><code>LadderDGA.calc_χγ</code></a></li><li><a href="#LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}"><code>LadderDGA.calc_χγ_par</code></a></li><li><a href="#LadderDGA.clear_wcache!-Tuple{}"><code>LadderDGA.clear_wcache!</code></a></li><li><a href="#LadderDGA.collect_Σ!-Tuple{OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}}"><code>LadderDGA.collect_Σ!</code></a></li><li><a href="#LadderDGA.collect_γ-Tuple{Symbol, Dispersions.KGrid, ModelParameters, SimulationParameters}"><code>LadderDGA.collect_γ</code></a></li><li><a href="#LadderDGA.collect_χ-Tuple{Symbol, lDΓAHelper}"><code>LadderDGA.collect_χ</code></a></li><li><a href="#LadderDGA.collect_χ₀-Tuple{lDΓAHelper}"><code>LadderDGA.collect_χ₀</code></a></li><li><a href="#LadderDGA.conv_tmp_add_rpa!-Union{Tuple{N}, Tuple{AbstractVector{ComplexF64}, Dispersions.KGrid, AbstractArray{ComplexF64, N}}} where N"><code>LadderDGA.conv_tmp_add_rpa!</code></a></li><li><a href="#LadderDGA.core-Tuple{χ₀T}"><code>LadderDGA.core</code></a></li><li><a href="#LadderDGA.core_sum_bosonic-Tuple{Int64, Float64, Int64}"><code>LadderDGA.core_sum_bosonic</code></a></li><li><a href="#LadderDGA.core_sum_fermionic-Tuple{Int64, Float64, Int64}"><code>LadderDGA.core_sum_fermionic</code></a></li><li><a href="#LadderDGA.correction_term-Tuple{ModelParameters, Dispersions.KGrid, χT, Union{Float64, ComplexF64}, AbstractVector{Int64}}"><code>LadderDGA.correction_term</code></a></li><li><a href="#LadderDGA.eom_ν_cutoff-Tuple{Int64, Bool}"><code>LadderDGA.eom_ν_cutoff</code></a></li><li><a href="#LadderDGA.estimate_connected_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}"><code>LadderDGA.estimate_connected_ef</code></a></li><li><a href="#LadderDGA.estimate_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}"><code>LadderDGA.estimate_ef</code></a></li><li><a href="#LadderDGA.expand_ω-Tuple{Any}"><code>LadderDGA.expand_ω</code></a></li><li><a href="#LadderDGA.fermi_surface_connected-Tuple{BitVector, Dispersions.KGrid}"><code>LadderDGA.fermi_surface_connected</code></a></li><li><a href="#LadderDGA.filling-Tuple{AbstractVector{ComplexF64}, Float64}"><code>LadderDGA.filling</code></a></li><li><a href="#LadderDGA.filling_pos-Tuple{AbstractVector{ComplexF64}, Vararg{Float64, 4}}"><code>LadderDGA.filling_pos</code></a></li><li><a href="#LadderDGA.filter_KZ-Union{Tuple{T}, Tuple{Int64, Int64, AbstractVector{T}}} where T&lt;:Number"><code>LadderDGA.filter_KZ</code></a></li><li><a href="#LadderDGA.filter_MA-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}}} where T&lt;:Number"><code>LadderDGA.filter_MA</code></a></li><li><a href="#LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}"><code>LadderDGA.find_usable_χ_interval</code></a></li><li><a href="#LadderDGA.gen_ν_part-Tuple{AbstractArray{Int64}, SimulationParameters, Int64}"><code>LadderDGA.gen_ν_part</code></a></li><li><a href="#LadderDGA.gen_ν_part_slices-Tuple{Array{ComplexF64, 3}, Vector{NTuple{4, Int64}}}"><code>LadderDGA.gen_ν_part_slices</code></a></li><li><a href="#LadderDGA.gen_νω_part-Tuple{SimulationParameters, Int64}"><code>LadderDGA.gen_νω_part</code></a></li><li><a href="#LadderDGA.gen_ω_part-Tuple{SimulationParameters, Int64}"><code>LadderDGA.gen_ω_part</code></a></li><li><a href="#LadderDGA.initialize_EoM-Tuple{lDΓAHelper, Array{ComplexF64, 3}, AbstractVector{Int64}}"><code>LadderDGA.initialize_EoM</code></a></li><li><a href="#LadderDGA.initialize_EoM_cache!-Tuple{Int64}"><code>LadderDGA.initialize_EoM_cache!</code></a></li><li><a href="#LadderDGA.is_okay-Tuple{Any}"><code>LadderDGA.is_okay</code></a></li><li><a href="#LadderDGA.iν_array-Tuple{Real, AbstractVector{Int64}}"><code>LadderDGA.iν_array</code></a></li><li><a href="#LadderDGA.iω_array-Tuple{Real, AbstractVector{Int64}}"><code>LadderDGA.iω_array</code></a></li><li><a href="#LadderDGA.log_q0_χ_check-Tuple{Dispersions.KGrid, SimulationParameters, AbstractMatrix{Float64}, Symbol}"><code>LadderDGA.log_q0_χ_check</code></a></li><li><a href="#LadderDGA.par_partition-Tuple{AbstractVector, Int64}"><code>LadderDGA.par_partition</code></a></li><li><a href="#LadderDGA.printr_s-Tuple{ComplexF64}"><code>LadderDGA.printr_s</code></a></li><li><a href="#LadderDGA.q0_index-Tuple{Dispersions.KGrid}"><code>LadderDGA.q0_index</code></a></li><li><a href="#LadderDGA.readConfig-Tuple{String}"><code>LadderDGA.readConfig</code></a></li><li><a href="#LadderDGA.readConfig_RPA-Tuple{String}"><code>LadderDGA.readConfig_RPA</code></a></li><li><a href="#LadderDGA.readFortranχDMFT-Tuple{String}"><code>LadderDGA.readFortranχDMFT</code></a></li><li><a href="#LadderDGA.read_χ₀_RPA-Tuple{String, Int64}"><code>LadderDGA.read_χ₀_RPA</code></a></li><li><a href="#LadderDGA.reduce_range-Tuple{AbstractArray, Float64}"><code>LadderDGA.reduce_range</code></a></li><li><a href="#LadderDGA.setupConfig_RPA-Tuple{String, Int64, Float64, Float64, Float64, Float64, Float64, Float64, Int64, Int64, Int64, Bool}"><code>LadderDGA.setupConfig_RPA</code></a></li><li><a href="#LadderDGA.setup_LDGA-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}"><code>LadderDGA.setup_LDGA</code></a></li><li><a href="#LadderDGA.setup_LDGAa-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}"><code>LadderDGA.setup_LDGAa</code></a></li><li><a href="#LadderDGA.shell_sum_fermionic-Tuple{Int64, Float64, Int64}"><code>LadderDGA.shell_sum_fermionic</code></a></li><li><a href="#LadderDGA.subtract_tail-Tuple{AbstractVector, Float64, Vector{ComplexF64}, Int64}"><code>LadderDGA.subtract_tail</code></a></li><li><a href="#LadderDGA.subtract_tail!-Tuple{AbstractVector, AbstractVector, Float64, Vector{ComplexF64}, Int64}"><code>LadderDGA.subtract_tail!</code></a></li><li><a href="#LadderDGA.sum_kω-Tuple{Dispersions.KGrid, Union{χT, χ₀RPA_T}}"><code>LadderDGA.sum_kω</code></a></li><li><a href="#LadderDGA.sum_ω-Tuple{χT}"><code>LadderDGA.sum_ω</code></a></li><li><a href="#LadderDGA.sum_ωk-Tuple{Dispersions.KGrid, χT}"><code>LadderDGA.sum_ωk</code></a></li><li><a href="#LadderDGA.tail_correction_term-Tuple{Float64, Float64, Vector{ComplexF64}}"><code>LadderDGA.tail_correction_term</code></a></li><li><a href="#LadderDGA.tail_factor-Tuple{Float64, Float64, Float64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Vector{ComplexF64}}"><code>LadderDGA.tail_factor</code></a></li><li><a href="#LadderDGA.update_tail!-Tuple{Vector{Float64}}"><code>LadderDGA.update_tail!</code></a></li><li><a href="#LadderDGA.update_tail!-Tuple{χT, Array{Float64}, Array{ComplexF64}}"><code>LadderDGA.update_tail!</code></a></li><li><a href="#LadderDGA.update_wcache!-Tuple{Symbol, Any}"><code>LadderDGA.update_wcache!</code></a></li><li><a href="#LadderDGA.usable_ωindices-Union{Tuple{N}, Tuple{SimulationParameters, Vararg{χT, N}}} where N"><code>LadderDGA.usable_ωindices</code></a></li><li><a href="#LadderDGA.Δ-Tuple{Vector{Float64}, Vector{Float64}, Vector{ComplexF64}}"><code>LadderDGA.Δ</code></a></li><li><a href="#LadderDGA.Σ_Dyson-Tuple{Vector{ComplexF64}, Vector{ComplexF64}}"><code>LadderDGA.Σ_Dyson</code></a></li><li><a href="#LadderDGA.Σ_hartree-Tuple{ModelParameters}"><code>LadderDGA.Σ_hartree</code></a></li><li><a href="#LadderDGA.λ_from_γ-Tuple{Symbol, γT, χT, Float64}"><code>LadderDGA.λ_from_γ</code></a></li><li><a href="#LadderDGA.ν0Index_of_ωIndex-Tuple{Int64, SimulationParameters}"><code>LadderDGA.ν0Index_of_ωIndex</code></a></li><li><a href="#LadderDGA.νi_health-Tuple{AbstractArray{Int64}, SimulationParameters}"><code>LadderDGA.νi_health</code></a></li><li><a href="#LadderDGA.νi_νngrid_pos-Tuple{Int64, Int64, SimulationParameters}"><code>LadderDGA.νi_νngrid_pos</code></a></li><li><a href="#LadderDGA.νnGrid-Tuple{Int64, SimulationParameters}"><code>LadderDGA.νnGrid</code></a></li><li><a href="#LadderDGA.χ₀Asym-Tuple{Float64, Vector{Float64}, Float64, AbstractVector{Int64}, Int64, Bool, Float64}"><code>LadderDGA.χ₀Asym</code></a></li><li><a href="#LadderDGA.χ₀Asym_coeffs-Tuple{Symbol, Dispersions.KGrid, ModelParameters}"><code>LadderDGA.χ₀Asym_coeffs</code></a></li><li><a href="#LadderDGA.ω0_index-Tuple{SimulationParameters}"><code>LadderDGA.ω0_index</code></a></li><li><a href="#LadderDGA.ω2_tail-Tuple{χT}"><code>LadderDGA.ω2_tail</code></a></li><li><a href="#LadderDGA.ω_tail-Tuple{χT, χT, AbstractVector{Float64}, SimulationParameters}"><code>LadderDGA.ω_tail</code></a></li><li><a href="#LadderDGA.ωn_grid-Tuple{Union{χT, χ₀RPA_T}}"><code>LadderDGA.ωn_grid</code></a></li></ul><h1 id="List-of-Functions"><a class="docs-heading-anchor" href="#List-of-Functions">List of Functions</a><a id="List-of-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-Functions" title="Permalink"></a></h1><h2 id="LadderDGA"><a class="docs-heading-anchor" href="#LadderDGA">LadderDGA</a><a id="LadderDGA-1"></a><a class="docs-heading-anchor-permalink" href="#LadderDGA" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.EnvironmentVars" href="#LadderDGA.EnvironmentVars"><code>LadderDGA.EnvironmentVars</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EnvironmentVars &lt;: ConfigStruct</code></pre><p>Contains various settings, controlling the I/O behaviour of this module. This is typically generated from a config.toml file using the <a href="#LadderDGA.readConfig-Tuple{String}"><code>readConfig</code></a> function.</p><p><strong>Fields</strong></p><ul><li><strong><code>inputDir</code></strong>        : <code>String</code>, Directory of input files</li><li><strong><code>inputVars</code></strong>       : <code>String</code>, File name of .jld2 file containing input.</li><li><strong><code>loglevel</code></strong>        : <code>String</code>, Options: disabled, error, warn, info, debug</li><li><strong><code>logfile</code></strong>         : <code>String</code>,    Options: STDOUT, STDERR, filename</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/Config.jl#LL77-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.ModelParameters" href="#LadderDGA.ModelParameters"><code>LadderDGA.ModelParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelParameters &lt;: ConfigStruct</code></pre><p>Contains model parameters for the Hubbard model. This is typically generated from a config.toml file using  the <a href="#LadderDGA.readConfig-Tuple{String}"><code>readConfig</code></a> function.</p><p><strong>Fields</strong></p><ul><li><strong><code>U</code></strong>         : <code>Float64</code>, Hubbard U</li><li><strong><code>μ</code></strong>         : <code>Float64</code>, chemical potential</li><li><strong><code>β</code></strong>         : <code>Float64</code>, inverse temperature</li><li><strong><code>n</code></strong>         : <code>Float64</code>, filling</li><li><strong><code>Epot_1Pt</code></strong> : <code>Float64</code>, DMFT potential energy</li><li><strong><code>Ekin_1Pt</code></strong> : <code>Float64</code>, DMFT kinetic energy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/Config.jl#LL23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.RPAHelper" href="#LadderDGA.RPAHelper"><code>LadderDGA.RPAHelper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RPAHelper &lt;: RunHelper</code></pre><p>Struct with data needed to run ladder RPA calculations.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">setup_RPA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [; silent=false])</code></pre><p>See <a href="@ref setup_RPA"><code>setup_RPA</code></a></p><p><strong>Fields</strong></p><pre><code class="nohighlight hljs">TODO: documentation</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/runHelpers.jl#LL53-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.SimulationParameters" href="#LadderDGA.SimulationParameters"><code>LadderDGA.SimulationParameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimulationParameters &lt;: ConfigStruct</code></pre><p>Contains simulation parameters for the ladder DGA computations. This is typically generated from a config.toml file using the <a href="#LadderDGA.readConfig-Tuple{String}"><code>readConfig</code></a> function.</p><p><strong>Fields</strong></p><ul><li><strong><code>n_iω</code></strong>                    : <code>Int</code>, Number of positive bosonic frequencies (full number will be <code>2*n_iω+1</code> </li><li><strong><code>n_iν</code></strong>                    : <code>Int</code>, Number of positive fermionic frequencies (full number will be <code>2*n_iν</code> </li><li><strong><code>n_iν_shell</code></strong>              : <code>Int</code>, Number of fermionic frequencies used for asymptotic sum improvement (<code>χ_asym_r</code> arrays with at least these many entries need to be provided)</li><li><strong><code>shift</code></strong>                   : <code>Bool</code>, Flag specifying if <code>-n_iν:n_iν-1</code> is shifted by <code>-ωₙ/2</code> at each <code>ωₙ</code> slice (centering the main features)</li><li><strong><code>χ_helper</code></strong>                : <code>struct</code>, helper struct for asymptotic sum improvements involving the generalized susceptibility (<code>nothing</code> if <code>n_iν_shell == 0</code>), see also <code>BSE_SC.jl</code>.</li><li><strong><code>sVk</code></strong>                     : <code>Float64</code>, ∑_k Vₖ^2</li><li><strong><code>fft_range</code></strong>               : <code>Int</code>, Frequencies used for computations of type <code>f(νₙ + ωₙ)</code>. </li><li><strong><code>usable_prct_reduction</code></strong>   : <code>Float64</code>, percent reduction of usable bosonic frequencies</li><li><strong><code>dbg_full_eom_omega</code></strong>      : <code>Bool</code>, if true overrides usable ω ranges to <code>n_iω</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/Config.jl#LL47-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.lDΓAHelper" href="#LadderDGA.lDΓAHelper"><code>LadderDGA.lDΓAHelper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">lDΓAHelper &lt;: RunHelper</code></pre><p>Struct with data needed to run ladder DΓA calculations.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">setup_LDGA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars)</code></pre><p>See <a href="#LadderDGA.setup_LDGA-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}"><code>setup_LDGA</code></a></p><p><strong>Fields</strong></p><p>TODO: documentation for fields</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/runHelpers.jl#LL13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.γT" href="#LadderDGA.γT"><code>LadderDGA.γT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">γT &lt;: MatsubaraFunction</code></pre><p>Struct for the non-local triangular vertex. </p><p><strong>Fields</strong></p><ul><li><strong><code>data</code></strong>         : <code>Array{ComplexF64,3}</code>, data</li><li><strong><code>axis_types</code></strong>   : <code>Dict{Symbol,Int}</code>, Dictionary mapping <code>:q, :ν, :ω</code> to the axis indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL443-L452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.χT" href="#LadderDGA.χT"><code>LadderDGA.χT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">χT &lt;: MatsubaraFunction</code></pre><p>Struct for the non-local susceptibilities. </p><p><strong>Constructor</strong></p><p><code>χT(data::Array{T, 2}; full_range=true, reduce_range_prct=0.1)</code>: if <code>full_range</code> is set to <code>false</code>, the usable range  is determined via <a href="#LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}"><code>find_usable_χ_interval</code></a>.</p><p><strong>Fields</strong></p><ul><li><strong><code>data</code></strong>         : <code>Array{ComplexF64,3}</code>, data</li><li><strong><code>axis_types</code></strong>   : <code>Dict{Symbol,Int}</code>, Dictionary mapping <code>:q, :ω</code> to the axis indices.</li><li><strong><code>indices_ω</code></strong>    : <code>Vector{Int}</code>, </li><li><strong><code>tail_c</code></strong>       : <code>Vector{Float64}</code>, tail coefficients of <span>$1/\omega^i$</span> tails. Index <code>1</code> corresponds to <code>i=0</code>.</li><li><strong><code>λ</code></strong>            : <code>Float64</code>, λ correction parameter.</li><li><strong><code>β</code></strong>            : <code>Float64</code>, inverse temperature.</li><li><strong><code>usable_ω</code></strong>     : <code>AbstractArray{Int}</code>, usable indices for which data is assumed to be correct. See also <a href="#LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}"><code>find_usable_χ_interval</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL199-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.χ₀RPA_T" href="#LadderDGA.χ₀RPA_T"><code>LadderDGA.χ₀RPA_T</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">χ₀RPA_T &lt;: MatsubaraFunction</code></pre><p>Struct for the RPA bubble term.</p><p>TODO: this does not use the χ₀Asym function and mixes thermodynamic quantities (kinetic energy) with       tail coefficients (they are the same, but should not be stored this way here).</p><p><strong>Constructor</strong></p><p>χ₀RPA<em>T(data::Array{</em>eltype,2}, ωnGrid::AbstractVector{Int}, νnGrid::UnitRange{Int64}, β::Float64)</p><p>This constructor does not perform any checks for the entered data array in the currently implemented version. Make sure that the axes match the axis_types field!</p><p><strong>Fields</strong></p><ul><li><strong><code>data</code></strong>         : <code>Array{ComplexF64,3}</code>, data.</li><li><strong><code>axis_types</code></strong>   : <code>Dict{Symbol,Int}</code>, Dictionary mapping <code>:q, :ω</code> to the axis indices.</li><li><strong><code>indices_ω</code></strong>    : <code>Vector{Int}</code>, <code>m</code> indices m of bosonic <span>$\omega_m$</span> Matsubara frequencies.</li><li><strong><code>β</code></strong>            : <code>Float64</code>, inverse temperature.</li><li><strong><code>e_kin</code></strong>        : <code>Float64</code>, kinetic energy.</li><li><strong><code>Nq</code></strong>           : <code>Int</code>, Number of points per dimension that are used to sample the reciprocal space</li><li><strong><code>Ngl</code></strong>           : <code>Int</code>, Number of gauß-legendre sample points per dimension that where used to calculate each element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL160-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.χ₀T" href="#LadderDGA.χ₀T"><code>LadderDGA.χ₀T</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">χ₀T &lt;: MatsubaraFunction</code></pre><p>Struct for the bubble term. The <code>q</code>, <code>ω</code> dependent asymptotic behavior is computed from the  <code>t1</code> and <code>t2</code> input.  See <a href="#LadderDGA.χ₀Asym_coeffs-Tuple{Symbol, Dispersions.KGrid, ModelParameters}"><code>χ₀Asym_coeffs</code></a> implementation for details.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">χ₀T(type::Symbol, data::Array{_eltype,3}, kG::KGrid, ωnGrid::AbstractVector{Int}, n_iν::Int, shift::Bool, mP::ModelParameters)</code></pre><p>Set <code>local_tail=true</code> in case of the local bubble constructed fro mthe impurity Green&#39;s function. This is necessary in order to construct the correct asymptotics.</p><p><strong>Fields</strong></p><ul><li><strong><code>type</code></strong>         : <code>Symbol</code>, can be <code>DMFT</code>, <code>local</code>, <code>RPA</code>, <code>RPA_exact</code>. TODO: documentation</li><li><strong><code>data</code></strong>         : <code>Array{ComplexF64,3}</code>, data</li><li><strong><code>asym</code></strong>         : <code>Array{ComplexF64,2}</code>, <code>[q, ω]</code> dependent asymptotic behavior.</li><li><strong><code>axis_types</code></strong>   : <code>Dict{Symbol,Int}</code>, Dictionary mapping <code>:q, :ν, :ω</code> to the axis indices.</li><li><strong><code>indices_νω</code></strong>   : <code>Matrix{Tuple{Int,Int}}</code>, (n,m) indices of fermionic <span>$\nu_n$</span> and bosonic <span>$\omega_m$</span> Matsubara frequencies.</li><li><strong><code>β</code></strong>            : <code>Float64</code>, inverse temperature.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL32-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, ModelParameters}" href="#Base.show-Tuple{IO, ModelParameters}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, m::ModelParameters)</code></pre><p>Custom output for ModelParameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO.jl#LL166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, SimulationParameters}" href="#Base.show-Tuple{IO, SimulationParameters}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, m::SimulationParameters)</code></pre><p>Custom output for SimulationParameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO.jl#LL143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.EPot1-Tuple{Dispersions.KGrid, AbstractMatrix{ComplexF64}, Matrix{ComplexF64}, Matrix{ComplexF64}, Vector{Float64}, Float64}" href="#LadderDGA.EPot1-Tuple{Dispersions.KGrid, AbstractMatrix{ComplexF64}, Matrix{ComplexF64}, Matrix{ComplexF64}, Vector{Float64}, Float64}"><code>LadderDGA.EPot1</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Specialized function for DGA potential energy. Better performance than calc_E.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/thermodynamics.jl#LL129-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.EPot_p1-Tuple{χT, χT, Vararg{Float64, 4}}" href="#LadderDGA.EPot_p1-Tuple{χT, χT, Vararg{Float64, 4}}"><code>LadderDGA.EPot_p1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EPot_p1(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64, U::Float64)::Float64</code></pre><p>Pauli-Principle on 2-particle level: <span>$\sum_{k,\nu} G^{\lambda,\nu}_{k} \Sigma^{\lambda,\nu}_{k}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/thermodynamics.jl#LL33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.EPot_p2-Tuple{χT, χT, Float64, Float64, Float64, Float64, Dispersions.KGrid}" href="#LadderDGA.EPot_p2-Tuple{χT, χT, Float64, Float64, Float64, Float64, Dispersions.KGrid}"><code>LadderDGA.EPot_p2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EPot_p2(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64, U::Float64)::Float64</code></pre><p>Pauli-Principle on 2-particle level: <span>$U(\sum_{k,\omega} \chi^{\lambda,\omega}_{m,k} - \sum_{k,\omega} \chi^{\lambda,\omega}_{d,k})/2 + U n^2/4$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/thermodynamics.jl#LL42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.F_from_χ-Tuple{Symbol, lDΓAHelper}" href="#LadderDGA.F_from_χ-Tuple{Symbol, lDΓAHelper}"><code>LadderDGA.F_from_χ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_from_χ(type::Symbol, h::lDΓAHelper; diag_term=true)
F_from_χ(χ::AbstractArray{ComplexF64,3}, G::AbstractArray{ComplexF64,1}, sP::SimulationParameters, β::Float64; diag_term=true)</code></pre><p>TODO: documentation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/BSETools.jl#LL29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.F_from_χ_gen-Tuple{χ₀T, Array{ComplexF64, 4}}" href="#LadderDGA.F_from_χ_gen-Tuple{χ₀T, Array{ComplexF64, 4}}"><code>LadderDGA.F_from_χ_gen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_from_χ_gen(χ₀::χ₀T, χr::Array{ComplexF64,4})::Array{ComplexF64,4}</code></pre><p>Calculates the full vertex from the generalized susceptibility <span>$\chi^{\nu\nu&#39;\omega}_r$</span> and the bubble term <span>$\chi_0$</span> via <span>$F^{\nu\nu&#39;\omega}_{r,\mathbf{q}}       =      \beta^2 \left( \chi^{\nu\nu&#39;\omega}_{0,\mathbf{q}} \right)^{-1}       - \left( \chi^{\nu\omega}_{0,\mathbf{q}} \right)^{-1}  \chi^{\nu\nu&#39;\omega}_{r,\mathbf{q}} \left( \chi^{\nu&#39;\omega}_{0,\mathbf{q}} \right)^{-1}$</span></p><p>For a version using the physical susceptibilities see <a href="#LadderDGA.F_from_χ_gen-Tuple{χ₀T, Array{ComplexF64, 4}}"><code>F_from_χ_gen</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/BSETools.jl#LL68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.F_from_χ_star_gen-Tuple{χ₀T, Array{ComplexF64, 4}, χT, γT, Float64}" href="#LadderDGA.F_from_χ_star_gen-Tuple{χ₀T, Array{ComplexF64, 4}, χT, γT, Float64}"><code>LadderDGA.F_from_χ_star_gen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_from_χ_star_gen(χ₀::χ₀T, χstar_r::Array{ComplexF64,4}, χr::χT, γr::γT, Ur::Float64)</code></pre><p>Calculates the full vertex from the generalized susceptibility <span>$\chi^{\nu\nu&#39;\omega}_r$</span>, the physical susceptibility <span>$\chi^{\omega}_r$</span> and the triangular vertex <span>$\gamma^{\nu\omega}_r$</span>. This is usefull to calculate a <span>$\lambda$</span>-corrected full vertex. </p><p><span>$F^{\nu\nu&#39;\omega}_{r,\mathbf{q}}       =      \beta^2 \left( \chi^{\nu\nu&#39;\omega}_{0,\mathbf{q}} \right)^{-1}       - \beta^2 (\chi^{\nu\omega}_{0,\mathbf{q}})^{-1} \chi^{*,\nu\nu&#39;\omega}_{r,\mathbf{q}} (\chi^{\nu&#39;\omega}_{0,\mathbf{q}})^{-1}      + U_r (1 - U_r \chi^{\omega}_{r,\mathbf{q}}) \gamma^{\nu\omega}_{r,\mathbf{q}} \gamma^{\nu&#39;\omega}_{r,\mathbf{q}}$</span> For a version using the physical susceptibilities see <a href="#LadderDGA.F_from_χ_gen-Tuple{χ₀T, Array{ComplexF64, 4}}"><code>F_from_χ_gen</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/BSETools.jl#LL92-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.G_fft-Tuple{OffsetArrays.OffsetArray, Dispersions.KGrid, SimulationParameters}" href="#LadderDGA.G_fft-Tuple{OffsetArrays.OffsetArray, Dispersions.KGrid, SimulationParameters}"><code>LadderDGA.G_fft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_fft(G::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)</code></pre><p>Calculates fast Fourier transformed lattice Green&#39;s functions used for <a href="#LadderDGA.calc_bubble-Tuple{Symbol, LadderDGA.RunHelper}"><code>calc_bubble</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.G_from_Σ-Tuple{Int64, Float64, Float64, Float64, ComplexF64}" href="#LadderDGA.G_from_Σ-Tuple{Int64, Float64, Float64, Float64, ComplexF64}"><code>LadderDGA.G_from_Σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_from_Σ(ind::Int64, β::Float64, μ::Float64, ϵₖ::Float64, Σ::ComplexF64)
G_from_Σ(mf::ComplexF64, μ::Float64, ϵₖ::Float64, Σ::ComplexF64)</code></pre><p>Computes Green&#39;s function according to <span>$[\frac{(2 n + 1)\pi i}{\beta} + \mu - \epsilon_k - \Sigma(k,i\nu_n)]^{-1}$</span>, where <span>$\epsilon_k$</span> and <span>$\Sigma(k,i\nu_n)$</span> are given as single values. Convenience wrappers for full grids are provided below.</p><p><strong>Arguments:</strong></p><ul><li><strong><code>ind</code></strong> : Matsubara frequency index</li><li><strong><code>mf</code></strong>  : Matsubara frequency</li><li><strong><code>β</code></strong>   : Inverse temperature (only needs to be set, if index instead of frequency is given)</li><li><strong><code>μ</code></strong>   : Chemical potential</li><li><strong><code>ϵₖ</code></strong>  : Dispersion relation at fixed <code>k</code>, see below for convenience wrappers.</li><li><strong><code>Σ</code></strong>   : Self energy at fixed frequency (and potentially fixed <code>k</code>), see below for convenience wrappers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL75-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.G_from_Σ-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Vector{Float64}, UnitRange{Int64}, ModelParameters}" href="#LadderDGA.G_from_Σ-Tuple{OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Vector{Float64}, UnitRange{Int64}, ModelParameters}"><code>LadderDGA.G_from_Σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_from_Σ(Σ::OffsetVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::UnitRange{Int}, mP::ModelParameters;
              μ = mP.μ, Σloc::OffsetVector{ComplexF64} = OffsetVector(ComplexF64[], 0:-1),
        )
G_from_Σ!(res::OffsetMatrix{ComplexF64}, Σ::OffsetVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::UnitRange{Int},
            mP::ModelParameters; μ = mP.μ, Σloc::OffsetVector{ComplexF64} = OffsetVector(ComplexF64[], 0:-1),
        )::Nothing

mP::ModelParameters; μ = mP.μ, Σloc::OffsetVector{ComplexF64} = OffsetVector(ComplexF64[], 0:-1),

G_from_Σ(Σ::AbstractVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::AbstractVector{Int}, mP::ModelParameters; μ = mP.μ,  Σloc::AbstractArray = nothing) 
G_from_Σ!(res::Matrix{ComplexF64}, Σ::AbstractVector{ComplexF64}, ϵkGrid::Vector{Float64}, range::AbstractVector{Int}, mP::ModelParameters; μ = mP.μ,  Σloc::AbstractVector = nothing)</code></pre><p>#TODO: unify API, redo documentation</p><p>Computes Green&#39;s function from self energy <code>Σ</code> and dispersion <code>ϵkGrid</code> over given frequency indices <code>range</code>. Optionally, a different chemical potential <code>μ</code> can be provided. When the non-local self energy is used, one typically wants to extend the usefull range of frequencies by attaching the tail of the local self energy in the high frequency regime. This is done by providing a <code>range</code> larger than the array size of <code>Σ</code> and in addition setting <code>Σloc</code> (the size of <code>Σloc</code> must be as large or larger than <code>range</code>).  The inplace version stores the result in <code>res</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL95-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.G_from_Σladder-Tuple{AbstractMatrix{ComplexF64}, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Dispersions.KGrid, ModelParameters, SimulationParameters}" href="#LadderDGA.G_from_Σladder-Tuple{AbstractMatrix{ComplexF64}, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Dispersions.KGrid, ModelParameters, SimulationParameters}"><code>LadderDGA.G_from_Σladder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_from_Σladder(Σ_ladder::AbstractMatrix{ComplexF64}, Σloc::Vector{ComplexF64}, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; 
               fix_n::Bool=false, μ=mP.μ, improved_sum_filling::Bool=true, νRange = sP.fft_range, n = mP.n, νFitRange=0:last(axes(Σ_ladder, 2)) )
G_from_Σladder!(G_new::OffsetMatrix{ComplexF64}, Σ_ladder::OffsetMatrix{ComplexF64}, Σloc::AbstractVector{ComplexF64}, kG::KGrid, mP::ModelParameters; 
                fix_n::Bool=false, μ=mP.μ, improved_sum_filling::Bool=true, n = mP.n, νFitRange=0:last(axes(Σ_ladder, 2)) )</code></pre><p>Computes Green&#39;s function from lDΓA self-energy. This is the Greensfunction used in eq. (8) of Stobbe, J., &amp; Rohringer, G. (2022). Consistency of potential energy in the dynamical vertex approximation. Physical Review B, 106(20), 205101.</p><p>The resulting frequency range is given by default as <code>νRange = sP.fft_range</code>, if less frequencies are available from <code>Σ_ladder</code>, <code>Σloc</code> is used instead. TODO: documentation for arguments TODO: fit function computes loads of unnecessary frequencies</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL200-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.G_rfft!-Tuple{OffsetArrays.OffsetArray, OffsetArrays.OffsetArray, Dispersions.KGrid, UnitRange}" href="#LadderDGA.G_rfft!-Tuple{OffsetArrays.OffsetArray, OffsetArrays.OffsetArray, Dispersions.KGrid, UnitRange}"><code>LadderDGA.G_rfft!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_rfft!(G_rfft::GνqT, G::GνqT, kG::KGrid, fft_range::UnitRange)::Nothing</code></pre><p>Calculates fast Fourier transformed lattice Green&#39;s functions used for <a href="#LadderDGA.calc_bubble-Tuple{Symbol, LadderDGA.RunHelper}"><code>calc_bubble</code></a>. Inplace version of <a href="#LadderDGA.G_fft-Tuple{OffsetArrays.OffsetArray, Dispersions.KGrid, SimulationParameters}"><code>G_fft</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, Int64, SimulationParameters}" href="#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, Int64, SimulationParameters}"><code>LadderDGA.OneToIndex_to_Freq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OneToIndex_to_Freq(ωi::Int, νpi::Int, νi::Int, sP::SimulationParameters)
Freq_to_OneToIndex(ωn::Int, νn::Int, νpn::Int, shift::Int, nBose::Int, nFermi::Int)</code></pre><p>Converts Matsubara frequency index to array indices, starting at 1. This is the inverse function of <a href="#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, Int64, SimulationParameters}"><code>OneToIndex_to_Freq</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, SimulationParameters}" href="#LadderDGA.OneToIndex_to_Freq-Tuple{Int64, Int64, SimulationParameters}"><code>LadderDGA.OneToIndex_to_Freq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OneToIndex_to_Freq(ωi::Int, νi::Int, sP::SimulationParameters)
OneToIndex_to_Freq(ωi::Int, νi::Int, shift::Int, nBose::Int, nFermi::Int)</code></pre><p>Converts <code>(1:N,1:N)</code> index tuple for bosonic (<code>ωi</code>) and fermionic (<code>νi</code>) frequency to Matsubara frequency number. If the array has a <code>ν</code> shell (for example for tail improvements) this will also be taken into account by providing <code>Nν_shell</code>. This is the inverse function of <a href="@ref Freq_to_OneToIndex"><code>Freq_to_OneToIndex</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL39-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.PP_p1-Tuple{χT, χT, Vararg{Float64, 4}}" href="#LadderDGA.PP_p1-Tuple{χT, χT, Vararg{Float64, 4}}"><code>LadderDGA.PP_p1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PP_p1(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64, U::Float64)::Float64</code></pre><p>Pauli-Principle on 1-particle level: <span>$n/2 (1-n/2)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/thermodynamics.jl#LL15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.PP_p2-Tuple{χT, χT, Float64, Float64, Float64, Float64, Dispersions.KGrid}" href="#LadderDGA.PP_p2-Tuple{χT, χT, Float64, Float64, Float64, Float64, Dispersions.KGrid}"><code>LadderDGA.PP_p2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PP_p2(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64, U::Float64)::Float64</code></pre><p>Pauli-Principle on 2-particle level: <span>$(\sum_{k,\omega} \chi^{\lambda,\omega}_{m,k} + \sum_{k,\omega} \chi^{\lambda,\omega}_{d,k})/2$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/thermodynamics.jl#LL24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA._update_tail!-Tuple{Vector{Float64}}" href="#LadderDGA._update_tail!-Tuple{Vector{Float64}}"><code>LadderDGA._update_tail!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_update_tail!(coeffs::Vector{Float64})</code></pre><p>Updates the Ekin/ω^2 tail of physical susceptibilities on worker. Used by <a href="#LadderDGA.update_tail!-Tuple{Vector{Float64}}"><code>update_tail!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.attach_Σloc-Tuple{OffsetArrays.OffsetMatrix{T} where T, OffsetArrays.OffsetVector{T} where T}" href="#LadderDGA.attach_Σloc-Tuple{OffsetArrays.OffsetMatrix{T} where T, OffsetArrays.OffsetVector{T} where T}"><code>LadderDGA.attach_Σloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">attach_Σloc(Σ_ladder::OffsetMatrix, Σ_loc::OffsetVector; 
            ν_first::Int=last(axis(Σ_ladder,2))+1, ν_last::Int=last(axes(Σloc,1)))</code></pre><p>Attach the local self energy tail, starting at <code>ν_first</code> up to <code>ν_last</code> to the ladder self energy. #TODO: attach this smoothely by also considering derivatives</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL164-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.bse_inv-Tuple{Symbol, Array{ComplexF64, 3}}" href="#LadderDGA.bse_inv-Tuple{Symbol, Array{ComplexF64, 3}}"><code>LadderDGA.bse_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bse_inv(type::Symbol, Γr::Array{ComplexF64,3})</code></pre><p>Kernel for calculation of susceptibility and triangular vertex. Used by <a href="#LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}"><code>calc_χγ_par</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools.jl#LL85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.build_GG-Tuple{Dispersions.KGrid, OffsetArrays.OffsetMatrix{T} where T, AbstractVector{Int64}, AbstractVector}" href="#LadderDGA.build_GG-Tuple{Dispersions.KGrid, OffsetArrays.OffsetMatrix{T} where T, AbstractVector{Int64}, AbstractVector}"><code>LadderDGA.build_GG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_GG(GF::OffsetMatrix, νnGrid::AbstractVector{Int}, kVecs::AbstractVector{NTuple})::Matrix{ComplexF64}</code></pre><p>Builds helper array <code>A</code>, defined as: <span>$A^{\nu}_{k} = G^\nu_{k} G^{-\nu}_{-k}$</span>. Used, for example, by <a href="@ref build_Γs"><code>build_Γs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LinearizedEliashberg.jl#LL18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.build_q_access_G-Tuple{Dispersions.KGrid, AbstractVector}" href="#LadderDGA.build_q_access_G-Tuple{Dispersions.KGrid, AbstractVector}"><code>LadderDGA.build_q_access_G</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_q_access(kG::KGrid, k_vecs::AbstractVector{NTuple})::Array{Int,2}</code></pre><p>Builds helper array <code>A</code>, defined as: <span>$A^{\nu}_{k} = G^\nu_{k} G^{-\nu}_{-k}$</span>. Used, for example, by <a href="@ref build_Γs"><code>build_Γs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LinearizedEliashberg.jl#LL40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_E-Tuple{χT, γT, χT, γT, Any, Any, Any, Dispersions.KGrid, ModelParameters, SimulationParameters}" href="#LadderDGA.calc_E-Tuple{χT, γT, χT, γT, Any, Any, Any, Dispersions.KGrid, ModelParameters, SimulationParameters}"><code>LadderDGA.calc_E</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calc<em>E(χ</em>sp::χT, γ<em>sp::γT, χ</em>ch::χT, γ<em>ch::γT, λ₀, Σ</em>loc, gLoc<em>rfft, kG::KGrid, mP::ModelParameters, sP::SimulationParameters;          νmax::Int = eom</em>ν<em>cutoff(sP), tc::Bool=true) calc</em>E([G::Array{ComplexF64,2},] Σ::AbstractArray{ComplexF64,2}, kG::KGrid, mP::ModelParameters; trace::Bool=false)</p><p>Returns kinetic and potential energies from given      * self-energy <code>Σ</code> or     * the ingredients of the equation of motion: the physical susceptibilies as well as the triangular vertices in spin and charge channel, the correction term and the greensfunction to be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/thermodynamics.jl#LL158-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_E_ED-Tuple{String}" href="#LadderDGA.calc_E_ED-Tuple{String}"><code>LadderDGA.calc_E_ED</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_E_ED(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, GImp::Vector{ComplexF64}, U, n, μ, β)
calc_E_ED(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, GImp::Vector{ComplexF64}, mP::ModelParameters)
calc_E_ED(fname::String)</code></pre><p>Computes kinetic and potential energies from Anderson parameters.</p><p><strong>Returns:</strong></p><p>(EKin, EPot): <code>Tuple{Float64,Float64}</code>, kinetic and potential energy.</p><p><strong>Arguments:</strong></p><ul><li><strong><code>fname</code></strong> : <code>jld2</code>-file containing the fields: <code>[gImp, β, ϵₖ, Vₖ, U, nden, μ]</code> (see below)</li><li><strong><code>ϵₖ</code></strong>    : bath levels</li><li><strong><code>Vₖ</code></strong>    : hoppend amplitudes</li><li><strong><code>GImp</code></strong>  : impurity Green&#39;s function. WARNING: the arguments are assumed to by fermionic Matsuabra indices 0:length(GImp)-1!</li><li><strong><code>U</code></strong>     : Coulomb interaction strength</li><li><strong><code>n</code></strong>     : number density</li><li><strong><code>μ</code></strong>     : chemical potential</li><li><strong><code>β</code></strong>     : inverse temperature</li><li><strong><code>mP</code></strong>    : Alternative call with model parameters as <code>Float64</code>. See also <a href="#LadderDGA.ModelParameters"><code>ModelParameters</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/thermodynamics.jl#LL58-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_bubble-Tuple{Symbol, LadderDGA.RunHelper}" href="#LadderDGA.calc_bubble-Tuple{Symbol, LadderDGA.RunHelper}"><code>LadderDGA.calc_bubble</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_bubble(type::Symbol, h &lt;: RunHelper; mode=:ph)
calc_bubble(type::Symbol, Gνω::GνqT, Gνω_r::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; mode=:ph)</code></pre><p>Calculates bubble term.</p><p><span>$\chi^{\omega}_{0,\mathbf{q}} = -\Sigma_{\mathbf{k}} \Sigma_{\nu} G^{\nu}_{\mathbf{k}} \cdot G^{\nu+\omega}_{\mathbf{k}+\mathbf{q}}$</span></p><p>where     <span>$\nu$</span>     : Fermionic Matsubara frequencies     <span>$\omega$</span>  : Bosonic Matsubara frequencies     <span>$\mathbf{k}, \mathbf{q}$</span>: Element of the first Brillouin zone</p><pre><code class="nohighlight hljs">This is a real-valued quantity.</code></pre><p><strong>Returns</strong></p><p>Bubble, <code>χ₀::χ₀T</code></p><p><strong>Arguments</strong></p><ul><li><strong><code>type</code></strong>      : <code>Symbol</code>, can be <code>DMFT</code>, <code>local</code>, <code>RPA</code>, <code>RPA_exact</code>. TODO: documentation</li><li><strong><code>RPAHelper</code></strong> :  Helper struct generated by <a href="@ref setup_RPA"><code>setup_RPA</code></a>.</li><li><strong><code>β</code></strong>         : <code>Float64</code>, Inverse temperature in natural units</li><li><strong><code>kG</code></strong>        : <code>KGrid</code>,   The k-grid on which to perform the calculation</li><li><strong><code>sP</code></strong>        : <code>SimulationParameters</code>, (to construct a frequency range)</li><li><strong><code>mode</code></strong>      : selects particle-hole (<code>:ph</code>, default) or particle-particle (<code>:pp</code>) notation </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/BSETools.jl#LL124-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_bubble_par-Tuple{lDΓAHelper}" href="#LadderDGA.calc_bubble_par-Tuple{lDΓAHelper}"><code>LadderDGA.calc_bubble_par</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_bubble_par(h::lDΓAHelper; collect_data=true)
calc_bubble_par(kG::KGrid, mP::ModelParameters, sP::SimulationParameters; collect_data=true)</code></pre><p>Calculates the bubble, based on two fourier-transformed Greens functions where the second one has to be reversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools.jl#LL36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_gen_χ-Tuple{Array{ComplexF64, 3}, χ₀T, Dispersions.KGrid}" href="#LadderDGA.calc_gen_χ-Tuple{Array{ComplexF64, 3}, χ₀T, Dispersions.KGrid}"><code>LadderDGA.calc_gen_χ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_gen_χ(Γr::ΓT, χ₀::χ₀T, kG::KGrid)</code></pre><p>Calculates generalized susceptibility from <code>Γr</code> by solving the Bethe Salpeter Equation.  See <a href="#LadderDGA.calc_χγ-Tuple{Symbol, lDΓAHelper, χ₀T}"><code>calc_χγ</code></a> for direct (and more efficient) calculation of physical susceptibility and triangular vertex.</p><p>Returns: <span>$\chi^{\nu\nu&#39;\omega}_q$</span> as 4-dim array with axis: <code>νi, νpi, qi, ωi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/BSETools.jl#LL290-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_Γs_ud-Tuple{Any, Any, Any, lDΓAHelper, OffsetArrays.OffsetMatrix{T} where T}" href="#LadderDGA.calc_Γs_ud-Tuple{Any, Any, Any, lDΓAHelper, OffsetArrays.OffsetMatrix{T} where T}"><code>LadderDGA.calc_Γs_ud</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_Γs_ud(Fm, Fd, Phi_ud, h::lDΓAHelper)</code></pre><p>Calculates the Γs in particle-particle notation from the ladder vertices.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LinearizedEliashberg.jl#LL106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_Σ-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}" href="#LadderDGA.calc_Σ-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.calc_Σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_Σ(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::λ₀T, h::lDΓAHelper;
       νmax=eom_ν_cutoff(h), λm::Float64=0.0, λd::Float64=0.0, tc::Bool=true)
calc_Σ(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::λ₀T, gLoc_rfft, h; 
       νmax::Int=eom_ν_cutoff(h), λm::Float64 = 0.0, λd::Float64 = 0.0, tc::Bool = true)
calc_Σ(χm::χT, γm::γT, χd::χT, γd::γT, χ_m_sum::Union{Float64,ComplexF64}, λ₀::λ₀T,
       Gνω::GνqT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; 
       νmax=eom_ν_cutoff(sP), λm::Float64=0.0, λd::Float64=0.0, tc::Bool=true)</code></pre><p>Calculates the self-energy from ladder quantities.</p><p>This is the single core variant, see <a href="#LadderDGA.calc_Σ_par-Tuple{}"><code>calc_Σ_par</code></a> for the parallel version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools_singleCore.jl#LL150-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_Σ_eom_par-Tuple{Float64, Float64}" href="#LadderDGA.calc_Σ_eom_par-Tuple{Float64, Float64}"><code>LadderDGA.calc_Σ_eom_par</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_Σ_eom_par(νmax::Int)</code></pre><p>Equation of motion for self energy. See <a href="#LadderDGA.calc_Σ_par-Tuple{}"><code>calc_Σ_par</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools.jl#LL178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_Σ_par-Tuple{}" href="#LadderDGA.calc_Σ_par-Tuple{}"><code>LadderDGA.calc_Σ_par</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_Σ_par(; λm::Float64=0.0, λd::Float64=0.0, collect_data=true, tc::Bool=true)</code></pre><p>Calculates self-energy on worker pool. Workers must first be initialized using <a href="#LadderDGA.initialize_EoM-Tuple{lDΓAHelper, Array{ComplexF64, 3}, AbstractVector{Int64}}"><code>initialize_EoM</code></a>. #TODO: νrange must be equal to the one used during initialization. remove one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools.jl#LL231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_Σ_parts-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, lDΓAHelper}" href="#LadderDGA.calc_Σ_parts-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, lDΓAHelper}"><code>LadderDGA.calc_Σ_parts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_Σ_parts(χm::χT,γm::γT,χd::χT,γd::γT,h::lDΓAHelper,λ₀::AbstractArray{ComplexF64,3};λm::Float64=0.0, λd::Float64=0.0)
calc_Σ_parts(χm::χT,γm::γT, χd::χT, γd::γT, χ_m_sum::Union{Float64,ComplexF64}, λ₀::λ₀T,
             Gνω::GνqT, kG::KGrid,mP::ModelParameters, sP::SimulationParameters;
             λm::Float64=0.0, λd::Float64=0.0)</code></pre><p>Calculates the <span>$lD\GammaA$</span> self-energy (see also <a href="#LadderDGA.calc_Σ-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>calc_Σ</code></a>), but split into <code>7</code> contributions from: <code>χm</code>, <code>γm</code>, <code>χd</code>, <code>γd</code>, <code>U</code>, <code>Fm</code> + <code>Σ_hartree</code>, <code>tail_correction</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools_singleCore.jl#LL196-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_λ0-Tuple{χ₀RPA_T, RPAHelper}" href="#LadderDGA.calc_λ0-Tuple{χ₀RPA_T, RPAHelper}"><code>LadderDGA.calc_λ0</code></a> — <span class="docstring-category">Method</span></header><section><div><p>calc<em>λ0(χ₀::χ₀RPA</em>T, helper::RPAHelper) calc<em>λ0(χ₀::χ₀RPA</em>T, sP::SimulationParameters, mP::ModelParameters)</p><p>This function corresponds to the following mapping</p><pre><code class="nohighlight hljs">λ0: BZ × π(2N + 1)/β × 2πN/β → C, (q, ν, ω)↦ -U χ₀(q,ω)

where ...
    ... U is the Hubbard on-site interaction parameter
    ... χ₀ is the RPA bubble term</code></pre><p>TODO: λ0 is constant in the fermionic matsubara frequency. This should be refactured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/RPATools_singleCore.jl#LL81-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_λ0-Tuple{χ₀T, lDΓAHelper}" href="#LadderDGA.calc_λ0-Tuple{χ₀T, lDΓAHelper}"><code>LadderDGA.calc_λ0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_λ0(χ₀::χ₀T, h::lDΓAHelper)
calc_λ0(χ₀::χ₀T, Fr::FT, h::lDΓAHelper)
calc_λ0(χ₀::χ₀T, Fr::FT, χ::χT, γ::γT, mP::ModelParameters, sP::SimulationParameters)</code></pre><p>Correction term, TODO: documentation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools_singleCore.jl#LL58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_λmax_linEliashberg-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}" href="#LadderDGA.calc_λmax_linEliashberg-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}"><code>LadderDGA.calc_λmax_linEliashberg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_λmax_linEliashberg(bubble::χ₀T, χm::χT, χd::χT, γm::γT, γd::γT, h::lDΓAHelper, env;
                         GF=h.gLoc, max_Nk::Int=h.kG.Ns, χm_star_gen=nothing, χd_star_gen=nothing)</code></pre><p>Calculates largest and smallest (real) eigen value of <span>$\Gamma_{\mathrm{s},\uparrow\downarrow}$</span>.</p><p>TODO: TeX/DOCU...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LinearizedEliashberg.jl#LL74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_λmax_linEliashberg_MatrixFree-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}" href="#LadderDGA.calc_λmax_linEliashberg_MatrixFree-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}"><code>LadderDGA.calc_λmax_linEliashberg_MatrixFree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_λmax_linEliashberg_MatrixFree(bubble::χ₀T, χm::χT, χd::χT, γm::γT, γd::γT, h::lDΓAHelper)</code></pre><p>This is a slower, but memory efficient versuion of <a href="#LadderDGA.calc_λmax_linEliashberg-Tuple{χ₀T, χT, χT, γT, γT, lDΓAHelper, Any}"><code>calc_λmax_linEliashberg</code></a>.</p><p>TODO: TeX/DOCU...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LinearizedEliashberg.jl#LL169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_χγ-Tuple{Symbol, lDΓAHelper, χ₀T}" href="#LadderDGA.calc_χγ-Tuple{Symbol, lDΓAHelper, χ₀T}"><code>LadderDGA.calc_χγ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_χγ(type::Symbol, h::lDΓAHelper, χ₀::χ₀T)
calc_χγ(type::Symbol, Γr::ΓT, χ₀::χ₀T, kG::KGrid, mP::ModelParameters, sP::SimulationParameters)</code></pre><p>Calculates susceptibility and triangular vertex in <code>type</code> channel. See <a href="#LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}"><code>calc_χγ_par</code></a> for parallel calculation.</p><p>This method solves the following equation: `` \chi<em>r = \chi</em>0 - \frac{1}{\beta^2} \chi<em>0 \Gamma</em>r \chi<em>r \
\Leftrightarrow (1 + \frac{1}{\beta^2} \chi</em>0 \Gamma<em>r) = \chi</em>0 \
\Leftrightarrow (\chi^{-1}<em>r - \chi^{-1}</em>0) = \frac{1}{\beta^2} \Gamma_r ``</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/BSETools.jl#LL203-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_χγ-Tuple{Symbol, χ₀RPA_T, ModelParameters, SimulationParameters}" href="#LadderDGA.calc_χγ-Tuple{Symbol, χ₀RPA_T, ModelParameters, SimulationParameters}"><code>LadderDGA.calc_χγ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_χγ(type::Symbol, χ₀::χ₀RPA_T, kG::KGrid, mP::ModelParameters)

This function corresponds to the following mappings

    χ: BZ × 2πN/β → R, (q, ω)↦ χ₀(q,ω) / ( 1 + U_r⋅χ₀(q,ω) )
    
    γ: BZ × π(2N + 1)/β × 2πN/β → C, (q, ν, ω)↦ 1

    where ...
        ... U_r is the Hubbard on-site interaction parameter multiplied by +1 if type = d and -1 if type = m.
        ... χ₀ is the RPA bubble term
        ... ν is a fermionic matsubara frequency
        ... ω is a bosonic matsubara frequency
        ... N is the set of natural numbers
        ... β is the inverse temperature
        ... q is a point in reciprocal space</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/RPATools_singleCore.jl#LL45-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}" href="#LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}"><code>LadderDGA.calc_χγ_par</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_χγ_par(type::Symbol, h::lDΓAHelper)
calc_χγ_par(type::Symbol, Γr::ΓT, kG::KGrid, mP::ModelParameters, sP::SimulationParameters; collect_data=true)</code></pre><p>Calculate susceptibility and triangular vertex parallel on workerpool. </p><p>Set <code>collect_data</code> to return both quantities, or call <a href="#LadderDGA.collect_χ-Tuple{Symbol, lDΓAHelper}"><code>collect_χ</code></a> and <a href="#LadderDGA.collect_γ-Tuple{Symbol, Dispersions.KGrid, ModelParameters, SimulationParameters}"><code>collect_γ</code></a> at a later point. <a href="#LadderDGA.calc_χγ-Tuple{Symbol, lDΓAHelper, χ₀T}"><code>calc_χγ</code></a> can be used for single core computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools.jl#LL121-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.clear_wcache!-Tuple{}" href="#LadderDGA.clear_wcache!-Tuple{}"><code>LadderDGA.clear_wcache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_wcache!()</code></pre><p>Clears cache on all workers. Must be used when recalculating susceptibilities after EoM initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL329-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.collect_Σ!-Tuple{OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}}" href="#LadderDGA.collect_Σ!-Tuple{OffsetArrays.OffsetMatrix{ComplexF64, Matrix{ComplexF64}}}"><code>LadderDGA.collect_Σ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect_Σ!(Σ_ladder::OffsetMatrix{ComplexF64, Matrix{ComplexF64}}, mP::ModelParameters; λm=0.0)</code></pre><p>Collects self-energy from workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools.jl#LL210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.collect_γ-Tuple{Symbol, Dispersions.KGrid, ModelParameters, SimulationParameters}" href="#LadderDGA.collect_γ-Tuple{Symbol, Dispersions.KGrid, ModelParameters, SimulationParameters}"><code>LadderDGA.collect_γ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect_γ(type::Symbol, [kG::KGrid, mP::ModelParameters, sP::SimulationParameters] OR [h::lDΓAHelper])</code></pre><p>Collects triangular vertex from workers, after parallel computation (see <a href="#LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}"><code>calc_χγ_par</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL417-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.collect_χ-Tuple{Symbol, lDΓAHelper}" href="#LadderDGA.collect_χ-Tuple{Symbol, lDΓAHelper}"><code>LadderDGA.collect_χ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect_χ(type::Symbol, [kG::KGrid, mP::ModelParameters, sP::SimulationParameters] OR [h::lDΓAHelper])</code></pre><p>Collects susceptibility from workers, after parallel computation (see <a href="#LadderDGA.calc_χγ_par-Tuple{Symbol, lDΓAHelper}"><code>calc_χγ_par</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL378-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.collect_χ₀-Tuple{lDΓAHelper}" href="#LadderDGA.collect_χ₀-Tuple{lDΓAHelper}"><code>LadderDGA.collect_χ₀</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect_χ₀(kG::KGrid, mP::ModelParameters, sP::SimulationParameters)</code></pre><p>Collect non-local bubble <span>$\chi_0^{\omega}(q)$</span> from workers. Values first need to be calculated using <a href="#LadderDGA.calc_bubble_par-Tuple{lDΓAHelper}"><code>calc_bubble_par</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools.jl#LL58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.conv_tmp_add_rpa!-Union{Tuple{N}, Tuple{AbstractVector{ComplexF64}, Dispersions.KGrid, AbstractArray{ComplexF64, N}}} where N" href="#LadderDGA.conv_tmp_add_rpa!-Union{Tuple{N}, Tuple{AbstractVector{ComplexF64}, Dispersions.KGrid, AbstractArray{ComplexF64, N}}} where N"><code>LadderDGA.conv_tmp_add_rpa!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conv_tmp_add_rpa!(res::AbstractVector{ComplexF64}, kG::KGrid, arr1::Vector{ComplexF64}, GView::AbstractArray{ComplexF64,N})::Nothing where N</code></pre><p>Expect both input arrays already in fouriertransformed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools.jl#LL159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.core-Tuple{χ₀T}" href="#LadderDGA.core-Tuple{χ₀T}"><code>LadderDGA.core</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">core(χ₀::χ₀T)</code></pre><p>Select core region (without asymptotic shell) from bubble term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.core_sum_bosonic-Tuple{Int64, Float64, Int64}" href="#LadderDGA.core_sum_bosonic-Tuple{Int64, Float64, Int64}"><code>LadderDGA.core_sum_bosonic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">core_sum_bosonic(N::Int, β::Float64, power::Int)</code></pre><p>Fast evaluation of <span>$\sum_{n=1}^N \frac{1}{(\pi i (2n) / \beta)^l}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL381-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.core_sum_fermionic-Tuple{Int64, Float64, Int64}" href="#LadderDGA.core_sum_fermionic-Tuple{Int64, Float64, Int64}"><code>LadderDGA.core_sum_fermionic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">core_sum_fermionic(N::Int, β::Float64, power::Int)</code></pre><p>Fast evaluation of <span>$\sum_{n=0}^N \frac{1}{(\pi i (2n+1) / \beta)^l}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL373-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.correction_term-Tuple{ModelParameters, Dispersions.KGrid, χT, Union{Float64, ComplexF64}, AbstractVector{Int64}}" href="#LadderDGA.correction_term-Tuple{ModelParameters, Dispersions.KGrid, χT, Union{Float64, ComplexF64}, AbstractVector{Int64}}"><code>LadderDGA.correction_term</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">correction_term(mP::ModelParameters, kG::KGrid, χm::χT, χ_m_sum::Union{Float64,ComplexF64}, grid::AbstractArray{Int64,1})</code></pre><p>Calculates the so called tail correcion term of the ladder self energy. The purpose of this term is to enforce the limit</p><p><code>\lim_{n\rightarrow\infty}i\nu_n\Sigma_{\mathbf{q}}^{\nu_n}=U^2\frac{n}{2}\left(1-\frac{n}{2} \right )</code>.</p><p>This can be archived by adding the term     * RPA: <code>-\frac{U^2}{i\nu}\sum_{\omega,\mathbf{q}}\left( \chi_{m,\mathbf{q}}^{\omega}-\chi_{0,\mathbf{q}}^{\omega}\right )</code>     * ladder-DGA: <code>-\frac{U^2}{i\nu}\left(\sum_{\omega,\mathbf{q}}\chi_{m,\mathbf{q}}^{\omega}-\chi_{m,loc} \right )</code> from the ladder self energy.</p><p><strong>Arguments</strong></p><ul><li><strong><code>mP</code></strong>         : ModelParameters</li><li><strong><code>kG</code></strong>         : KGrid</li><li><strong><code>χm</code></strong>         : χT</li><li><strong><code>χ_m_sum</code></strong>    : Union{Float64,ComplexF64}. RPA: <code>\sum_{\omega,\mathbf{q}}\chi_{0,\mathbf{q}}^{\omega}</code>, lDGA: &#39;χ<em>m</em>sum&#39;.</li><li><strong><code>grid</code></strong>       : AbstractArray{Int64,1}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools_singleCore.jl#LL34-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.eom_ν_cutoff-Tuple{Int64, Bool}" href="#LadderDGA.eom_ν_cutoff-Tuple{Int64, Bool}"><code>LadderDGA.eom_ν_cutoff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eom_ν_cutoff(Niν::Int, grid_shifted::Bool)::Int
eom_ν_cutoff(sP::SimulationParameters)
eom_ν_cutoff(h::lDΓAHelper)</code></pre><p>Returns number of positive fermionic frequencies to be used in self-energy after calculation of EoM (as a function of available positive frequency from DMFT <code>Niν</code>).</p><p>This is especially necessary for shifted grids, since there fewer bosonic frequencies available for large ν, leading to an error in the high frequency tail of the self energy. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/numerical_parameters.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.estimate_connected_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}" href="#LadderDGA.estimate_connected_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}"><code>LadderDGA.estimate_connected_ef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimate_connected_ef(Σ_ladder::OffsetMatrix, kG::KGrid, μ::Float64, β::Float64; ν0_estimator::Function=lin_fit)</code></pre><p>Estimates connected fermi surface. See also <a href="#LadderDGA.estimate_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}"><code>estimate_ef</code></a> and <a href="#LadderDGA.fermi_surface_connected-Tuple{BitVector, Dispersions.KGrid}"><code>fermi_surface_connected</code></a>. Returns fermi surface indices and <code>relax_zero_condition</code> (values substantially larger than <code>1</code> indicate appearance of fermi arcs).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL478-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.estimate_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}" href="#LadderDGA.estimate_ef-Tuple{OffsetArrays.OffsetMatrix{T} where T, Dispersions.KGrid, Float64, Float64}"><code>LadderDGA.estimate_ef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">estimate_ef(Σ_ladder::OffsetMatrix, kG::KGrid, μ::Float64, β::Float64; ν0_estimator::Function=lin_fit, relax_zero_condition::Float64=10.0)</code></pre><p>Estimate fermi surface of <code>Σ_ladder</code>, using extrapolation to <span>$\nu = 0$</span> with the function <code>ν0_estimator</code> and the condition <span>$\lim_{\nu \to 0} \Sigma (\nu, k_f) = \mu - \epsilon_{k_f}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL461-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.expand_ω-Tuple{Any}" href="#LadderDGA.expand_ω-Tuple{Any}"><code>LadderDGA.expand_ω</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expand_ω(χ₀qω)

Helper function for reading RPA input. It holds χ₀(q,ω)=χ₀(q,-ω). Take an array for χ₀(q,ω) with ω-integers {0, 1, ..., m} and map onto array with ω-integers {-m, -(m-1), ..., -1, 0, 1, ..., m-1, m}.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO_RPA.jl#LL86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.fermi_surface_connected-Tuple{BitVector, Dispersions.KGrid}" href="#LadderDGA.fermi_surface_connected-Tuple{BitVector, Dispersions.KGrid}"><code>LadderDGA.fermi_surface_connected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fermi_surface_connected(ef_ind::BitVector, kG::KGrid, D::Int)</code></pre><p>Checks for connected fermi surface of <code>kG</code> dimensions, given a <code>BitVector</code> of points on the fermi surface. Returns <code>&lt; 0</code> if fermi surface is not connected, <code>== 0</code> if it is exactly a line, <code>&gt; 0</code> if the line is multiple points thick.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL446-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.filling-Tuple{AbstractVector{ComplexF64}, Float64}" href="#LadderDGA.filling-Tuple{AbstractVector{ComplexF64}, Float64}"><code>LadderDGA.filling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filling(G::Vector{ComplexF64}, [kG::KGrid, ] β::Float64)
filling(G::Vector, U::Float64, μ::Float64, β::Float64, [shell::Float64])</code></pre><p>Computes filling of (non-) local Green&#39;s function.</p><p>If <code>U</code>, <code>μ</code> and <code>β</code> are provided, asymptotic corrections are used. The shell sum can be precomputed using <a href="#LadderDGA.shell_sum_fermionic-Tuple{Int64, Float64, Int64}"><code>shell_sum_fermionic</code></a> If <code>G</code> is defined only over positive Matsubara frequencies <a href="#LadderDGA.filling_pos-Tuple{AbstractVector{ComplexF64}, Vararg{Float64, 4}}"><code>filling_pos</code></a> can be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL291-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.filling_pos-Tuple{AbstractVector{ComplexF64}, Vararg{Float64, 4}}" href="#LadderDGA.filling_pos-Tuple{AbstractVector{ComplexF64}, Vararg{Float64, 4}}"><code>LadderDGA.filling_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filling_pos(G::Vector, U::Float64, μ::Float64, β::Float64[, shell::Float64, improved_sum::Bool=true])::Float64
filling_pos(G::AbstractMatrix{ComplexF64},kG::KGrid,U::Float64,μ::Float64,β::Float64; improved_sum::Bool = true)::Float64
filling_pos(G::AbstractMatrix{ComplexF64},kG::KGrid,)::Float64</code></pre><p>Returns filling from <code>G</code> only defined over positive Matsubara frequencies.  See <a href="#LadderDGA.filling-Tuple{AbstractVector{ComplexF64}, Float64}"><code>filling</code></a> for further documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL327-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.filter_KZ-Union{Tuple{T}, Tuple{Int64, Int64, AbstractVector{T}}} where T&lt;:Number" href="#LadderDGA.filter_KZ-Union{Tuple{T}, Tuple{Int64, Int64, AbstractVector{T}}} where T&lt;:Number"><code>LadderDGA.filter_KZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_KZ(m::Int, k::Int, X::AbstractArray{T,1}) where T &lt;: Number</code></pre><p>Iterated moving average noise filter for inut data. See also <a href="#LadderDGA.filter_MA-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}}} where T&lt;:Number"><code>filter_MA</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.filter_MA-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}}} where T&lt;:Number" href="#LadderDGA.filter_MA-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}}} where T&lt;:Number"><code>LadderDGA.filter_MA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">filter_MA(m::Int, X::AbstractArray{T,1}) where T &lt;: Number
filter_MA!(res::AbstractArray{T,1}, m::Int, X::AbstractArray{T,1}) where T &lt;: Number</code></pre><p>Iterated moving average noise filter for inut data. See also <a href="#LadderDGA.filter_KZ-Union{Tuple{T}, Tuple{Int64, Int64, AbstractVector{T}}} where T&lt;:Number"><code>filter_KZ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}" href="#LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}"><code>LadderDGA.find_usable_χ_interval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_usable_χ_interval(χ_ω::Array{Float64,1/2}; sum_type::Union{Symbol,Tuple{Int,Int}}=:common, reduce_range_prct::Float64 = 0.1)</code></pre><p>Determines usable range for physical susceptibilities <span>$\chi^\omega$</span> or <span>$\chi^\omega$</span> and additionally cut away <code>reduce_range_prct</code> % of the range. The unusable region is given whenever the susceptibility becomes negative, or the first derivative changes sign.</p><p><strong>Returns:</strong></p><p><code>range::AbstractVector{Float64}</code> : Usable <span>$\omega$</span> range for <span>$\chi$</span></p><p><strong>Arguments:</strong></p><ul><li><strong><code>χ_ω</code></strong>                : <span>$\chi^\omega$</span> </li><li><strong><code>sum_type</code></strong>           : Optional, default <code>:common</code>. Can be set to <code>:full</code> to enforce full range, or a <code>::Tuple{Int,Int}</code> to enforce a specific interval size.</li><li><strong><code>reduce_range_prct</code></strong>  : Optional, default <code>0.1</code>. After finding the usable interval it is reduced by an additional percentage given by this value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFFit.jl#LL15-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.gen_ν_part-Tuple{AbstractArray{Int64}, SimulationParameters, Int64}" href="#LadderDGA.gen_ν_part-Tuple{AbstractArray{Int64}, SimulationParameters, Int64}"><code>LadderDGA.gen_ν_part</code></a> — <span class="docstring-category">Method</span></header><section><div><p>gen<em>ν</em>part(νGrid::AbstractVector{Int}, sP::SimulationParameters, N::Int)</p><p>Returns partition of fermionic frequencies grid, according to the number of workers <code>N</code>. The partition is given as a list (of length <code>N</code>) of lists with 4-Tuples <code>(ωi, ωn, νi, νn)</code>.  <code>νi</code> and <code>ωi</code> are the indices for the Matsubara frequencies <code>νn</code> and <code>ωn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.gen_ν_part_slices-Tuple{Array{ComplexF64, 3}, Vector{NTuple{4, Int64}}}" href="#LadderDGA.gen_ν_part_slices-Tuple{Array{ComplexF64, 3}, Vector{NTuple{4, Int64}}}"><code>LadderDGA.gen_ν_part_slices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_ν_part_slices(data::Array{ComplexF64,3}, index_list::Vector{NTuple{4,Int}})</code></pre><p>Rearragnes data over <code>q</code>, <code>ν</code> and <code>ω</code> axes, for EoM (see <a href="#LadderDGA.calc_Σ_par-Tuple{}"><code>calc_Σ_par</code></a>) given <code>index_list</code>, which is one element of the list of lists obtained from <a href="#LadderDGA.gen_ν_part-Tuple{AbstractArray{Int64}, SimulationParameters, Int64}"><code>gen_ν_part</code></a>.</p><p>Returns three arrays:      - data<em>res: Rearranged data, only containes values for ν, given in `index</em>list<code>, ω values not contained in</code>data<code>are set to 0.     - νn_list: Has length</code>size(data<em>res,3)`. Contained fermionic Matsubara frequency for each index.     - ωn</em>ranges: Has length <code>size(data_res,3)</code>. Containes bosonic Matsubara frequencies for each ν value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL70-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.gen_νω_part-Tuple{SimulationParameters, Int64}" href="#LadderDGA.gen_νω_part-Tuple{SimulationParameters, Int64}"><code>LadderDGA.gen_νω_part</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_νω_part(sP::SimulationParameters, N::Int)</code></pre><p>Returns partition of frequency grid, according to the number of workers <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.gen_ω_part-Tuple{SimulationParameters, Int64}" href="#LadderDGA.gen_ω_part-Tuple{SimulationParameters, Int64}"><code>LadderDGA.gen_ω_part</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_ω_part(sP::SimulationParameters, N::Int)</code></pre><p>Returns partition of bosonic frequencies grid, according to the number of workers <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.initialize_EoM-Tuple{lDΓAHelper, Array{ComplexF64, 3}, AbstractVector{Int64}}" href="#LadderDGA.initialize_EoM-Tuple{lDΓAHelper, Array{ComplexF64, 3}, AbstractVector{Int64}}"><code>LadderDGA.initialize_EoM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function initialize_EoM([G_fft_reverse, λ₀::Array{ComplexF64,3}, νGrid::AbstractVector{Int}, 
                    kG::KGrid, mP::ModelParameters, sP::SimulationParameters]; 
                    OR [h::lDΓAHelper, λ₀, νGrid];
                    force_reinit = false,
                    χm::χT = collect_χ(:sp, kG, mP, sP),
                    γm::γT = collect_γ(:sp, kG, mP, sP),
                    χd::χT = collect_χ(:ch, kG, mP, sP),
                    γd::γT = collect_γ(:ch, kG, mP, sP))</code></pre><p>Worker cache initialization. Must be called before <a href="#LadderDGA.calc_Σ_par-Tuple{}"><code>calc_Σ_par</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL205-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.initialize_EoM_cache!-Tuple{Int64}" href="#LadderDGA.initialize_EoM_cache!-Tuple{Int64}"><code>LadderDGA.initialize_EoM_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_EoM_cache!()</code></pre><p>Initializes cache to correct size. <code>kG</code> and <code>sP</code> must be set first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.is_okay-Tuple{Any}" href="#LadderDGA.is_okay-Tuple{Any}"><code>LadderDGA.is_okay</code></a> — <span class="docstring-category">Method</span></header><section><div><p>is_okay(χ₀qω)</p><p>check whether the given χ₀qω Array satisfies a set of expected conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO_RPA.jl#LL11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.iν_array-Tuple{Real, AbstractVector{Int64}}" href="#LadderDGA.iν_array-Tuple{Real, AbstractVector{Int64}}"><code>LadderDGA.iν_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iν_array(β::Real, grid::AbstractArray{Int64,1})::Vector{ComplexF64}
iν_array(β::Real, size::Int)::Vector{ComplexF64}</code></pre><p>Computes list of fermionic Matsubara frequencies. If length <code>size</code> is given, the grid will have indices <code>0:size-1</code>. Bosonic arrays can be generated with <a href="#LadderDGA.iω_array-Tuple{Real, AbstractVector{Int64}}"><code>iω_array</code></a>.</p><p><strong>Returns:</strong></p><p>Vector of fermionic Matsubara frequencies, given either a list of indices or a length. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL21-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.iω_array-Tuple{Real, AbstractVector{Int64}}" href="#LadderDGA.iω_array-Tuple{Real, AbstractVector{Int64}}"><code>LadderDGA.iω_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iω_array(β::Real, grid::AbstractArray{Int64,1})::Vector{ComplexF64}
iω_array(β::Real, size::Int)::Vector{ComplexF64}</code></pre><p>Computes list of bosonic Matsubara frequencies. If length <code>size</code> is given, the grid will have indices <code>0:size-1</code>. Fermionic arrays can be generated with <a href="#LadderDGA.iν_array-Tuple{Real, AbstractVector{Int64}}"><code>iν_array</code></a>.</p><p><strong>Returns:</strong></p><p>Vector of bosonic Matsubara frequencies, given either a list of indices or a length. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL37-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.log_q0_χ_check-Tuple{Dispersions.KGrid, SimulationParameters, AbstractMatrix{Float64}, Symbol}" href="#LadderDGA.log_q0_χ_check-Tuple{Dispersions.KGrid, SimulationParameters, AbstractMatrix{Float64}, Symbol}"><code>LadderDGA.log_q0_χ_check</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_q0_χ_check(kG::KGrid, sP::SimulationParameters, χ::AbstractArray{_eltype,2}, type::Symbol)</code></pre><p>TODO: documentation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.par_partition-Tuple{AbstractVector, Int64}" href="#LadderDGA.par_partition-Tuple{AbstractVector, Int64}"><code>LadderDGA.par_partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">par_partition(set::AbstractVector, N::Int)</code></pre><p>Returns list of indices for partition of <code>set</code> into <code>N</code> (almost) equally large segements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.printr_s-Tuple{ComplexF64}" href="#LadderDGA.printr_s-Tuple{ComplexF64}"><code>LadderDGA.printr_s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printr_s(x::ComplexF64)
printr_s(x::Float64)</code></pre><p>prints 4 digits of (the real part of) <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO.jl#LL131-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.q0_index-Tuple{Dispersions.KGrid}" href="#LadderDGA.q0_index-Tuple{Dispersions.KGrid}"><code>LadderDGA.q0_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">q0_index(kG::KGrid)</code></pre><p>Index of zero k-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.readConfig-Tuple{String}" href="#LadderDGA.readConfig-Tuple{String}"><code>LadderDGA.readConfig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readConfig(cfg_in::String)</code></pre><p>Reads a config.toml file either as string or from a file and returns      - workerpool     - <a href="#LadderDGA.ModelParameters"><code>ModelParameters</code></a>     - <a href="#LadderDGA.SimulationParameters"><code>SimulationParameters</code></a>     - <a href="#LadderDGA.EnvironmentVars"><code>EnvironmentVars</code></a>     - kGrid (see Dispersions.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO.jl#LL19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.readConfig_RPA-Tuple{String}" href="#LadderDGA.readConfig_RPA-Tuple{String}"><code>LadderDGA.readConfig_RPA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">readConfig_RPA(cfg_in::String)</code></pre><p>Reads a config.toml file either as string or from a file and returns      - workerpool     - <a href="@ref"><code>ModelParameter, &quot;../test/test_data/rpa_chi0_1.h5&quot;)     # χ₀ = read_χ₀_RPA(inputfile)s</code></a>     - <a href="#LadderDGA.SimulationParameters"><code>SimulationParameters</code></a>     - <a href="#LadderDGA.EnvironmentVars"><code>EnvironmentVars</code></a>     - kGrid (see Dispersions.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO_RPA.jl#LL117-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.readFortranχDMFT-Tuple{String}" href="#LadderDGA.readFortranχDMFT-Tuple{String}"><code>LadderDGA.readFortranχDMFT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Returns χ_DMFT[ω, ν, ν&#39;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO_legacy.jl#LL122-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.read_χ₀_RPA-Tuple{String, Int64}" href="#LadderDGA.read_χ₀_RPA-Tuple{String, Int64}"><code>LadderDGA.read_χ₀_RPA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_χ₀_RPA(file::String)

Nω :: Int, Number of positive bosonic frequencies to be used. Make sure that the given χ₀-file has at least this many bosonic frequencies!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO_RPA.jl#LL25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.reduce_range-Tuple{AbstractArray, Float64}" href="#LadderDGA.reduce_range-Tuple{AbstractArray, Float64}"><code>LadderDGA.reduce_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_range(range::AbstractArray, red_prct::Float64)</code></pre><p>Returns indices for 1D array slice, reduced by <code>red_prct</code> % (compared to initial <code>range</code>). Range is symmetrically reduced fro mstart and end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.setupConfig_RPA-Tuple{String, Int64, Float64, Float64, Float64, Float64, Float64, Float64, Int64, Int64, Int64, Bool}" href="#LadderDGA.setupConfig_RPA-Tuple{String, Int64, Float64, Float64, Float64, Float64, Float64, Float64, Int64, Int64, Int64, Bool}"><code>LadderDGA.setupConfig_RPA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setupConfig_RPA(KGridStr, Nk::Int)</code></pre><p>Sets up RPA calculation directly. Usually one should use <a href="#LadderDGA.readConfig_RPA-Tuple{String}"><code>readConfig_RPA</code></a> as entry point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/IO_RPA.jl#LL95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.setup_LDGA-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}" href="#LadderDGA.setup_LDGA-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}"><code>LadderDGA.setup_LDGA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setup_LDGA(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [;silent=false])</code></pre><p>Computes all needed objects for DΓA calculations.</p><p>Returns: <a href="#LadderDGA.lDΓAHelper"><code>lDΓAHelper</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/runHelpers.jl#LL81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.setup_LDGAa-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}" href="#LadderDGA.setup_LDGAa-Tuple{Tuple{String, Int64}, ModelParameters, SimulationParameters, EnvironmentVars}"><code>LadderDGA.setup_LDGAa</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setup_LDGAa(kGridStr::Tuple{String,Int}, mP::ModelParameters, sP::SimulationParameters, env::EnvironmentVars [;silent=false])</code></pre><p>Computes all needed objects for DΓA-asymptotic calculations.</p><p>Returns: <a href="@ref lDΓAaHelper"><code>lDΓAaHelper</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/runHelpers.jl#LL202-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.shell_sum_fermionic-Tuple{Int64, Float64, Int64}" href="#LadderDGA.shell_sum_fermionic-Tuple{Int64, Float64, Int64}"><code>LadderDGA.shell_sum_fermionic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shell_sum_fermionic(N::Int, β::Float64, power::Int)::Float64</code></pre><p>Calculate <span>$\frac{1}{\beta} \sum_{n \in \Omega_\mathrm{shell}} \frac{1}{(i \nu_n)^power}$</span> <code>N-1</code> is the largest frequency index (i.e. <span>$\sum_{n=-N}^(N-1)  u_n$</span> is in the core region)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL365-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.subtract_tail!-Tuple{AbstractVector, AbstractVector, Float64, Vector{ComplexF64}, Int64}" href="#LadderDGA.subtract_tail!-Tuple{AbstractVector, AbstractVector, Float64, Vector{ComplexF64}, Int64}"><code>LadderDGA.subtract_tail!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtract_tail!(outp::AbstractArray{T,1}, inp::AbstractArray{T,1}, c::Float64, iω::Array{ComplexF64,1}, power::Int) where T &lt;: Number</code></pre><p>subtract the c/(iω)^power high frequency tail from <code>inp</code> and store in <code>outp</code>. See also <a href="#LadderDGA.subtract_tail-Tuple{AbstractVector, Float64, Vector{ComplexF64}, Int64}"><code>subtract_tail</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL401-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.subtract_tail-Tuple{AbstractVector, Float64, Vector{ComplexF64}, Int64}" href="#LadderDGA.subtract_tail-Tuple{AbstractVector, Float64, Vector{ComplexF64}, Int64}"><code>LadderDGA.subtract_tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtract_tail(inp::AbstractArray{T,1}, c::Float64, iω::Array{ComplexF64,1}, power::Int) where T &lt;: Number</code></pre><p>subtract the <span>$\frac{c}{(i\omega)^\text{power}}$</span> high frequency tail from input array <code>inp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL390-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.sum_kω-Tuple{Dispersions.KGrid, Union{χT, χ₀RPA_T}}" href="#LadderDGA.sum_kω-Tuple{Dispersions.KGrid, Union{χT, χ₀RPA_T}}"><code>LadderDGA.sum_kω</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_kω(kG::kGrid, χ::χT; ωn_arr=ωn_grid(χ), force_full_range=false, [transform::Function])
sum_kω(kG::kGrid, χ::χT; ωn_arr=ωn_grid(χ), force_full_range=false, [λ::Float64])
sum_kω(kG::KGrid, χ::AbstractMatrix{Float64}, β::Float64, ωn2_tail::Vector{Float64}; transform=nothing)::Float64</code></pre><p>Returns <span>$\int_\mathrm{BZ} dk \sum_\omega \chi^\omega_k$</span>. The bosonic Matsubara grid can be precomputed and given with <code>ωn_arr</code> to increase performance.</p><p>TODO: for now this is only implemented for tail correction in the <span>$1 / \omega^2_n$</span> term! Sums first over k, then over ω (see also <a href="#LadderDGA.sum_ω-Tuple{χT}"><code>sum_ω</code></a>), see <a href="#LadderDGA.sum_kω-Tuple{Dispersions.KGrid, Union{χT, χ₀RPA_T}}"><code>sum_kω</code></a> for the reverse order (results can differ, due to inaccuracies in the asymptotic tail treatment). The transform function needs to have the signature <code>f(in::Float64)::Float64</code> and will be applied before summation. Alternatively, <code>λ</code> can be given directly as <code>Float64</code>, if the usual <a href="#LadderDGA.LambdaCorrection.χ_λ-Tuple{Float64, Float64}"><code>λ-correction</code></a> should be applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL269-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.sum_ω-Tuple{χT}" href="#LadderDGA.sum_ω-Tuple{χT}"><code>LadderDGA.sum_ω</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_ω(χ::χT)
sum_ω!(res::Vector{ComplexF64}, ωn_arr::Vector{ComplexF64}, χ::χT; force_full_range=false)::Nothing
sum_ω!(ωn_arr::Vector{T}, χ::AbstractVector{T}, tail_c::Vector{Float64}, β::Float64; force_full_range=false)::T where T &lt;: Union{Float64,ComplexF64}

Sums the physical susceptibility over all usable (if `force_full_range` is not set to `true`) bosonic frequencies, including improvd tail summation, if `χ.tail_c` is set.

WARNING: This function might be buggy!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL341-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.sum_ωk-Tuple{Dispersions.KGrid, χT}" href="#LadderDGA.sum_ωk-Tuple{Dispersions.KGrid, χT}"><code>LadderDGA.sum_ωk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_ωk(kG::KGrid, χ::χT; force_full_range=false)::Float64</code></pre><p>WARNING: This function is a non optimized debugging function! See <a href="#LadderDGA.sum_kω-Tuple{Dispersions.KGrid, Union{χT, χ₀RPA_T}}"><code>sum_kω</code></a>, which should return the same result if the asymptotics are captured correctly. Optional function <code>f</code> transforms <code>χ</code> before summation.</p><p>WARNING: This function might be buggy!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL322-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.tail_correction_term-Tuple{Float64, Float64, Vector{ComplexF64}}" href="#LadderDGA.tail_correction_term-Tuple{Float64, Float64, Vector{ComplexF64}}"><code>LadderDGA.tail_correction_term</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tail_correction_term(χm_nl::Float64, χm_loc::Float64, tail_factor::Vector{ComplexF64})

tail_correction_term(U::Float64, β::Float64, n::Float64, χm_nl::Float64, χm_loc::Float64,
                          Σ_loc::OffsetVector{ComplexF64}, iν::Vector{ComplexF64}; 
                          δ::Real=10.0*length(iν))</code></pre><p>Calculates correction term for high frequency behavior of self energy.</p><p><span>$w_\nu = e^{(-\Delta^2_{\nu}/\delta)}$</span> with <span>$\Delta_{\nu} = \nu \cdot \Sigma^\nu_\mathrm{DMFT} - U^2 \frac{n}{2} (1 - \frac{n}{2})$</span>. See also <a href="#LadderDGA.tail_factor-Tuple{Float64, Float64, Float64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Vector{ComplexF64}}"><code>tail_factor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools_singleCore.jl#LL261-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.tail_factor-Tuple{Float64, Float64, Float64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Vector{ComplexF64}}" href="#LadderDGA.tail_factor-Tuple{Float64, Float64, Float64, OffsetArrays.OffsetVector{ComplexF64, AA} where AA&lt;:AbstractVector{ComplexF64}, Vector{ComplexF64}}"><code>LadderDGA.tail_factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tail_factor(U::Float64, β::Float64, n::Float64, Σ_loc::OffsetVector{ComplexF64}, iν::Vector{ComplexF64}; 
                          δ::Real=min(0.01, 1 ./ length(iν)))</code></pre><p>Calculates the tail factor for <a href="#LadderDGA.tail_correction_term-Tuple{Float64, Float64, Vector{ComplexF64}}"><code>tail_correction_term</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools_singleCore.jl#LL249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.update_tail!-Tuple{Vector{Float64}}" href="#LadderDGA.update_tail!-Tuple{Vector{Float64}}"><code>LadderDGA.update_tail!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_tail!(coeffs::Vector{Float64})</code></pre><p>Updates the Ekin/ω^2 tail of physical susceptibilities on all workers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.update_tail!-Tuple{χT, Array{Float64}, Array{ComplexF64}}" href="#LadderDGA.update_tail!-Tuple{χT, Array{Float64}, Array{ComplexF64}}"><code>LadderDGA.update_tail!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_tail!(χ::χT, new_tail_c::Array{Float64}, ωnGrid::Array{ComplexF64})</code></pre><p>Updates the <span>$\frac{c_i}{\omega_n^i}$</span> tail for all coefficients given in <code>new_tail_c</code> (index 1 corresponds to <span>$i=0$</span>). #TODO: ONLY UPDATES 1/w^2 AT THE MOMENT!!!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL390-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.update_wcache!-Tuple{Symbol, Any}" href="#LadderDGA.update_wcache!-Tuple{Symbol, Any}"><code>LadderDGA.update_wcache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_wcache!(name::Symbol, val; override=true)</code></pre><p>Updates worker cache with given name and value. Typically used through <code>remotecall()</code> on specific worker.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/parallelization_helpers.jl#LL165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.usable_ωindices-Union{Tuple{N}, Tuple{SimulationParameters, Vararg{χT, N}}} where N" href="#LadderDGA.usable_ωindices-Union{Tuple{N}, Tuple{SimulationParameters, Vararg{χT, N}}} where N"><code>LadderDGA.usable_ωindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">usable_ωindices(sP::SimulationParameters, χ_sp::χT, χ_ch::χT)</code></pre><p>Helper function, returning the indices <code>n</code> for <span>$\omega_n$</span> ranges of multiple channels. If <code>dbg_full_eom_omega</code> is set to <code>true</code> in the config, the full range will be returned, otherwise an intersection of the usable ranges obtained from <a href="#LadderDGA.find_usable_χ_interval-Tuple{AbstractVector{Float64}}"><code>find_usable_χ_interval</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFFit.jl#LL85-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.Δ-Tuple{Vector{Float64}, Vector{Float64}, Vector{ComplexF64}}" href="#LadderDGA.Δ-Tuple{Vector{Float64}, Vector{Float64}, Vector{ComplexF64}}"><code>LadderDGA.Δ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Δ(ϵₖ::Vector{Float64}, Vₖ::Vector{Float64}, νₙ::Vector{ComplexF64})::Vector{ComplexF64}</code></pre><p>Computes hybridization function <span>$\Delta(i\nu_n) = \sum_k \frac{|V_k|^2}{\nu_n - \epsilon_k}$</span> from Anderson parameters (for example obtained through exact diagonalization).</p><p><strong>Returns:</strong></p><p>Hybridization function  over list of given fermionic Matsubara frequencies.</p><p><strong>Arguments:</strong></p><ul><li><strong><code>ϵₖ</code></strong> : list of bath levels</li><li><strong><code>Vₖ</code></strong> : list of hopping amplitudes</li><li><strong><code>νₙ</code></strong> : Vector of fermionic Matsubara frequencies, see also: <a href="#LadderDGA.iν_array-Tuple{Real, AbstractVector{Int64}}"><code>iν_array</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL54-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.Σ_Dyson-Tuple{Vector{ComplexF64}, Vector{ComplexF64}}" href="#LadderDGA.Σ_Dyson-Tuple{Vector{ComplexF64}, Vector{ComplexF64}}"><code>LadderDGA.Σ_Dyson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Σ_Dyson(GBath::Vector{ComplexF64}, GImp::Vector{ComplexF64})::Vector{ComplexF64}
Σ_Dyson!(Σ::Vector{ComplexF64}, GBath::Vector{ComplexF64}, GImp::Vector{ComplexF64})::Vector{ComplexF64}</code></pre><p>Calculates <span>$\Sigma = 1 / G_\text{bath} - 1 / G_\text{imp}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.Σ_hartree-Tuple{ModelParameters}" href="#LadderDGA.Σ_hartree-Tuple{ModelParameters}"><code>LadderDGA.Σ_hartree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Σ_hartree(mP::ModelParameters)</code></pre><p>Calculates the hartree term of the self energy</p><p><code>\Sigma_{hartree}=\frac{U\cdot n}{2}</code>.</p><p><strong>Arguments</strong></p><ul><li><strong><code>mP</code></strong> : ModelParameters</li></ul><p><strong>Returns</strong></p><p>Float64 : Hartree term </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/ladderDGATools_singleCore.jl#LL15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.λ_from_γ-Tuple{Symbol, γT, χT, Float64}" href="#LadderDGA.λ_from_γ-Tuple{Symbol, γT, χT, Float64}"><code>LadderDGA.λ_from_γ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ_from_γ(type::Symbol, γ::γT, χ::χT, U::Float64)</code></pre><p>TODO: documentation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/BSETools.jl#LL12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.ν0Index_of_ωIndex-Tuple{Int64, SimulationParameters}" href="#LadderDGA.ν0Index_of_ωIndex-Tuple{Int64, SimulationParameters}"><code>LadderDGA.ν0Index_of_ωIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ν0Index_of_ωIndex(ωi::Int[, sP])::Int</code></pre><p>Calculates index of zero fermionic Matsubara frequency (which may depend on the bosonic frequency).  <code>ωi</code> is the index (i.e. starting with 1) of the bosonic Matsubara frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.νi_health-Tuple{AbstractArray{Int64}, SimulationParameters}" href="#LadderDGA.νi_health-Tuple{AbstractArray{Int64}, SimulationParameters}"><code>LadderDGA.νi_health</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">νi_health(νGrid::AbstractArray{Int}, sP::SimulationParameters)</code></pre><p>Returns a list of available bosonic frequencies for each fermionic frequency, given in <code>νGrid</code>. This can be used to estimate the maximum number of usefull frequencies for the equation of motion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.νi_νngrid_pos-Tuple{Int64, Int64, SimulationParameters}" href="#LadderDGA.νi_νngrid_pos-Tuple{Int64, Int64, SimulationParameters}"><code>LadderDGA.νi_νngrid_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">νi_νngrid_pos(ωi::Int, νmax::Int, sP::SimulationParameters)</code></pre><p>Indices for positive fermionic Matsubara frequencies, depinding on <code>ωi</code>, the index of the bosonic Matsubara frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.νnGrid-Tuple{Int64, SimulationParameters}" href="#LadderDGA.νnGrid-Tuple{Int64, SimulationParameters}"><code>LadderDGA.νnGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">νnGrid(ωn::Int, sP::SimulationParameters)</code></pre><p>Calculates grid of fermionic Matsubara frequencies for given bosonic frequency <code>ωn</code> (including shift, if set through <code>sP</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.χ₀Asym-Tuple{Float64, Vector{Float64}, Float64, AbstractVector{Int64}, Int64, Bool, Float64}" href="#LadderDGA.χ₀Asym-Tuple{Float64, Vector{Float64}, Float64, AbstractVector{Int64}, Int64, Bool, Float64}"><code>LadderDGA.χ₀Asym</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">χ₀Asym(c1::Float64, c2::Vector{Float64}, c3::Float64, ωnGrid::AbstractVector{Int}, n_iν::Int, shift::Int, β::Float64)</code></pre><p>Builds asymtotic helper array. See <a href="#LadderDGA.calc_bubble-Tuple{Symbol, LadderDGA.RunHelper}"><code>calc_bubble</code></a> implementation for details.</p><p><code>c1</code>, <code>c2</code> and <code>c3</code> are the coefficients for the asymtotic tail expansion and can be obtained through <a href="#LadderDGA.χ₀Asym_coeffs-Tuple{Symbol, Dispersions.KGrid, ModelParameters}"><code>χ₀Asym_coeffs</code></a>. <code>n_iν</code> is the number of positive fermionic Matsubara frequencies, <code>shift</code> is either <code>1</code> or <code>0</code>, depending on the type of frequency grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.χ₀Asym_coeffs-Tuple{Symbol, Dispersions.KGrid, ModelParameters}" href="#LadderDGA.χ₀Asym_coeffs-Tuple{Symbol, Dispersions.KGrid, ModelParameters}"><code>LadderDGA.χ₀Asym_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">χ₀Asym_coeffs(type::Symbol, kG::KGrid, mP::ModelParameters; sVk=NaN)</code></pre><p>Builds tail coefficients for the χ₀ asymptotic helper, obtained through <a href="#LadderDGA.χ₀Asym-Tuple{Float64, Vector{Float64}, Float64, AbstractVector{Int64}, Int64, Bool, Float64}"><code>χ₀Asym</code></a>.</p><p>TODO: full documentation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.ω0_index-Tuple{SimulationParameters}" href="#LadderDGA.ω0_index-Tuple{SimulationParameters}"><code>LadderDGA.ω0_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ω0_index(sP::SimulationParameters)
ω0_index(χ::[χT or AbstractMatrix])</code></pre><p>Index of ω₀ frequency. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/helpers.jl#LL29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.ω2_tail-Tuple{χT}" href="#LadderDGA.ω2_tail-Tuple{χT}"><code>LadderDGA.ω2_tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ω2_tail(χ, h)</code></pre><p>Computes bosonic frequency tail for <code>χ</code>: <span>$\mathrm{tail}(n) = \frac{1}{(2 i \pi n / \beta)^2}$</span>. Sets <span>$\mathrm{tail}(n) = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL251-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.ω_tail-Tuple{χT, χT, AbstractVector{Float64}, SimulationParameters}" href="#LadderDGA.ω_tail-Tuple{χT, χT, AbstractVector{Float64}, SimulationParameters}"><code>LadderDGA.ω_tail</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ω_tail(ωindices::AbstractVector{Int}, coeffs::AbstractVector{Float64}, sP::SimulationParameters) 
ω_tail(χ_sp::χT, χ_ch::χT, coeffs::AbstractVector{Float64}, β::Float64, sP::SimulationParameters)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/GFTools.jl#LL416-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.ωn_grid-Tuple{Union{χT, χ₀RPA_T}}" href="#LadderDGA.ωn_grid-Tuple{Union{χT, χ₀RPA_T}}"><code>LadderDGA.ωn_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ωn_grid(χ::χT)</code></pre><p>Computes bosonic frequencies for <code>χ</code>: <span>$2 i \pi n / \beta$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/DataTypes.jl#LL243-L247">source</a></section></article><h2 id="LambdaCorrection"><a class="docs-heading-anchor" href="#LambdaCorrection">LambdaCorrection</a><a id="LambdaCorrection-1"></a><a class="docs-heading-anchor-permalink" href="#LambdaCorrection" title="Permalink"></a></h2><p>This sub-module contains function related to the <span>$\lambda$</span>-correction.</p><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λ_result" href="#LadderDGA.LambdaCorrection.λ_result"><code>LadderDGA.LambdaCorrection.λ_result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">λ_result</code></pre><p>Containes result and auxilliary information of λ correction, is returned by <a href="#LadderDGA.LambdaCorrection.λ_correction-Tuple{Symbol, χT, γT, χT, γT, Any, lDΓAHelper}"><code>λ_correction</code></a>, should not be constructed explicitly!</p><p><strong>Fields</strong></p><ul><li><strong><code>λm</code></strong>           : <code>Float64</code>, Magnetic channel correction parameter.</li><li><strong><code>λd</code></strong>           : <code>Float64</code>, Density channel correction parameter.</li><li><strong><code>type</code></strong>         : <code>CorrectionMethod</code>, Type of λ correction: <ul><li><code>:m</code>, only magnetic channel</li><li><code>:dm</code>, magnetic and density channel </li><li><code>:m_sc</code>, only magnetic channel, partial self-consistency in EoM </li><li><code>:dm_sc</code>, magnetic and density channel, partial self-consistency in EoM </li><li><code>:m_tsc</code>, only magnetic channel, partial self-consistency in EoM, updated kinetic energy term in susceptibility tail</li><li><code>:dm_tsc</code>, magnetic and density channel, partial self-consistency in EoM, updated kinetic energy term in susceptibility tail</li></ul></li><li><strong><code>sc_converged</code></strong> : <code>Bool</code>, convergence parameter for self-consistency methods. Always <code>True</code> for non self-consist methods. See also <a href="#LadderDGA.LambdaCorrection.sc_converged-Tuple{λ_result}"><code>sc_converged</code></a></li><li><strong><code>eps_abs</code></strong>      : <code>Float64</code>, Threshold for convergence. Convergence is assumed when the potential energies and Pauli principle values (depending on method both or one) are equal up to this value.</li><li><strong><code>sc_eps_abs</code></strong>   : <code>Float64</code>, Threshold for sc convergence. Convergence is assumed when the potential energies and Pauli principle values (for 1- and 2-particle quantities) individually change by less than <code>sc_eps_abs</code>.</li><li><strong><code>EKin</code></strong>         : <code>Float64</code>, 2-Particle kinetic energy</li><li><strong><code>EPot_p1</code></strong>      : <code>Float64</code>, 1-Particle potential energy, <span>$G^\mathbf{\lambda}_\mathrm{ladder} \Sigma^\mathbf{\lambda}_\mathrm{ladder}$</span>, see <a href="#LadderDGA.calc_E-Tuple{χT, γT, χT, γT, Any, Any, Any, Dispersions.KGrid, ModelParameters, SimulationParameters}"><code>calc_E</code></a></li><li><strong><code>EPot_p2</code></strong>      : <code>Float64</code>, 2-Particle potential energy, <span>$\frac{U}{2} \sum_{\omega,q} (\chi^{\lambda_\mathrm{d},\omega}_{\mathrm{d},q} - \chi^{\lambda_\mathrm{m},\omega}_{\mathrm{m},q} + U\frac{n^2}{2}$</span></li><li><strong><code>PP_p1</code></strong>        : <code>Float64</code>, 1-Particle Pauli principle, <span>$\frac{n}{2} (1 - \frac{n}{2})$</span></li><li><strong><code>PP_p2</code></strong>        : <code>Float64</code>, 2-Particle Pauli principle, <span>$\frac{1}{2} \sum_{\omega,q} (\chi^{\lambda_\mathrm{d},\omega}_{\mathrm{d},q} + \chi^{\lambda_\mathrm{m},\omega}_{\mathrm{m},q}$</span> </li><li><strong><code>trace</code></strong>        : <code>DataFrame/Nothing</code>, intermediate values of <code>λ_result</code> (<code>Σ_ladder</code> and <code>G_ladder</code> are only stored as checksums) for each self-consistency iteration.</li><li><strong><code>G_ladder</code></strong>     : <code>Nothing/OffsetMatrix</code>, Green&#39;s function after covnergence of λ-correction </li><li><strong><code>Σ_ladder</code></strong>     : <code>Nothing/OffsetMatrix</code>, self-energy after λ-correction </li><li><strong><code>μ</code></strong>            : <code>Float64</code>, chemical potential after λ-correction</li><li><strong><code>n</code></strong>            : <code>Float64</code>, electron density. This is used as check, μ should have been internally adjustet to keep this value fixed (i.e. <code>n ≈ n_dmft</code>)</li><li><strong><code>n_dmft</code></strong>       : <code>Float64</code>, input electron density</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/Types.jl#LL23-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λ_result-Tuple{Any, χT, γT, χT, γT, Array{ComplexF64, 3}, Float64, Float64, Bool, LadderDGA.RunHelper}" href="#LadderDGA.LambdaCorrection.λ_result-Tuple{Any, χT, γT, χT, γT, Array{ComplexF64, 3}, Float64, Float64, Bool, LadderDGA.RunHelper}"><code>LadderDGA.LambdaCorrection.λ_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ_result(χm::χT,γm::γT,χd::χT, γd::γT, λ₀::Array{ComplexF64,3}, λm, λd, h; 
              validation_threshold::Float64 = 1e-8, max_steps_m::Int = 2000)
λ_result(χm::χT,γm::γT,χd::χT, γd::γT, λ₀::Array{ComplexF64,3}, μ_new, G_ladder, Σ_ladder, λm, λd, h; 
              validation_threshold::Float64 = 1e-8, max_steps_m::Int = 2000)</code></pre><p>Constructs λ_result object, runs all checks and stores them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/Types.jl#LL85-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.EPot_diff-Tuple{λ_result}" href="#LadderDGA.LambdaCorrection.EPot_diff-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.EPot_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EPot_diff(result::λ_result)</code></pre><p>Difference between potential energies on one- and two particle level (may be negative if <code>EPot_p2 &gt; EPot_p1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/Types.jl#LL115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.PP_diff-Tuple{λ_result}" href="#LadderDGA.LambdaCorrection.PP_diff-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.PP_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PP_diff(result::λ_result)</code></pre><p>Difference between Pauli principle on one- and two particle level (may be negative if <code>PP_p2 &gt; PP_p1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/Types.jl#LL122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.bisect-NTuple{4, Float64}" href="#LadderDGA.LambdaCorrection.bisect-NTuple{4, Float64}"><code>LadderDGA.LambdaCorrection.bisect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bisect(λl::T, λm::T, λr::T, Fm::T)::Tuple{T,T} where T &lt;: Union{Float64, Vector{Float64}}</code></pre><p>WARNING: Not properly tested! Bisection root finding algorithm. This is a very crude adaption of the 1D case.  The root may therefore lie outside the given region and the search space has to be corrected using <a href="#LadderDGA.LambdaCorrection.correct_margins-NTuple{4, Float64}"><code>correct_margins</code></a>.</p><p><strong>Returns:</strong></p><p>(Vector of) new interval borders, according to <code>Fm</code>.</p><p><strong>Arguments:</strong></p><ul><li><strong><code>λl</code></strong> : (Vector of) left border(s) of bisection area</li><li><strong><code>λm</code></strong> : (Vector of) central border(s) of bisection area</li><li><strong><code>λr</code></strong> : (Vector of) right border(s) of bisection area</li><li><strong><code>Fm</code></strong> : (Vector of) Poincare-Miranda condition (s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/RootFinding.jl#LL12-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.calc_G_Σ-Tuple{χT, γT, χT, γT, AbstractArray{ComplexF64, 3}, Float64, Float64, LadderDGA.RunHelper}" href="#LadderDGA.LambdaCorrection.calc_G_Σ-Tuple{χT, γT, χT, γT, AbstractArray{ComplexF64, 3}, Float64, Float64, LadderDGA.RunHelper}"><code>LadderDGA.LambdaCorrection.calc_G_Σ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_G_Σ(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::AbstractArray{ComplexF64,3}, 
         λm::Float64, λd::Float64,
         h::RunHelper, sP::SimulationParameters, mP::ModelParameters; 
         tc::Bool = true, fix_n::Bool = true</code></pre><p>)</p><p>Returns <code>μ_new</code>, <code>G_ladder</code>, <code>Σ_ladder</code> with λ correction according to function parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/common.jl#LL78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.converged-Union{Tuple{λ_result{T}}, Tuple{T}} where T" href="#LadderDGA.LambdaCorrection.converged-Union{Tuple{λ_result{T}}, Tuple{T}} where T"><code>LadderDGA.LambdaCorrection.converged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">converged(r::λ_result, eps_abs::Float64=1e-6)</code></pre><p>Checks convergences for appropriate parameters of method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/Types.jl#LL136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.correct_margins-NTuple{4, Float64}" href="#LadderDGA.LambdaCorrection.correct_margins-NTuple{4, Float64}"><code>LadderDGA.LambdaCorrection.correct_margins</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">correct_margins(λl::T, λm::T, λr::T, Fm::T, Fr::T)::Tuple{T,T} where T &lt;: Union{Float64, Vector{Float64}}</code></pre><p>Helper method for <a href="#LadderDGA.LambdaCorrection.bisect-NTuple{4, Float64}"><code>bisect</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/RootFinding.jl#LL42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.dχ_λ-Tuple{Float64, Float64}" href="#LadderDGA.LambdaCorrection.dχ_λ-Tuple{Float64, Float64}"><code>LadderDGA.LambdaCorrection.dχ_λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dχ_λ(χ::[Float64,ComplexF64,AbstractArray], λ::Float64)</code></pre><p>First derivative of <a href="#LadderDGA.LambdaCorrection.χ_λ-Tuple{Float64, Float64}"><code>χ_λ</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/common.jl#LL55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.gen_νω_indices-Tuple{χT, χT, ModelParameters, SimulationParameters}" href="#LadderDGA.LambdaCorrection.gen_νω_indices-Tuple{χT, χT, ModelParameters, SimulationParameters}"><code>LadderDGA.LambdaCorrection.gen_νω_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gen_νω_indices(χ_m::χT, χ_d::χT, sP::SimulationParameters)</code></pre><p>Internal helper to generate usable bosonic and fermionic ranges. Also returns the <span>$c_1/x^2$</span> tail. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/helpers.jl#LL98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.get_λ_min-Tuple{AbstractMatrix{Float64}}" href="#LadderDGA.LambdaCorrection.get_λ_min-Tuple{AbstractMatrix{Float64}}"><code>LadderDGA.LambdaCorrection.get_λ_min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_λ_min(χr::AbstractArray{Float64,2})::Float64</code></pre><p>Computes the smallest possible <span>$\lambda$</span>-correction parameter (i.e. first divergence of <span>$\chi(q)$</span>), given as <span>$\lambda_\text{min} = - \min_{q}(1 / \chi^{\omega_0}_q)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/helpers.jl#LL87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.linear_approx-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T1, T2, T2, T2}} where {T1, T2}" href="#LadderDGA.LambdaCorrection.linear_approx-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T1, T2, T2, T2}} where {T1, T2}"><code>LadderDGA.LambdaCorrection.linear_approx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_approx(f1::T2, f2::T2, x1::T1, x2::T1, xm::T1) where {T1, T2}</code></pre><p>Linear approximation of function sampled at <code>f1 = f(x1)</code> and <code>f2 = f(x2)</code> at point <code>xm</code>, <code>x1</code> &lt;= <code>xm</code> &lt;= <code>x2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/helpers.jl#LL16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.n_diff-Tuple{λ_result}" href="#LadderDGA.LambdaCorrection.n_diff-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.n_diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_diff(result::λ_result)</code></pre><p>Difference between density before and after λ-correction (this should always be close to 0!) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/Types.jl#LL129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.newton-Tuple{Function, Function, Float64}" href="#LadderDGA.LambdaCorrection.newton-Tuple{Function, Function, Float64}"><code>LadderDGA.LambdaCorrection.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton(f::Function, df::Function, xi::Float64; nsteps::Int = 500, atol::Float64 = 1e-10)::Float64</code></pre><p>Normal Newton method, used for example by <a href="@ref newton_transformed"><code>newton_transformed</code></a> and <a href="#LadderDGA.LambdaCorrection.newton_secular-Tuple{Function, Function, Float64}"><code>newton_secular</code></a>.</p><p><code>xi</code> is the initial guess, for functions with multiple roots, the result will depend on this guess.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/RootFinding.jl#LL159-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.newton_right-Tuple{Function, Function, Float64, Float64}" href="#LadderDGA.LambdaCorrection.newton_right-Tuple{Function, Function, Float64, Float64}"><code>LadderDGA.LambdaCorrection.newton_right</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton_right(f::Function, [df::Function,] start::[Float64,Vector{Float64},MVector{Float64}], min::[Float64,Vector{Float64},MVector{Float64}]; nsteps=5000, atol=1e-11)</code></pre><p>Computes root of function <code>f</code> but under the condition that each compontent of the root is larger than the corresponding component of the start vector. This algorithm also assumes, that <code>f</code> is stricly monotonically decreasing in each component. <code>nsteps</code> sets the maximum number of newton-steps, <code>atol</code> sets the convergence tolerance. <code>df</code> can be omitted. In this case it is approximated using finite differences.</p><p>This is a legacy method. For better convergence performance and reliability please consider using <a href="#LadderDGA.LambdaCorrection.newton_secular-Tuple{Function, Function, Float64}"><code>newton_secular</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/RootFinding.jl#LL63-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.newton_secular-Tuple{Function, Function, Float64}" href="#LadderDGA.LambdaCorrection.newton_secular-Tuple{Function, Function, Float64}"><code>LadderDGA.LambdaCorrection.newton_secular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton_secularEq(f::Function, [df::Function,], pole::Float64)</code></pre><p>Computes largest root of function <code>f</code>, assuming it corresponds to a secular equaiton <span>$f(x) = 1 + \sum_j \frac{b_j}{d_j - x}$</span>. Adapted from Example 2,  https://doi.org/10.48550/arXiv.2204.02326 Given the largest pole <span>$x_p$</span> we transform the input according to <span>$w(x_i) = \frac{1}{x} + x_p$</span> and then  procede with the modified Newton algorithm (using the chain rule): <span>$x_{(n+1)} = x_{(n)} + f(w(x_i)) \cdot  (f&#39;(w(x_i)))^{-1} (w&#39;(x_i))^{-1}$</span></p><p>For debugging purposes, there are also <a href="#LadderDGA.LambdaCorrection.newton_secular_trace-Tuple{Function, Function, Float64}"><code>newton_secular_trace</code></a> and <a href="@ref trace_f"><code>trace_f</code></a> available.</p><p><strong>Arguments:</strong></p><ul><li><strong><code>f</code></strong>      : function, with structure as given above.</li><li><strong><code>df</code></strong>     : derivative function, will be constructed by finite differences, if not provided.</li><li><strong><code>xp</code></strong>     : largest pole, it is guaranteed, that there is exactly one root larger than this, which will be returned by the algorithm. </li><li><strong><code>nsteps</code></strong> : maximum number of steps</li><li><strong><code>atol</code></strong>   : convergence criterion, i.e. <span>$|f(x_0)| &lt;$</span> <code>atol</code> will return root <code>x0</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/RootFinding.jl#LL182-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.newton_secular_trace-Tuple{Function, Function, Float64}" href="#LadderDGA.LambdaCorrection.newton_secular_trace-Tuple{Function, Function, Float64}"><code>LadderDGA.LambdaCorrection.newton_secular_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton_secular_trace(f::Function, df::Function, xp::Float64; nsteps::Int = 500, atol::Float64 = 1e-10)::Float64</code></pre><p>This is the same as <a href="#LadderDGA.LambdaCorrection.newton_secular-Tuple{Function, Function, Float64}"><code>newton_secular</code></a>, but also returns a trace of the intermediate values <code>(xi,xi_tf,fi,dfii)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/RootFinding.jl#LL227-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.reset!-Tuple{χT}" href="#LadderDGA.LambdaCorrection.reset!-Tuple{χT}"><code>LadderDGA.LambdaCorrection.reset!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reset!(χ::χT)</code></pre><p>Resets the λ-correction of the <code>χ</code> struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/common.jl#LL63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.sample_f-Union{Tuple{T}, Tuple{Function, T, T}} where T" href="#LadderDGA.LambdaCorrection.sample_f-Union{Tuple{T}, Tuple{Function, T, T}} where T"><code>LadderDGA.LambdaCorrection.sample_f</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_f(f::Function, xmin::T, xmax::T; feps_abs::Float64=1e-8, xeps_abs::Float64=1e-8, maxit::Int=1000) where T</code></pre><p>Sample a function <span>$f: \mathbb{R} \to \mathbb{R}$</span> over the interval <span>$[xmin, xmax]$</span> by repeatedly bisecting intervals, that cannot be approximated linearly. </p><p><span>$x$</span> values will be sampled with a distance of at least <code>ϵ</code>. <span>$\delta$</span> is the bisection criterion. i.e. if <span>$|f(x_i) L_f(x_i)| | &lt;$</span> <code>feps_abs</code> for a proposed bisection point, the interval is supposed to be converged. Algorithm will stop bisection after <code>maxit</code> samples</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/helpers.jl#LL27-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.sc_converged-Tuple{λ_result}" href="#LadderDGA.LambdaCorrection.sc_converged-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.sc_converged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sc_converged(r::λ_result)</code></pre><p>Checks for self-consistency convergence. Returns <code>true</code> if method does not invlove a self-consistency loop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/Types.jl#LL163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.validate-Tuple{λ_result}" href="#LadderDGA.LambdaCorrection.validate-Tuple{λ_result}"><code>LadderDGA.LambdaCorrection.validate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validation(r::λ_result)</code></pre><p>Returns <code>Tuple</code> with check for (density, Pauli-principle, potential energy), both checked between one- and two-particle level against <code>λ_result.eps_abs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/Types.jl#LL151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.validate_EPot-Tuple{Float64, χT, χT, Float64, Float64}" href="#LadderDGA.LambdaCorrection.validate_EPot-Tuple{Float64, χT, χT, Float64, Float64}"><code>LadderDGA.LambdaCorrection.validate_EPot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_EPot(χm::χT, χd::χT, λm::Float64, n::Float64)</code></pre><p>Returns .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/conditions_singleCore.jl#LL103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.validate_PP-Tuple{χT, χT, Float64, Float64, Float64}" href="#LadderDGA.LambdaCorrection.validate_PP-Tuple{χT, χT, Float64, Float64, Float64}"><code>LadderDGA.LambdaCorrection.validate_PP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_PP(χm::χT, χd::χT, λm::Float64, λd::Float64, n::Float64)</code></pre><p>Returns .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/conditions_singleCore.jl#LL94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.validate_sums-Tuple{Dispersions.KGrid, χT, Float64}" href="#LadderDGA.LambdaCorrection.validate_sums-Tuple{Dispersions.KGrid, χT, Float64}"><code>LadderDGA.LambdaCorrection.validate_sums</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">validate_sums(kG::KGrid, χr::χT[, λr::Float64])</code></pre><p>Returns <span>$\sum_k \sum_\omega \chi^{\lambda_r,\omega}_{r,q} - \sum_\omega \sum_k \chi^{\lambda_r,\omega}_{r,q}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/conditions_singleCore.jl#LL76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λ_correction-Tuple{Symbol, χT, γT, χT, γT, Any, lDΓAHelper}" href="#LadderDGA.LambdaCorrection.λ_correction-Tuple{Symbol, χT, γT, χT, γT, Any, lDΓAHelper}"><code>LadderDGA.LambdaCorrection.λ_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λ_correction(type::Symbol, χm::χT, γm::γT, χd::χT, γd::γT, λ₀, h::lDΓAHelper; 
             λm_rhs_type::Symbol=:native, fit_μ::Bool=true, 
             νmax::Int=eom_ν_cutoff(h), λ_min_δ::Float64 = 0.0001,
             maxit::Int=100, mixing::Float64=0.2, conv_abs::Float64=1e-8, trace::Bool=false,
             λ_val_only::Bool=false, verbose::Bool=false, validation_threshold::Float64=1e-8, tc::Bool=true)</code></pre><p>Executes λ-correction.  TODO: finish docu</p><p><strong>Arguments</strong></p><ul><li><strong><code>type</code></strong> : <code>Symbol</code>, options are <code>:m</code>, <code>:dm</code>, <code>:m_sc</code>, <code>:dm_sc</code>, <code>:m_tsc</code> and <code>:dm_tsc</code></li><li><strong><code>χm</code></strong>   :</li><li><strong><code>γm</code></strong>   :</li><li><strong><code>χd</code></strong>   :</li><li><strong><code>γd</code></strong>   :</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/conditions_singleCore.jl#LL12-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}" href="#LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λdm_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λdm_correction(χm::χT,γm::γT,χd::χT, γd::γT,λ₀::Array{ComplexF64,3}, h;
                    validation_threshold::Float64 = 1e-8, max_steps_m::Int = 2000, max_steps_dm::Int = 2000, log_io = devnull
)</code></pre><p>Computes the <code>λm</code> and <code>λd</code> parameters for the consistency of Pauli principle and potential energie on one- and two-particle level. Returns a <a href="#LadderDGA.LambdaCorrection.λ_result"><code>λ_result</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_dm_correction.jl#LL11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λdm_correction_val-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}" href="#LadderDGA.LambdaCorrection.λdm_correction_val-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λdm_correction_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λdm_correction_val(χm::χT,γm::γT,χd::χT, γd::γT,λ₀::Array{ComplexF64,3}, h;
                    validation_threshold::Float64 = 1e-8, max_steps_m::Int = 2000, max_steps_dm::Int = 2000, log_io = devnull
)</code></pre><p>Computes the <code>λm</code> and <code>λd</code> parameters for the consistency of Pauli principle and potential energie on one- and two-particle level. Returns the bare λ-values, usually one should run <a href="#LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>λdm_correction</code></a>, which returns a <a href="#LadderDGA.LambdaCorrection.λ_result"><code>λ_result</code></a> object  that stores additional consistency checks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_dm_correction.jl#LL28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λdm_sc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}" href="#LadderDGA.LambdaCorrection.λdm_sc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λdm_sc_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λdm_sc_correction(χm::χT,γm::γT,χd::χT, γd::γT,λ₀::λ₀T, h;
                       validation_threshold::Float64 = 1e-8,
                       max_steps_m::Int = 2000, max_steps_dm::Int = 2000, max_steps_sc::Int = 2000,
                       log_io = devnull, tc = true)</code></pre><p>Runs partial self-consistency loop (update of propagators in equation of motion) within <a href="#LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>λdm correction</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_sc_correction.jl#LL32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λdm_tsc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}" href="#LadderDGA.LambdaCorrection.λdm_tsc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λdm_tsc_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λdm_tsc_correction(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::Array{ComplexF64,3}, h, sP, mP;
                    validation_threshold::Float64 = 1e-8, log_io = devnull
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_tsc_correction.jl#LL29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}" href="#LadderDGA.LambdaCorrection.λm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λm_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λm_correction(χm::χT,γm::γT,χd::χT,γd::γT,λ₀::Array{ComplexF64,3},h::lDΓAHelper;
                   νmax::Int = eom_ν_cutoff(h), fit_μ::Bool = true, tc = true, 
                   validation_threshold::Float64 = 1e-8, log_io = devnull</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_m_correction.jl#LL54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λm_correction_val-Tuple{χT, Float64, Any}" href="#LadderDGA.LambdaCorrection.λm_correction_val-Tuple{χT, Float64, Any}"><code>LadderDGA.LambdaCorrection.λm_correction_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λm_correction_val(χm::χT, rhs::Float64, h::lDΓAHelper)
λm_correction_val(χm::χT, rhs::Float64, kG::KGrid, ωn2_tail)</code></pre><p>Used internally for performance reasons (because the <span>$\lambda_\mathrm{d}$</span> correction needs this calculation repeatedly), see <a href="#LadderDGA.LambdaCorrection.λm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>λm_correction</code></a> for the user-sided version. Calculates <span>$\lambda_\mathrm{m}$</span> value, by fixing <span>$\sum_{q,\omega} \chi^{\lambda,\omega}_{\uparrow\uparrow}(q,i\omega) = \frac{n}{2}(1-\frac{n}{2})$</span>. This is only calculates the value and validation numbers and does not return a full <code>λ_result</code> object. </p><p>TODO: finish docu</p><p><strong>Arguments</strong></p><ul><li><strong><code>χm</code></strong>        :</li><li><strong><code>rhs</code></strong>       :</li><li><strong><code>h</code></strong>         :</li><li><strong><code>ωn2_tail</code></strong> :</li><li><strong><code>verbose</code></strong>   :</li><li><strong><code>ωn2_tail</code></strong> :</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_m_correction.jl#LL68-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λm_rhs-Tuple{χT, χT, LadderDGA.RunHelper}" href="#LadderDGA.LambdaCorrection.λm_rhs-Tuple{χT, χT, LadderDGA.RunHelper}"><code>LadderDGA.LambdaCorrection.λm_rhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λm_rhs(χm::χT, χd::χT, h::RunHelper; λd::Float64=NaN, λ_rhs = :native, verbose=false)
λm_rhs(imp_density::Float64, χm::χT, χd::χT, λd::Float64, kG::KGrid, mP::ModelParameters, sP::SimulationParameters, λ_rhs = :native)</code></pre><p>Helper function for the right hand side of the Pauli principle conditions (λm correction). <code>imp_density</code> can be set to <code>NaN</code>, if the rhs (<span>$\frac{n}{2}(1-\frac{n}{2})$</span>) should not be error-corrected (not ncessary or usefull when asymptotic improvement are active). TODO: write down formula, explain imp_density as compensation to DMFT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_m_correction.jl#LL12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λm_sc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}" href="#LadderDGA.LambdaCorrection.λm_sc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λm_sc_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λdm_sc_correction(χm::χT,γm::γT,χd::χT, γd::γT,λ₀::λ₀T, h;
                       validation_threshold::Float64 = 1e-8,
                       max_steps_m::Int = 2000, max_steps_dm::Int = 2000, max_steps_sc::Int = 2000,
                       log_io = devnull, tc = true)</code></pre><p>Runs partial self-consistency loop (update of propagators in equation of motion) within <a href="#LadderDGA.LambdaCorrection.λdm_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>λdm correction</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_sc_correction.jl#LL11-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.λm_tsc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}" href="#LadderDGA.LambdaCorrection.λm_tsc_correction-Tuple{χT, γT, χT, γT, Array{ComplexF64, 3}, Any}"><code>LadderDGA.LambdaCorrection.λm_tsc_correction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">λm_tsc_correction(χm::χT, γm::γT, χd::χT, γd::γT, λ₀::Array{ComplexF64,3}, h, sP, mP;
                    validation_threshold::Float64 = 1e-8, log_io = devnull
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/lambda_tsc_correction.jl#LL11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.χ_λ!-Tuple{χT, χT, Float64}" href="#LadderDGA.LambdaCorrection.χ_λ!-Tuple{χT, χT, Float64}"><code>LadderDGA.LambdaCorrection.χ_λ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">χ_λ!(χ_destination::[AbstractArray,χT], [χ::[AbstractArray,χT], ] λ::Float64)</code></pre><p>Inplace version of <a href="#LadderDGA.LambdaCorrection.χ_λ-Tuple{Float64, Float64}"><code>χ_λ</code></a>. If the second argument is omitted, results are stored in the input <code>χ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/common.jl#LL31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LadderDGA.LambdaCorrection.χ_λ-Tuple{Float64, Float64}" href="#LadderDGA.LambdaCorrection.χ_λ-Tuple{Float64, Float64}"><code>LadderDGA.LambdaCorrection.χ_λ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">χ_λ(χ::[Float64,ComplexF64,AbstractArray,χT], λ::Float64)</code></pre><p>Computes the λ-corrected susceptibility:  <span>$\chi^{\lambda,\omega}_q = \frac{1}{1 / \chi^{\lambda,\omega}_q + \lambda}$</span>. The susceptibility <span>$\chi$</span> can be either given element wise, or as χT See also <a href="#LadderDGA.χT"><code>χT</code></a> in LadderDGA.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Atomtomate/LadderDGA.jl/blob/5c2c5316bbf5eb5152cfaecc50dc5409defecae8/src/LambdaCorrection/common.jl#LL11-L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="deps/">Dependencies »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 26 May 2024 14:12">Sunday 26 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
